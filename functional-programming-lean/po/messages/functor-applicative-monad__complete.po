#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/functor-applicative-monad/complete.md:3
#, fuzzy
msgid ""
"Now that all the relevant language features have been presented, this "
"section describes the complete, honest definitions of `Functor`, "
"`Applicative`, and `Monad` as they occur in the Lean standard library. For "
"the sake of understanding, no details are omitted."
msgstr ""
"现在已经介绍了所有相关的语言特性，本节描述了 `Functor`、`Applicative` 和 `Monad` 在 Lean "
"标准库中出现的完整、真实的定义。为了理解，没有省略任何细节。"

#: src/functor-applicative-monad/complete.md:6
#, fuzzy
msgid "Functor"
msgstr "函子"

#: src/functor-applicative-monad/complete.md:8
#, fuzzy
msgid ""
"The complete definition of the `Functor` class makes use of universe "
"polymorphism and a default method implementation:"
msgstr "`Functor` 类的完整定义使用了宇宙多态和默认方法实现："

#: src/functor-applicative-monad/complete.md:15
#, fuzzy
msgid ""
"In this definition, `Function.comp` is function composition, which is "
"typically written with the `∘` operator. `Function.const` is the _constant "
"function_, which is a two-argument function that ignores its second "
"argument. Applying this function to only one argument produces a function "
"that always returns the same value, which is useful when an API demands a "
"function but a program doesn't need to compute different results for "
"different arguments. A simple version of `Function.const` can be written as "
"follows:"
msgstr ""
"在这个定义中，`Function.comp` 是函数组合，通常用 `∘` 运算符表示。`Function.const` 是 "
"_常量函数_，这是一个双参数函数，它忽略其第二个参数。仅对一个参数应用此函数会生成一个始终返回相同值的函数，当 API "
"要求一个函数但程序不需要为不同的参数计算不同的结果时，这很有用。`Function.const` 的一个简单版本可以写成如下："

#: src/functor-applicative-monad/complete.md:22
#, fuzzy
msgid ""
"Using it with one argument as the function argument to `List.map` "
"demonstrates its utility:"
msgstr "将其与一个参数一起用作 `List.map` 的函数参数，演示了它的效用："

#: src/functor-applicative-monad/complete.md:23
msgid ""
"```lean\n"
"#eval [1, 2, 3].map (simpleConst \"same\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/complete.md:26
msgid ""
"```output info\n"
"[\"same\", \"same\", \"same\"]\n"
"```"
msgstr ""

#: src/functor-applicative-monad/complete.md:29
#, fuzzy
msgid "The actual function has the following signature:"
msgstr "实际函数具有以下签名："

#: src/functor-applicative-monad/complete.md:33
#, fuzzy
msgid ""
"Here, the type argument `β` is an explicit argument, so the default "
"definition of `Functor.mapConst` provides an `_` argument that instructs "
"Lean to find a unique type to pass to `Function.const` that would cause the "
"program to type check. `(Function.comp map (Function.const _) : α → f β → f "
"α)` is equivalent to `fun (x : α) (y : f β) => map (fun _ => x) y`."
msgstr ""
"这里，类型参数 `β` 是一个显式参数，因此 `Functor.mapConst` 的默认定义提供了一个 `_` 参数，指示 Lean "
"找到一个唯一的类型传递给 `Function.const`，这将导致程序类型检查。`(Function.comp map (Function.const"
" _) : α → f β → f α)` 等价于 `fun (x : α) (y : f β) => map (fun _ => x) y`。"

#: src/functor-applicative-monad/complete.md:36
#, fuzzy
msgid ""
"The `Functor` type class inhabits a universe that is the greater of `u+1` "
"and `v`. Here, `u` is the level of universes accepted as arguments to `f`, "
"while `v` is the universe returned by `f`. To see why the structure that "
"implements the `Functor` type class must be in a universe that's larger than"
" `u`, begin with a simplified definition of the class:"
msgstr ""
"`Functor` 类型类存在于大于 `u+1` 和 `v` 的宇宙中。这里，`u` 是作为 `f` 参数接受的宇宙级别，而 `v` 是 `f` "
"返回的宇宙。要了解为什么实现 `Functor` 类型类的结构必须位于大于 `u` 的宇宙中，请从类的简化定义开始："

#: src/functor-applicative-monad/complete.md:43
#, fuzzy
msgid ""
"This type class's structure type is equivalent to the following inductive "
"type:"
msgstr "此类型类的结构类型等效于以下归纳类型："

#: src/functor-applicative-monad/complete.md:48
#, fuzzy
msgid ""
"The implementation of the `map` method that is passed as an argument to "
"`Functor.mk` contains a function that takes two types in `Type u` as "
"arguments. This means that the type of the function itself is in `Type "
"(u+1)`, so `Functor` must also be at a level that is at least `u+1`. "
"Similarly, other arguments to the function have a type built by applying "
"`f`, so it must also have a level that is at least `v`. All the type classes"
" in this section share this property."
msgstr ""
"`map` 方法的实现作为参数传递给 `Functor.mk`，其中包含一个将 `Type u` 中的两个类型作为参数的函数。这意味着函数本身的类型在 "
"`Type (u+1)` 中，因此 `Functor` 也必须处于至少 `u+1` 的级别。类似地，函数的其他参数具有通过应用 `f` "
"构建的类型，因此它也必须具有至少 `v` 的级别。本节中的所有类型类都共享此属性。"

#: src/functor-applicative-monad/complete.md:53
#, fuzzy
msgid "Applicative"
msgstr "应用"

#: src/functor-applicative-monad/complete.md:55
#, fuzzy
msgid ""
"The `Applicative` type class is actually built from a number of smaller "
"classes that each contain some of the relevant methods. The first are `Pure`"
" and `Seq`, which contain `pure` and `seq` respectively:"
msgstr ""
"`Applicative` 类型类实际上是由许多较小的类构建的，每个类都包含一些相关方法。第一个是 `Pure` 和 `Seq`，它们分别包含 "
"`pure` 和 `seq`："

#: src/functor-applicative-monad/complete.md:65
#, fuzzy
msgid ""
"In addition to these, `Applicative` also depends on `SeqRight` and an "
"analogous `SeqLeft` class:"
msgstr "除了这些之外，`Applicative` 还依赖于 `SeqRight` 和类似的 `SeqLeft` 类："

#: src/functor-applicative-monad/complete.md:74
#, fuzzy
msgid ""
"The `seqRight` function, which was introduced in the [section about "
"alternatives and validation](alternative.md), is easiest to understand from "
"the perspective of effects. `E1 *> E2`, which desugars to `SeqRight.seqRight"
" E1 (fun () => E2)`, can be understood as first executing `E1`, and then "
"`E2`, resulting only in `E2`'s result. Effects from `E1` may result in `E2` "
"not being run, or being run multiple times. Indeed, if `f` has a `Monad` "
"instance, then `E1 *> E2` is equivalent to `do let _ ← E1; E2`, but "
"`seqRight` can be used with types like `Validate` that are not monads."
msgstr ""
"`seqRight` 函数在 [关于备选和验证](alternative.md) 的部分中介绍，从效果的角度最容易理解。`E1 *> E2`，它简化为 "
"`SeqRight.seqRight E1 (fun () => E2)`，可以理解为先执行 `E1`，然后执行 `E2`，仅产生 `E2` "
"的结果。`E1` 的效果可能导致 `E2` 不运行或运行多次。事实上，如果 `f` 有一个 `Monad` 实例，那么 `E1 *> E2` 等价于 "
"`do let _ ← E1; E2`，但是 `seqRight` 可以与不是单子的类型（如 `Validate`）一起使用。"

#: src/functor-applicative-monad/complete.md:79
#, fuzzy
msgid ""
"Its cousin `seqLeft` is very similar, except the leftmost expression's value"
" is returned. `E1 <* E2` desugars to `SeqLeft.seqLeft E1 (fun () => E2)`. "
"`SeqLeft.seqLeft` has type `f α → (Unit → f β) → f α`, which is identical to"
" that of `seqRight` except for the fact that it returns `f α`. `E1 <* E2` "
"can be understood as a program that first executes `E1`, and then `E2`, "
"returning the original result for `E1`. If `f` has a `Monad` instance, then "
"`E1 <* E2` is equivalent to `do let x ← E1; _ ← E2; pure x`. Generally "
"speaking, `seqLeft` is useful for specifying extra conditions on a value in "
"a validation or parser-like workflow without changing the value itself."
msgstr ""
"它的表亲 `seqLeft` 非常相似，除了返回最左边的表达式的值。`E1 <* E2` 简化为 `SeqLeft.seqLeft E1 (fun ()"
" => E2)`。`SeqLeft.seqLeft` 的类型为 `f α → (Unit → f β) → f α`，它与 `seqRight` "
"的类型相同，除了它返回 `f α`。`E1 <* E2` 可以理解为一个程序，它首先执行 `E1`，然后执行 `E2`，返回 `E1` 的原始结果。如果"
" `f` 有一个 `Monad` 实例，那么 `E1 <* E2` 等价于 `do let x ← E1; _ ← E2; pure "
"x`。一般来说，`seqLeft` 对于在验证或类似解析器的流程中指定值的额外条件很有用，而无需更改值本身。"

#: src/functor-applicative-monad/complete.md:86
#, fuzzy
msgid ""
"The definition of `Applicative` extends all these classes, along with "
"`Functor`:"
msgstr "`Applicative` 的定义扩展了所有这些类，以及 `Functor`："

#: src/functor-applicative-monad/complete.md:93
#, fuzzy
msgid ""
"A complete definition of `Applicative` requires only definitions for `pure` "
"and `seq`. This is because there are default definitions for all of the "
"methods from `Functor`, `SeqLeft`, and `SeqRight`. The `mapConst` method of "
"`Functor` has its own default implementation in terms of `Functor.map`. "
"These default implementations should only be overridden with new functions "
"that are behaviorally equivalent, but more efficient. The default "
"implementations should be seen as specifications for correctness as well as "
"automatically-created code."
msgstr ""
"`Applicative` 的完整定义只需要 `pure` 和 `seq` 的定义。这是因为 `Functor`、`SeqLeft` 和 "
"`SeqRight` 的所有方法都有默认定义。`Functor` 的 `mapConst` 方法有自己的默认实现，即 "
"`Functor.map`。这些默认实现只应被行为等效但效率更高的新函数覆盖。默认实现应被视为正确性的规范以及自动创建的代码。"

#: src/functor-applicative-monad/complete.md:99
#, fuzzy
msgid ""
"The default implementation for `seqLeft` is very compact. Replacing some of "
"the names with their syntactic sugar or their definitions can provide "
"another view on it, so:"
msgstr "`seqLeft` 的默认实现非常简洁。用它们的语法糖或定义替换一些名称可以提供另一种视图，因此："

#: src/functor-applicative-monad/complete.md:104
#, fuzzy
msgid "becomes"
msgstr "变为"

#: src/functor-applicative-monad/complete.md:108
#, fuzzy
msgid ""
"How should `(fun x _ => x) <$> a` be understood? Here, `a` has type `f α`, "
"and `f` is a functor. If `f` is `List`, then `(fun x _ => x) <$> [1, 2, 3]` "
"evaluates to `[fun _ => 1, fun _ => 2, fun _ => 3]`. If `f` is `Option`, "
"then `(fun x _ => x) <$> some \"hello\"` evaluates to `some (fun _ => "
"\"hello\")`. In each case, the values in the functor are replaced by "
"functions that return the original value, ignoring their argument. When "
"combined with `seq`, this function discards the values from `seq`'s second "
"argument."
msgstr ""
"如何理解 `(fun x _ => x) <$> a`？此处，`a` 的类型为 `f α`，而 `f` 是一个函子。如果 `f` 是 `List`，则 "
"`(fun x _ => x) <$> [1, 2, 3]` 的值为 `[fun _ => 1, fun _ => 2, fun _ => 3]`。如果"
" `f` 是 `Option`，则 `(fun x _ => x) <$> some \"hello\"` 的值为 `some (fun _ => "
"\"hello\")`。在每种情况下，函子中的值都会被返回原始值的函数替换，而忽略它们的实参。与 `seq` 结合使用时，此函数会丢弃 `seq` "
"第二个实参中的值。"

#: src/functor-applicative-monad/complete.md:115
#, fuzzy
msgid ""
"The default implementation for `seqRight` is very similar, except `const` "
"has an additional argument `id`. This definition can be understood "
"similarly, by first introducing some standard syntactic sugar and then "
"replacing some names with their definitions:"
msgstr ""
"`seqRight` 的默认实现非常相似，除了 `const` 有一个附加实参 "
"`id`。此定义可以类似地理解，首先引入一些标准语法糖，然后用它们的定义替换一些名称："

#: src/functor-applicative-monad/complete.md:126
#, fuzzy
msgid ""
"How should `(fun _ x => x) <$> a` be understood? Once again, examples are "
"useful. `(fun _ x => x) <$> [1, 2, 3]` is equivalent to `[fun x => x, fun x "
"=> x, fun x => x]`, and `(fun _ x => x) <$> some \"hello\"` is equivalent to"
" `some (fun x => x)`. In other words, `(fun _ x => x) <$> a` preserves the "
"overall shape of `a`, but each value is replaced by the identity function. "
"From the perspective of effects, the side effects of `a` occur, but the "
"values are thrown out when it is used with `seq`."
msgstr ""
"如何理解 `(fun _ x => x) <$> a`？同样，示例很有用。`(fun _ x => x) <$> [1, 2, 3]` 等价于 "
"`[fun x => x, fun x => x, fun x => x]`，而 `(fun _ x => x) <$> some \"hello\"`"
" 等价于 `some (fun x => x)`。换句话说，`(fun _ x => x) <$> a` 保留了 `a` "
"的整体形状，但每个值都被恒等函数替换。从效果的角度来看，`a` 的副作用会发生，但当它与 `seq` 一起使用时，这些值会被丢弃。"

#: src/functor-applicative-monad/complete.md:132
#, fuzzy
msgid "Monad"
msgstr "Monad"

#: src/functor-applicative-monad/complete.md:134
#, fuzzy
msgid ""
"Just as the constituent operations of `Applicative` are split into their own"
" type classes, `Bind` has its own class as well:"
msgstr "正如 `Applicative` 的组成操作被拆分为它们自己的类型类一样，`Bind` 也有自己的类："

#: src/functor-applicative-monad/complete.md:139
#, fuzzy
msgid "`Monad` extends `Applicative` with `Bind`:"
msgstr "`Monad` 用 `Bind` 扩展了 `Applicative`："

#: src/functor-applicative-monad/complete.md:147
#, fuzzy
msgid ""
"Tracing the collection of inherited methods and default methods from the "
"entire hierarchy shows that a `Monad` instance requires only implementations"
" of `bind` and `pure`. In other words, `Monad` instances automatically yield"
" implementations of `seq`, `seqLeft`, `seqRight`, `map`, and `mapConst`. "
"From the perspective of API boundaries, any type with a `Monad` instance "
"gets instances for `Bind`, `Pure`, `Seq`, `Functor`, `SeqLeft`, and "
"`SeqRight`."
msgstr ""
"从整个层次结构中追踪继承的方法和默认方法的集合可以看出，`Monad` 实例只需要 `bind` 和 `pure` 的实现。换句话说，`Monad` "
"实例会自动生成 `seq`、`seqLeft`、`seqRight`、`map` 和 `mapConst` 的实现。从 API 边界的角度来看，任何具有"
" `Monad` 实例的类型都会获得 `Bind`、`Pure`、`Seq`、`Functor`、`SeqLeft` 和 `SeqRight` 的实例。"

#: src/functor-applicative-monad/complete.md:154
#, fuzzy
msgid ""
"Understand the default implementations of `map`, `seq`, `seqLeft`, and "
"`seqRight` in `Monad` by working through examples such as `Option` and "
"`Except`. In other words, substitute their definitions for `bind` and `pure`"
" into the default definitions, and simplify them to recover the versions "
"`map`, `seq`, `seqLeft`, and `seqRight` that would be written by hand."
msgstr ""
"通过处理诸如 `Option` 和 `Except` 的示例来理解 `Monad` 中 `map`、`seq`、`seqLeft` 和 "
"`seqRight` 的默认实现。换句话说，将它们的定义替换为 `bind` 和 `pure` 的默认定义，并对其进行简化以恢复手动编写的 "
"`map`、`seq`、`seqLeft` 和 `seqRight` 版本。"

#: src/functor-applicative-monad/complete.md:155
#, fuzzy
msgid ""
"On paper or in a text file, prove to yourself that the default "
"implementations of `map` and `seq` satisfy the contracts for `Functor` and "
"`Applicative`. In this argument, you're allowed to use the rules from the "
"`Monad` contract as well as ordinary expression evaluation."
msgstr ""
"在纸上或文本文件中，向自己证明 `map` 和 `seq` 的默认实现满足 `Functor` 和 `Applicative` "
"的契约。在此论证中，你可以使用 `Monad` 契约中的规则以及普通的表达式求值。"
