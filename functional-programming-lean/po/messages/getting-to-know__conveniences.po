#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/getting-to-know/conveniences.md:3
#, fuzzy
msgid ""
"Lean contains a number of convenience features that make programs much more "
"concise."
msgstr "Lean 包含许多便利功能，使程序更加简洁。"

#: src/getting-to-know/conveniences.md:5
#, fuzzy
msgid "Automatic Implicit Arguments"
msgstr "自动隐式参数"

#: src/getting-to-know/conveniences.md:7
#, fuzzy
msgid ""
"When writing polymorphic functions in Lean, it is typically not necessary to"
" list all the implicit arguments. Instead, they can simply be mentioned. If "
"Lean can determine their type, then they are automatically inserted as "
"implicit arguments. In other words, the previous definition of `length`:"
msgstr ""
"在 Lean 中编写多态函数时，通常不必列出所有隐式参数。相反，它们可以简单地被提及。如果 Lean "
"可以确定它们的类型，那么它们将自动插入为隐式参数。换句话说，`length` 的先前定义："

#: src/getting-to-know/conveniences.md:17
#, fuzzy
msgid "can be written without `{α : Type}`:"
msgstr "可以不写 `{α : Type}`："

#: src/getting-to-know/conveniences.md:24
#, fuzzy
msgid ""
"This can greatly simplify highly polymorphic definitions that take many "
"implicit arguments."
msgstr "这可以极大简化需要很多隐式参数的高级多态定义。"

#: src/getting-to-know/conveniences.md:26
#, fuzzy
msgid "Pattern-Matching Definitions"
msgstr "模式匹配定义"

#: src/getting-to-know/conveniences.md:28
#, fuzzy
msgid ""
"When defining functions with `def`, it is quite common to name an argument "
"and then immediately use it with pattern matching. For instance, in "
"`length`, the argument `xs` is used only in `match`. In these situations, "
"the cases of the `match` expression can be written directly, without naming "
"the argument at all."
msgstr ""
"用 `def` 定义函数时，通常会给参数命名，然后立即用模式匹配使用它。例如，在 `length` 中，参数 `xs` 仅在 `match` "
"中使用。在这些情况下，`match` 表达式的 case 可以直接编写，而无需给参数命名。"

#: src/getting-to-know/conveniences.md:32
#, fuzzy
msgid ""
"The first step is to move the arguments' types to the right of the colon, so"
" the return type is a function type. For instance, the type of `length` is "
"`List α → Nat`. Then, replace the `:=` with each case of the pattern match:"
msgstr ""
"第一步是将参数类型移到冒号的右侧，因此返回类型是函数类型。例如，`length` 的类型是 `List α → Nat`。然后，用模式匹配的每个 "
"case 替换 `:=`："

#: src/getting-to-know/conveniences.md:41
#, fuzzy
msgid ""
"This syntax can also be used to define functions that take more than one "
"argument. In this case, their patterns are separated by commas. For "
"instance, `drop` takes a number \\\\( n \\\\) and a list, and returns the "
"list after removing the first \\\\( n \\\\) entries."
msgstr ""
"此语法还可用于定义接受多个参数的函数。在这种情况下，它们的模式用逗号分隔。例如，`drop` 接受一个数字 \\\\( n \\\\) "
"和一个列表，并返回删除前 \\\\( n \\\\) 个条目的列表。"

#: src/getting-to-know/conveniences.md:51
#, fuzzy
msgid ""
"Named arguments and patterns can also be used in the same definition. For "
"instance, a function that takes a default value and an optional value, and "
"returns the default when the optional value is `none`, can be written:"
msgstr "命名参数和模式也可以在同一定义中使用。例如，一个函数接受一个默认值和一个可选值，当可选值为 `none` 时返回默认值，可以写成："

#: src/getting-to-know/conveniences.md:58
#, fuzzy
msgid ""
"This function is called `Option.getD` in the standard library, and can be "
"called with dot notation:"
msgstr "此函数在标准库中称为 `Option.getD`，可以用点表示法调用："

#: src/getting-to-know/conveniences.md:59
#, fuzzy
msgid ""
"```lean\n"
"#eval (some \"salmonberry\").getD \"\"\n"
"```"
msgstr ""
"```lean\n"
"#eval (some \"salmonberry\").getD \"\"\n"
"```"

#: src/getting-to-know/conveniences.md:62
#, fuzzy
msgid ""
"```output info\n"
"\"salmonberry\"\n"
"```"
msgstr ""
"```output info\n"
"\"salmonberry\"\n"
"```"

#: src/getting-to-know/conveniences.md:65
#, fuzzy
msgid ""
"```lean\n"
"#eval none.getD \"\"\n"
"```"
msgstr ""
"```lean\n"
"#eval none.getD \"\"\n"
"```"

#: src/getting-to-know/conveniences.md:68
#, fuzzy
msgid ""
"```output info\n"
"\"\"\n"
"```"
msgstr ""
"```output info\n"
"\"\"\n"
"```"

#: src/getting-to-know/conveniences.md:72
#, fuzzy
msgid "Local Definitions"
msgstr "局部定义"

#: src/getting-to-know/conveniences.md:74
#, fuzzy
msgid ""
"It is often useful to name intermediate steps in a computation. In many "
"cases, intermediate values represent useful concepts all on their own, and "
"naming them explicitly can make the program easier to read. In other cases, "
"the intermediate value is used more than once. As in most other languages, "
"writing down the same code twice in Lean causes it to be computed twice, "
"while saving the result in a variable leads to the result of the computation"
" being saved and re-used."
msgstr ""
"在计算中对中间步骤命名通常很有用。在许多情况下，中间值本身就代表有用的概念，明确地命名它们可以使程序更易于阅读。在其他情况下，中间值被使用多次。与大多数其他语言一样，在"
" Lean 中两次写下相同的代码会导致计算两次，而将结果保存在变量中会导致计算的结果被保存并重新使用。"

#: src/getting-to-know/conveniences.md:79
#, fuzzy
msgid ""
"For instance, `unzip` is a function that transforms a list of pairs into a "
"pair of lists. When the list of pairs is empty, then the result of `unzip` "
"is a pair of empty lists. When the list of pairs has a pair at its head, "
"then the two fields of the pair are added to the result of unzipping the "
"rest of the list. This definition of `unzip` follows that description "
"exactly:"
msgstr ""
"例如，`unzip` 是一个将对列表转换为一对列表的函数。当对列表为空时，`unzip` "
"的结果是一对空列表。当对列表的头部有一个对时，则该对的两个字段将添加到解压缩列表其余部分的结果中。`unzip` 的此定义完全遵循该描述："

#: src/getting-to-know/conveniences.md:89
#, fuzzy
msgid ""
"Unfortunately, there is a problem: this code is slower than it needs to be. "
"Each entry in the list of pairs leads to two recursive calls, which makes "
"this function take exponential time. However, both recursive calls will have"
" the same result, so there is no reason to make the recursive call twice."
msgstr ""
"不幸的是，存在一个问题：此代码比需要的速度慢。对列表中的每个条目都会导致两个递归调用，这使得此函数需要指数时间。然而，两个递归调用都会有相同的结果，因此没有理由进行两次递归调用。"

#: src/getting-to-know/conveniences.md:94
#, fuzzy
msgid ""
"In Lean, the result of the recursive call can be named, and thus saved, "
"using `let`. Local definitions with `let` resemble top-level definitions "
"with `def`: it takes a name to be locally defined, arguments if desired, a "
"type signature, and then a body following `:=`. After the local definition, "
"the expression in which the local definition is available (called the _body_"
" of the `let`\\-expression) must be on a new line, starting at a column in "
"the file that is less than or equal to that of the `let` keyword. For "
"instance, `let` can be used in `unzip` like this:"
msgstr ""
"在 Lean 中，可以使用 `let` 命名递归调用的结果，从而保存它。使用 `let` 的局部定义类似于使用 `def` "
"的顶级定义：它需要一个局部定义的名称，如果需要，还需要参数、类型签名，然后是 `:=` 后面的主体。在局部定义之后，局部定义可用的表达式（称为 "
"`let` 表达式的 _body_）必须在新行上，从文件中的列开始，该列小于或等于 `let` 关键字的列。例如，`let` 可以像这样用于 "
"`unzip`："

#: src/getting-to-know/conveniences.md:105
#, fuzzy
msgid ""
"To use `let` on a single line, separate the local definition from the body "
"with a semicolon."
msgstr "要在单行上使用 `let`，请使用分号将局部定义与主体分隔开。"

#: src/getting-to-know/conveniences.md:107
#, fuzzy
msgid ""
"Local definitions with `let` may also use pattern matching when one pattern "
"is enough to match all cases of a datatype. In the case of `unzip`, the "
"result of the recursive call is a pair. Because pairs have only a single "
"constructor, the name `unzipped` can be replaced with a pair pattern:"
msgstr ""
"当一个模式足以匹配数据类型的全部情况时，使用 `let` 的局部定义也可以使用模式匹配。在 `unzip` "
"的情况下，递归调用的结果是一对。因为对只有一个构造函数，所以名称 `unzipped` 可以替换为对模式："

#: src/getting-to-know/conveniences.md:117
#, fuzzy
msgid ""
"Judicious use of patterns with `let` can make code easier to read, compared "
"to writing the accessor calls by hand."
msgstr "巧妙地使用带有 `let` 的模式可以使代码更易于阅读，而无需手动编写访问器调用。"

#: src/getting-to-know/conveniences.md:119
#, fuzzy
msgid ""
"The biggest difference between `let` and `def` is that recursive `let` "
"definitions must be explicitly indicated by writing `let rec`. For instance,"
" one way to reverse a list involves a recursive helper function, as in this "
"definition:"
msgstr ""
"`let` 和 `def` 之间最大的区别在于，递归 `let` 定义必须通过编写 `let rec` "
"明确表示。例如，反转列表的一种方法涉及递归辅助函数，如下所示："

#: src/getting-to-know/conveniences.md:128
#, fuzzy
msgid ""
"The helper function walks down the input list, moving one entry at a time "
"over to `soFar`. When it reaches the end of the input list, `soFar` contains"
" a reversed version of the input."
msgstr "辅助函数遍历输入列表，一次将一个条目移动到 `soFar`。当它到达输入列表的末尾时，`soFar` 包含输入的反转版本。"

#: src/getting-to-know/conveniences.md:132
#, fuzzy
msgid "Type Inference"
msgstr "类型推断"

#: src/getting-to-know/conveniences.md:134
#, fuzzy
msgid ""
"In many situations, Lean can automatically determine an expression's type. "
"In these cases, explicit types may be omitted from both top-level "
"definitions (with `def`) and local definitions (with `let`). For instance, "
"the recursive call to `unzip` does not need an annotation:"
msgstr ""
"在许多情况下，Lean 可以自动确定表达式的类型。在这些情况下，可以从顶级定义（使用 `def`）和局部定义（使用 `let`）中省略显式类型。例如，对"
" `unzip` 的递归调用不需要注释："

#: src/getting-to-know/conveniences.md:145
#, fuzzy
msgid ""
"As a rule of thumb, omitting the types of literal values (like strings and "
"numbers) usually works, although Lean may pick a type for literal numbers "
"that is more specific than the intended type. Lean can usually determine a "
"type for a function application, because it already knows the argument types"
" and the return type. Omitting return types for function definitions will "
"often work, but function arguments typically require annotations. "
"Definitions that are not functions, like `unzipped` in the example, do not "
"need type annotations if their bodies do not need type annotations, and the "
"body of this definition is a function application."
msgstr ""
"根据经验，省略文字值（如字符串和数字）的类型通常有效，尽管 Lean 可能会为文字数字选择比预期类型更具体的类型。Lean "
"通常可以确定函数应用程序的类型，因为它已经知道参数类型和返回类型。省略函数定义的返回类型通常有效，但函数参数通常需要注释。不是函数的定义（如示例中的 "
"`unzipped`）不需要类型注释，如果它们的正文不需要类型注释，并且此定义的正文是函数应用程序。"

#: src/getting-to-know/conveniences.md:150
#, fuzzy
msgid ""
"Omitting the return type for `unzip` is possible when using an explicit "
"`match` expression:"
msgstr "在使用显式 `match` 表达式时，可以省略 `unzip` 的返回类型："

#: src/getting-to-know/conveniences.md:161
#, fuzzy
msgid ""
"Generally speaking, it is a good idea to err on the side of too many, rather"
" than too few, type annotations. First off, explicit types communicate "
"assumptions about the code to readers. Even if Lean can determine the type "
"on its own, it can still be easier to read code without having to repeatedly"
" query Lean for type information. Secondly, explicit types help localize "
"errors. The more explicit a program is about its types, the more informative"
" the error messages can be. This is especially important in a language like "
"Lean that has a very expressive type system. Thirdly, explicit types make it"
" easier to write the program in the first place. The type is a "
"specification, and the compiler's feedback can be a helpful tool in writing "
"a program that meets the specification. Finally, Lean's type inference is a "
"best-effort system. Because Lean's type system is so expressive, there is no"
" \"best\" or most general type to find for all expressions. This means that "
"even if you get a type, there's no guarantee that it's the _right_ type for "
"a given application. For instance, `14` can be a `Nat` or an `Int`:"
msgstr ""
"一般来说，宁可多加类型注释，也不要太少。首先，显式类型向读者传达了对代码的假设。即使 Lean 可以自行确定类型，但无需反复查询 Lean "
"以获取类型信息，代码仍然更容易阅读。其次，显式类型有助于定位错误。程序对其类型越明确，错误消息就越有信息量。这在 Lean "
"这样的具有非常丰富的类型系统的语言中尤为重要。第三，显式类型使编写程序变得更容易。类型是一种规范，编译器的反馈可以成为编写符合规范的程序的有用工具。最后，Lean"
" 的类型推断是一种尽力而为的系统。由于 Lean "
"的类型系统非常丰富，因此无法为所有表达式找到“最佳”或最通用的类型。这意味着即使你得到了一个类型，也不能保证它是给定应用程序的“正确”类型。例如，`14`"
" 可以是 `Nat` 或 `Int`："

#: src/getting-to-know/conveniences.md:186
#, fuzzy
msgid ""
"Missing type annotations can give confusing error messages. Omitting all "
"types from the definition of `unzip`:"
msgstr "缺少类型注释可能会导致令人困惑的错误消息。从 `unzip` 的定义中省略所有类型："

#: src/getting-to-know/conveniences.md:196
#, fuzzy
msgid "leads to a message about the `match` expression:"
msgstr "导致有关 `match` 表达式的消息："

#: src/getting-to-know/conveniences.md:201
#, fuzzy
msgid ""
"This is because `match` needs to know the type of the value being inspected,"
" but that type was not available. A \"metavariable\" is an unknown part of a"
" program, written `?m.XYZ` in error messages—they are described in the "
"[section on Polymorphism](polymorphism.md). In this program, the type "
"annotation on the argument is required."
msgstr ""
"这是因为 `match` 需要知道正在检查的值的类型，但该类型不可用。“元变量”是程序中未知的部分，在错误消息中写为 `?m.XYZ`——它们在 "
"[多态性](polymorphism.md) 一节中进行了描述。在此程序中，参数上的类型注释是必需的。"

#: src/getting-to-know/conveniences.md:205
#, fuzzy
msgid ""
"Even some very simple programs require type annotations. For instance, the "
"identity function just returns whatever argument it is passed. With argument"
" and type annotations, it looks like this:"
msgstr "即使一些非常简单的程序也需要类型注释。例如，恒等函数只返回传递给它的任何参数。使用参数和类型注释，它看起来像这样："

#: src/getting-to-know/conveniences.md:211
#, fuzzy
msgid "Lean is capable of determining the return type on its own:"
msgstr "Lean 能够自行确定返回类型："

#: src/getting-to-know/conveniences.md:215
#, fuzzy
msgid "Omitting the argument type, however, causes an error:"
msgstr "然而，省略参数类型会导致错误："

#: src/getting-to-know/conveniences.md:223
#, fuzzy
msgid ""
"In general, messages that say something like \"failed to infer\" or that "
"mention metavariables are often a sign that more type annotations are "
"necessary. Especially while still learning Lean, it is useful to provide "
"most types explicitly."
msgstr "一般来说，类似于“无法推断”或提及元变量的消息通常表示需要更多类型注释。特别是在学习 Lean 时，显式提供大多数类型是有用的。"

#: src/getting-to-know/conveniences.md:226
#, fuzzy
msgid "Simultaneous Matching"
msgstr "同时匹配"

#: src/getting-to-know/conveniences.md:228
#, fuzzy
msgid ""
"Pattern-matching expressions, just like pattern-matching definitions, can "
"match on multiple values at once. Both the expressions to be inspected and "
"the patterns that they match against are written with commas between them, "
"similarly to the syntax used for definitions. Here is a version of `drop` "
"that uses simultaneous matching:"
msgstr ""
"模式匹配表达式，就像模式匹配定义一样，可以一次匹配多个值。要检查的表达式和它们匹配的模式都用逗号分隔，类似于用于定义的语法。以下是使用同时匹配的 "
"`drop` 版本："

#: src/getting-to-know/conveniences.md:239
#, fuzzy
msgid "Natural Number Patterns"
msgstr "自然数模式"

#: src/getting-to-know/conveniences.md:241
#, fuzzy
msgid ""
"In the section on [datatypes and patterns](datatypes-and-patterns.md), "
"`even` was defined like this:"
msgstr "在 [数据类型和模式](datatypes-and-patterns.md) 一节中，`even` 被定义为："

#: src/getting-to-know/conveniences.md:248
#, fuzzy
msgid ""
"Just as there is special syntax to make list patterns more readable than "
"using `List.cons` and `List.nil` directly, natural numbers can be matched "
"using literal numbers and `+`. For instance, `even` can also be defined like"
" this:"
msgstr ""
"就像有特殊语法使列表模式比直接使用 `List.cons` 和 `List.nil` 更具可读性一样，自然数可以使用字面数字和 `+` "
"进行匹配。例如，`even` 也可以这样定义："

#: src/getting-to-know/conveniences.md:256
#, fuzzy
msgid ""
"In this notation, the arguments to the `+` pattern serve different roles. "
"Behind the scenes, the left argument (`n` above) becomes an argument to some"
" number of `Nat.succ` patterns, and the right argument (`1` above) "
"determines how many `Nat.succ`s to wrap around the pattern. The explicit "
"patterns in `halve`, which divides a `Nat` by two and drops the remainder:"
msgstr ""
"在此表示法中，`+` 模式的参数扮演着不同的角色。在幕后，左参数（上面的 `n`）成为一些 `Nat.succ` 模式的参数，右参数（上面的 "
"`1`）确定围绕模式包装多少个 `Nat.succ`。`halve` 中的显式模式，它将 `Nat` 除以二并丢弃余数："

#: src/getting-to-know/conveniences.md:265
#, fuzzy
msgid "can be replaced by numeric literals and `+`:"
msgstr ""
"幕后，这两个定义完全等价。记住：`halve n + 1` 等价于 `(halve n) + 1`，而不是 `halve (n + 1)`。"

#: src/getting-to-know/conveniences.md:272
#, fuzzy
msgid ""
"Behind the scenes, both definitions are completely equivalent. Remember: "
"`halve n + 1` is equivalent to `(halve n) + 1`, not `halve (n + 1)`."
msgstr "使用此语法时，`+` 的第二个参数应始终为文字 `Nat`。即使加法是可交换的，在模式中翻转参数也会导致以下错误："

#: src/getting-to-know/conveniences.md:275
#, fuzzy
msgid ""
"When using this syntax, the second argument to `+` should always be a "
"literal `Nat`. Even though addition is commutative, flipping the arguments "
"in a pattern can result in errors like the following:"
msgstr "此限制使 Lean 能够将模式中所有 `+` 符号的用法转换为底层 `Nat.succ` 的用法，从而在幕后使语言更简单。"

#: src/getting-to-know/conveniences.md:287
#, fuzzy
msgid ""
"This restriction enables Lean to transform all uses of the `+` notation in a"
" pattern into uses of the underlying `Nat.succ`, keeping the language "
"simpler behind the scenes."
msgstr "匿名函数"

#: src/getting-to-know/conveniences.md:289
#, fuzzy
msgid "Anonymous Functions"
msgstr ""
"Lean 中的函数不必在顶层定义。作为表达式，函数使用 `fun` 语法生成。函数表达式以关键字 `fun` 开头，后跟一个或多个参数，这些参数使用 "
"`=>` 与返回表达式分隔。例如，可以编写一个将数字加 1 的函数："

#: src/getting-to-know/conveniences.md:291
#, fuzzy
msgid ""
"Functions in Lean need not be defined at the top level. As expressions, "
"functions are produced with the `fun` syntax. Function expressions begin "
"with the keyword `fun`, followed by one or more arguments, which are "
"separated from the return expression using `=>`. For instance, a function "
"that adds one to a number can be written:"
msgstr "类型注释的编写方式与 `def` 相同，使用括号和冒号："

#: src/getting-to-know/conveniences.md:301
#, fuzzy
msgid ""
"Type annotations are written the same way as on `def`, using parentheses and"
" colons:"
msgstr "同样，隐式参数可以用大括号编写："

#: src/getting-to-know/conveniences.md:308
#, fuzzy
msgid "Similarly, implicit arguments may be written with curly braces:"
msgstr ""
"这种匿名函数表达式风格通常称为 _lambda 表达式_，因为编程语言的数学描述中使用的典型符号在 Lean 中使用关键字 `fun` "
"的地方使用了希腊字母 λ（lambda）。即使 Lean 允许使用 `λ` 代替 `fun`，但最常见的是编写 `fun`。"

#: src/getting-to-know/conveniences.md:315
#, fuzzy
msgid ""
"This style of anonymous function expression is often referred to as a "
"_lambda expression_, because the typical notation used in mathematical "
"descriptions of programming languages uses the Greek letter λ (lambda) where"
" Lean has the keyword `fun`. Even though Lean does permit `λ` to be used "
"instead of `fun`, it is most common to write `fun`."
msgstr "匿名函数还支持 `def` 中使用的多模式样式。例如，可以编写一个返回自然数的前驱（如果存在）的函数："

#: src/getting-to-know/conveniences.md:318
#, fuzzy
msgid ""
"Anonymous functions also support the multiple-pattern style used in `def`. "
"For instance, a function that returns the predecessor of a natural number if"
" it exists can be written:"
msgstr "匿名函数也支持 `def` 中使用的多模式样式。例如，可以编写一个返回自然数的前驱（如果存在）的函数："

#: src/getting-to-know/conveniences.md:331
#, fuzzy
msgid ""
"Note that Lean's own description of the function has a named argument and a "
"`match` expression. Many of Lean's convenient syntactic shorthands are "
"expanded to simpler syntax behind the scenes, and the abstraction sometimes "
"leaks."
msgstr ""
"注意，Lean 函数的描述本身有一个命名参数和一个 `match` 表达式。Lean 的许多便捷语法缩写都扩展为幕后的更简单的语法，并且抽象有时会泄漏。"

#: src/getting-to-know/conveniences.md:334
#, fuzzy
msgid ""
"Definitions using `def` that take arguments may be rewritten as function "
"expressions. For instance, a function that doubles its argument can be "
"written as follows:"
msgstr "使用 `def` 定义的参数可以重写为函数表达式。例如，可以将将参数加倍的函数写成如下形式："

#: src/getting-to-know/conveniences.md:342
#, fuzzy
msgid ""
"When an anonymous function is very simple, like `fun x => x + 1`, the syntax"
" for creating the function can be fairly verbose. In that particular "
"example, six non-whitespace characters are used to introduce the function, "
"and its body consists of only three non-whitespace characters. For these "
"simple cases, Lean provides a shorthand. In an expression surrounded by "
"parentheses, a centered dot character `·` can stand for an argument, and the"
" expression inside the parentheses becomes the function's body. That "
"particular function can also be written `(· + 1)`."
msgstr ""
"当匿名函数非常简单时，例如 `fun x => x + "
"1`，创建函数的语法可能相当冗长。在那个特定的示例中，六个非空白字符用于引入函数，其主体仅包含三个非空白字符。对于这些简单的情况，Lean "
"提供了一个简写。在括号包围的表达式中，居中的点字符 `·` 可以表示一个参数，括号内的表达式成为函数的主体。那个特定的函数也可以写成 `(· + "
"1)`。"

#: src/getting-to-know/conveniences.md:348
#, fuzzy
msgid ""
"The centered dot always creates a function out of the _closest_ surrounding "
"set of parentheses. For instance, `(· + 5, 3)` is a function that returns a "
"pair of numbers, while `((· + 5), 3)` is a pair of a function and a number. "
"If multiple dots are used, then they become arguments from left to right:"
msgstr ""
"居中的点总是从 _最接近_ 的一组括号中创建函数。例如，`(· + 5, 3)` 是返回一对数字的函数，而 `((· + 5), 3)` "
"是一个函数和一个数字的元组。如果使用多个点，则它们从左到右成为参数："

#: src/getting-to-know/conveniences.md:359
#, fuzzy
msgid ""
"Anonymous functions can be applied in precisely the same way as functions "
"defined using `def` or `let`. The command `#eval (fun x => x + x) 5` results"
" in:"
msgstr ""
"匿名函数可以与使用 `def` 或 `let` 定义的函数完全相同的方式应用。命令 `#eval (fun x => x + x) 5` 的结果是："

#: src/getting-to-know/conveniences.md:364
#, fuzzy
msgid "while `#eval (· * 2) 5` results in:"
msgstr "而 `#eval (· * 2) 5` 的结果是："

#: src/getting-to-know/conveniences.md:369
#, fuzzy
msgid "Namespaces"
msgstr "命名空间"

#: src/getting-to-know/conveniences.md:371
#, fuzzy
msgid ""
"Each name in Lean occurs in a _namespace_, which is a collection of names. "
"Names are placed in namespaces using `.`, so `List.map` is the name `map` in"
" the `List` namespace. Names in different namespaces do not conflict with "
"each other, even if they are otherwise identical. This means that `List.map`"
" and `Array.map` are different names. Namespaces may be nested, so "
"`Project.Frontend.User.loginTime` is the name `loginTime` in the nested "
"namespace `Project.Frontend.User`."
msgstr ""
"Lean 中的每个名称都出现在一个 _命名空间_ 中，这是一个名称集合。名称使用 `.` 放在命名空间中，因此 `List.map` 是 `List` "
"命名空间中的名称 `map`。不同命名空间中的名称不会相互冲突，即使它们在其他方面是相同的。这意味着 `List.map` 和 `Array.map` "
"是不同的名称。命名空间可以嵌套，因此 `Project.Frontend.User.loginTime` 是嵌套命名空间 "
"`Project.Frontend.User` 中的名称 `loginTime`。"

#: src/getting-to-know/conveniences.md:377
#, fuzzy
msgid ""
"Names can be directly defined within a namespace. For instance, the name "
"`double` can be defined in the `Nat` namespace:"
msgstr "命名空间中可以直接定义名称。例如，名称 `double` 可以定义在 `Nat` 命名空间中："

#: src/getting-to-know/conveniences.md:382
#, fuzzy
msgid ""
"Because `Nat` is also the name of a type, dot notation is available to call "
"`Nat.double` on expressions with type `Nat`:"
msgstr "由于 `Nat` 也是一个类型的名称，因此可以使用点表示法对类型为 `Nat` 的表达式调用 `Nat.double`："

#: src/getting-to-know/conveniences.md:390
#, fuzzy
msgid ""
"In addition to defining names directly in a namespace, a sequence of "
"declarations can be placed in a namespace using the `namespace` and `end` "
"commands. For instance, this defines `triple` and `quadruple` in the "
"namespace `NewNamespace`:"
msgstr ""
"除了直接在命名空间中定义名称外，还可以使用 `namespace` 和 `end` 命令将一系列声明放在命名空间中。例如，这在 "
"`NewNamespace` 命名空间中定义了 `triple` 和 `quadruple`："

#: src/getting-to-know/conveniences.md:398
#, fuzzy
msgid "To refer to them, prefix their names with `NewNamespace.`:"
msgstr "要引用它们，请在其名称前加上 `NewNamespace.`："

#: src/getting-to-know/conveniences.md:412
#, fuzzy
msgid ""
"Namespaces may be _opened_, which allows the names in them to be used "
"without explicit qualification. Writing `open MyNamespace in` before an "
"expression causes the contents of `MyNamespace` to be available in the "
"expression. For example, `timesTwelve` uses both `quadruple` and `triple` "
"after opening `NewNamespace`:"
msgstr ""
"命名空间可以“打开”，这允许在不显式限定的情况下使用其中的名称。在表达式之前编写 `open MyNamespace in` 会导致 "
"`MyNamespace` 的内容在表达式中可用。例如，`timesTwelve` 在打开 `NewNamespace` 后同时使用了 "
"`quadruple` 和 `triple`："

#: src/getting-to-know/conveniences.md:420
#, fuzzy
msgid ""
"Namespaces can also be opened prior to a command. This allows all parts of "
"the command to refer to the contents of the namespace, rather than just a "
"single expression. To do this, place the `open ... in` prior to the command."
msgstr ""
"命名空间也可以在命令之前打开。这允许命令的所有部分引用命名空间的内容，而不仅仅是一个表达式。为此，请在命令之前放置 `open ... in`。"

#: src/getting-to-know/conveniences.md:430
#, fuzzy
msgid ""
"Function signatures show the name's full namespace. Namespaces may "
"additionally be opened for _all_ following commands for the rest of the "
"file. To do this, simply omit the `in` from a top-level usage of `open`."
msgstr "函数签名显示名称的完整命名空间。还可以为文件其余部分的所有后续命令打开命名空间。为此，只需从 `open` 的顶级用法中省略 `in`。"

#: src/getting-to-know/conveniences.md:434
#, fuzzy
msgid "if let"
msgstr "if let"

#: src/getting-to-know/conveniences.md:436
#, fuzzy
msgid ""
"When consuming values that have a sum type, it is often the case that only a"
" single constructor is of interest. For instance, given this type that "
"represents a subset of Markdown inline elements:"
msgstr "在使用具有和类型的值时，通常只对一个构造函数感兴趣。例如，给定表示 Markdown 内联元素子集的类型："

#: src/getting-to-know/conveniences.md:445
#, fuzzy
msgid ""
"a function that recognizes string elements and extracts their contents can "
"be written:"
msgstr "可以编写一个识别字符串元素并提取其内容的函数："

#: src/getting-to-know/conveniences.md:452
#, fuzzy
msgid ""
"An alternative way of writing this function's body uses `if` together with "
"`let`:"
msgstr "另一种编写此函数主体的方法是将 `if` 与 `let` 一起使用："

#: src/getting-to-know/conveniences.md:459
#, fuzzy
msgid ""
"This is very much like the pattern-matching `let` syntax. The difference is "
"that it can be used with sum types, because a fallback is provided in the "
"`else` case. In some contexts, using `if let` instead of `match` can make "
"code easier to read."
msgstr ""
"这与模式匹配 `let` 语法非常相似。不同之处在于它可以与和类型一起使用，因为在 `else` 情况下提供了后备。在某些情况下，使用 `if let`"
" 代替 `match` 可以使代码更易于阅读。"

#: src/getting-to-know/conveniences.md:463
#, fuzzy
msgid "Positional Structure Arguments"
msgstr "位置结构参数"

#: src/getting-to-know/conveniences.md:465
#, fuzzy
msgid ""
"The [section on structures](structures.md) presents two ways of constructing"
" structures:"
msgstr "[结构部分](structures.md)介绍了构建结构的两种方法："

#: src/getting-to-know/conveniences.md:466
#, fuzzy
msgid "The constructor can be called directly, as in `Point.mk 1 2`."
msgstr "构造函数可以直接调用，如 `Point.mk 1 2`。"

#: src/getting-to-know/conveniences.md:467
#, fuzzy
msgid "Brace notation can be used, as in `{ x := 1, y := 2 }`."
msgstr "可以使用大括号表示法，如 `{ x := 1, y := 2 }`。"

#: src/getting-to-know/conveniences.md:469
#, fuzzy
msgid ""
"In some contexts, it can be convenient to pass arguments positionally, "
"rather than by name, but without naming the constructor directly. For "
"instance, defining a variety of similar structure types can help keep domain"
" concepts separate, but the natural way to read the code may treat each of "
"them as being essentially a tuple. In these contexts, the arguments can be "
"enclosed in angle brackets `⟨` and `⟩`. A `Point` can be written `⟨1, 2⟩`. "
"Be careful! Even though they look like the less-than sign `<` and greater-"
"than sign `>`, these brackets are different. They can be input using `\\<` "
"and `\\>`, respectively."
msgstr ""
"在某些情况下，按位置传递参数而不是按名称传递参数可能很方便，但无需直接命名构造函数。例如，定义各种相似的结构类型有助于保持域概念分离，但阅读代码的自然方式可能将它们中的每一个都视为本质上是一个元组。在这些情况下，参数可以用尖括号"
" `⟨` 和 `⟩` 括起来。`Point` 可以写成 `⟨1, 2⟩`。小心！即使它们看起来像小于号 `<` 和大于号 "
"`>`，这些括号也不同。它们可以使用 `\\<` 和 `\\>` 分别输入。"

#: src/getting-to-know/conveniences.md:477
#, fuzzy
msgid ""
"Just as with the brace notation for named constructor arguments, this "
"positional syntax can only be used in a context where Lean can determine the"
" structure's type, either from a type annotation or from other type "
"information in the program. For instance, `#eval ⟨1, 2⟩` yields the "
"following error:"
msgstr ""
"与命名构造函数参数的大括号表示法一样，此位置语法只能在 Lean 可以从类型注释或程序中其他类型信息确定结构类型的上下文中使用。例如，`#eval "
"⟨1, 2⟩` 会产生以下错误："

#: src/getting-to-know/conveniences.md:483
#, fuzzy
msgid ""
"The metavariable in the error is because there is no type information "
"available. Adding an annotation, such as in `#eval (⟨1, 2⟩ : Point)`, solves"
" the problem:"
msgstr "错误中的元变量是因为没有可用的类型信息。添加注释，例如 `#eval (⟨1, 2⟩ : Point)`，可以解决此问题："

#: src/getting-to-know/conveniences.md:490
#, fuzzy
msgid "String Interpolation"
msgstr "字符串插值"

#: src/getting-to-know/conveniences.md:492
#, fuzzy
msgid ""
"In Lean, prefixing a string with `s!` triggers _interpolation_, where "
"expressions contained in curly braces inside the string are replaced with "
"their values. This is similar to `f`\\-strings in Python and `$`\\-prefixed "
"strings in C#. For instance,"
msgstr ""
"在 Lean 中，在字符串前加上 `s!` 会触发 _插值_，其中字符串中大括号内的表达式会被其值替换。这类似于 Python 中的 `f` 字符串和 "
"C# 中以 `$` 为前缀的字符串。例如，"

#: src/getting-to-know/conveniences.md:495
#, fuzzy
msgid ""
"```lean\n"
"#eval s!\"three fives is {NewNamespace.triple 5}\"\n"
"```"
msgstr ""
"```lean\n"
"#eval s!\"three fives is {NewNamespace.triple 5}\"\n"
"```"

#: src/getting-to-know/conveniences.md:498
#: src/getting-to-know/conveniences.md:508
#, fuzzy
msgid "yields the output"
msgstr "会产生输出"

#: src/getting-to-know/conveniences.md:499
#, fuzzy
msgid ""
"```output info\n"
"\"three fives is 15\"\n"
"```"
msgstr ""
"```output info\n"
"\"three fives is 15\"\n"
"```"

#: src/getting-to-know/conveniences.md:503
#, fuzzy
msgid ""
"Not all expressions can be interpolated into a string. For instance, "
"attempting to interpolate a function results in an error."
msgstr "并非所有表达式都可以插值到字符串中。例如，尝试插值一个函数会导致错误。"

#: src/getting-to-know/conveniences.md:505
#, fuzzy
msgid ""
"```lean\n"
"#check s!\"three fives is {NewNamespace.triple}\"\n"
"```"
msgstr ""
"```lean\n"
"#check s!\"three fives is {NewNamespace.triple}\"\n"
"```"

#: src/getting-to-know/conveniences.md:513
#, fuzzy
msgid ""
"This is because there is no standard way to convert functions into strings. "
"The Lean compiler maintains a table that describes how to convert values of "
"various types into strings, and the message `failed to synthesize instance` "
"means that the Lean compiler didn't find an entry in this table for the "
"given type. This uses the same language feature as the `deriving Repr` "
"syntax that was described in the [section on structures](structures.md)."
msgstr ""
"这是因为没有将函数转换为字符串的标准方法。Lean 编译器维护了一个表，描述如何将各种类型的值转换为字符串，而消息 `failed to "
"synthesize instance` 意味着 Lean 编译器未在此表中找到给定类型的条目。这使用了与 "
"[结构部分](structures.md)中描述的 `deriving Repr` 语法相同的语言特性。"
