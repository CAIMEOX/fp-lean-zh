#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/functor-applicative-monad/alternative.md:4
#, fuzzy
msgid "Recovery from Failure"
msgstr "从失败中恢复"

#: src/functor-applicative-monad/alternative.md:6
#, fuzzy
msgid ""
"`Validate` can also be used in situations where there is more than one way "
"for input to be acceptable. For the input form `RawInput`, an alternative "
"set of business rules that implement conventions from a legacy system might "
"be the following:"
msgstr "`Validate` 还可以用于输入有多种可接受方式的情况。对于输入表单 `RawInput`，实现旧系统约定的备用业务规则集可能是："

#: src/functor-applicative-monad/alternative.md:9
#, fuzzy
msgid "All human users must provide a birth year that is four digits."
msgstr "所有人类用户都必须提供四位数的出生年份。"

#: src/functor-applicative-monad/alternative.md:10
#, fuzzy
msgid ""
"Users born prior to 1970 do not need to provide names, due to incomplete "
"older records."
msgstr "由于旧记录不完整，1970 年之前出生的用户无需提供姓名。"

#: src/functor-applicative-monad/alternative.md:11
#, fuzzy
msgid "Users born after 1970 must provide names."
msgstr "1970 年之后出生的用户必须提供姓名。"

#: src/functor-applicative-monad/alternative.md:12
#, fuzzy
msgid ""
"Companies should enter `\"FIRM\"` as their year of birth and provide a "
"company name."
msgstr "公司应将其出生年份输入为 `\"FIRM\"`，并提供公司名称。"

#: src/functor-applicative-monad/alternative.md:14
#, fuzzy
msgid ""
"No particular provision is made for users born in 1970. It is expected that "
"they will either give up, lie about their year of birth, or call. The "
"company considers this an acceptable cost of doing business."
msgstr "对于 1970 年出生的用户没有做出任何特别规定。预计他们要么会放弃，要么谎报出生年份，要么打电话。公司认为这是开展业务的可接受成本。"

#: src/functor-applicative-monad/alternative.md:18
#, fuzzy
msgid ""
"The following inductive type captures the values that can be produced from "
"these stated rules:"
msgstr "以下归纳类型捕获了可以从这些既定规则中产生的值："

#: src/functor-applicative-monad/alternative.md:19
msgid ""
"```lean\n"
"abbrev NonEmptyString := {s : String // s ≠ \"\"}\n"
"\n"
"inductive LegacyCheckedInput where\n"
"  | humanBefore1970 :\n"
"    (birthYear : {y : Nat // y > 999 ∧ y < 1970}) →\n"
"    String →\n"
"    LegacyCheckedInput\n"
"  | humanAfter1970 :\n"
"    (birthYear : {y : Nat // y > 1970}) →\n"
"    NonEmptyString →\n"
"    LegacyCheckedInput\n"
"  | company :\n"
"    NonEmptyString →\n"
"    LegacyCheckedInput\n"
"deriving Repr\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:37
#, fuzzy
msgid ""
"A validator for these rules is more complicated, however, as it must address"
" all three cases. While it can be written as a series of nested `if` "
"expressions, it's easier to design the three cases independently and then "
"combine them. This requires a means of recovering from failure while "
"preserving error messages:"
msgstr ""
"但是，针对这些规则的验证器会更复杂，因为它必须解决所有三种情况。虽然它可以写成一系列嵌套的 `if` "
"表达式，但独立设计这三种情况然后将它们组合起来会更容易。这需要一种在保留错误消息的同时从失败中恢复的方法："

#: src/functor-applicative-monad/alternative.md:50
#, fuzzy
msgid ""
"This pattern of recovery from failures is common enough that Lean has built-"
"in syntax for it, attached to a type class named `OrElse`:"
msgstr "从失败中恢复的这种模式很常见，以至于 Lean 为它内置了语法，附加到名为 `OrElse` 的类型类："

#: src/functor-applicative-monad/alternative.md:55
#, fuzzy
msgid ""
"The expression `E1 <|> E2` is short for `OrElse.orElse E1 (fun () => E2)`. "
"An instance of `OrElse` for `Validate` allows this syntax to be used for "
"error recovery:"
msgstr ""
"表达式 `E1 <|> E2` 是 `OrElse.orElse E1 (fun () => E2)` 的缩写。`Validate` 的 "
"`OrElse` 实例允许将此语法用于错误恢复："

#: src/functor-applicative-monad/alternative.md:62
#, fuzzy
msgid ""
"The validator for `LegacyCheckedInput` can be built from a validator for "
"each constructor. The rules for a company state that the birth year should "
"be the string `\"FIRM\"` and that the name should be non-empty. The "
"constructor `LegacyCheckedInput.company`, however, has no representation of "
"the birth year at all, so there's no easy way to carry it out using `<*>`. "
"The key is to use a function with `<*>` that ignores its argument."
msgstr ""
"`LegacyCheckedInput` 的验证器可以从每个构造函数的验证器构建。公司的规则规定出生年份应为字符串 "
"`\"FIRM\"`，并且姓名应非空。但是，构造函数 `LegacyCheckedInput.company` 根本没有出生年份的表示，因此无法使用 "
"`<*>` 轻松执行。关键是要使用忽略其参数的函数和 `<*>`。"

#: src/functor-applicative-monad/alternative.md:67
#, fuzzy
msgid ""
"Checking that a Boolean condition holds without recording any evidence of "
"this fact in a type can be accomplished with `checkThat`:"
msgstr "使用 `checkThat` 可以检查布尔条件是否成立，而无需在类型中记录此事实的任何证据："

#: src/functor-applicative-monad/alternative.md:72
#, fuzzy
msgid ""
"This definition of `checkCompany` uses `checkThat`, and then throws away the"
" resulting `Unit` value:"
msgstr "`checkCompany` 的此定义使用 `checkThat`，然后丢弃结果 `Unit` 值："

#: src/functor-applicative-monad/alternative.md:73
msgid ""
"```lean\n"
"def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=\n"
"  pure (fun () name => .company name) <*>\n"
"    checkThat (input.birthYear == \"FIRM\") \"birth year\" \"FIRM if a company\" <*>\n"
"    checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:80
#, fuzzy
msgid ""
"However, this definition is quite noisy. It can be simplified in two ways. "
"The first is to replace the first use of `<*>` with a specialized version "
"that automatically ignores the value returned by the first argument, called "
"`*>`. This operator is also controlled by a type class, called `SeqRight`, "
"and `E1 *> E2` is syntactic sugar for `SeqRight.seqRight E1 (fun () => E2)`:"
msgstr ""
"但是，此定义非常冗长。可以通过两种方式简化它。首先，用一个专门版本替换第一个 `<*>` 用法，该版本会自动忽略第一个参数返回的值，称为 "
"`*>`。此运算符也由类型类 `SeqRight` 控制，并且 `E1 *> E2` 是 `SeqRight.seqRight E1 (fun () "
"=> E2)` 的语法糖："

#: src/functor-applicative-monad/alternative.md:88
#, fuzzy
msgid ""
"There is a default implementation of `seqRight` in terms of `seq`: `seqRight"
" (a : f α) (b : Unit → f β) : f β := pure (fun _ x => x) <*> a <*> b ()`."
msgstr ""
"`seqRight` 有一个基于 `seq` 的默认实现：`seqRight (a : f α) (b : Unit → f β) : f β := "
"pure (fun _ x => x) <*> a <*> b ()`。"

#: src/functor-applicative-monad/alternative.md:90
#, fuzzy
msgid "Using `seqRight`, `checkCompany` becomes simpler:"
msgstr "使用 `seqRight`，`checkCompany` 变得更简单："

#: src/functor-applicative-monad/alternative.md:91
msgid ""
"```lean\n"
"def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=\n"
"  checkThat (input.birthYear == \"FIRM\") \"birth year\" \"FIRM if a company\" *>\n"
"  pure .company <*> checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:96
#, fuzzy
msgid ""
"One more simplification is possible. For every `Applicative`, `pure F <*> E`"
" is equivalent to `f <$> E`. In other words, using `seq` to apply a function"
" that was placed into the `Applicative` type using `pure` is overkill, and "
"the function could have just been applied using `Functor.map`. This "
"simplification yields:"
msgstr ""
"还可以进行更多简化。对于每个 `Applicative`，`pure F <*> E` 等同于 `f <$> E`。换句话说，使用 `seq` 应用使用"
" `pure` 放入 `Applicative` 类型的函数是多余的，可以使用 `Functor.map` 直接应用函数。此简化产生："

#: src/functor-applicative-monad/alternative.md:100
msgid ""
"```lean\n"
"def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=\n"
"  checkThat (input.birthYear == \"FIRM\") \"birth year\" \"FIRM if a company\" *>\n"
"  .company <$> checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:106
#, fuzzy
msgid ""
"The remaining two constructors of `LegacyCheckedInput` use subtypes for "
"their fields. A general-purpose tool for checking subtypes will make these "
"easier to read:"
msgstr "`LegacyCheckedInput` 的其余两个构造函数为其字段使用子类型。用于检查子类型的通用工具将使这些字段更易于阅读："

#: src/functor-applicative-monad/alternative.md:108
msgid ""
"```lean\n"
"def checkSubtype {α : Type} (v : α) (p : α → Prop) [Decidable (p v)] (err : ε) : Validate ε {x : α // p x} :=\n"
"  if h : p v then\n"
"    pure ⟨v, h⟩\n"
"  else\n"
"    .errors { head := err, tail := [] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:115
#, fuzzy
msgid ""
"In the function's argument list, it's important that the type class "
"`[Decidable (p v)]` occur after the specification of the arguments `v` and "
"`p`. Otherwise, it would refer to an additional set of automatic implicit "
"arguments, rather than to the manually-provided values. The `Decidable` "
"instance is what allows the proposition `p v` to be checked using `if`."
msgstr ""
"在函数的参数列表中，类型类 `[Decidable (p v)]` 必须在参数 `v` 和 `p` "
"的规范之后出现。否则，它将引用一组额外的自动隐式参数，而不是手动提供的值。`Decidable` 实例允许使用 `if` 检查命题 `p v`。"

#: src/functor-applicative-monad/alternative.md:119
#, fuzzy
msgid "The two human cases do not need any additional tools:"
msgstr "两种人类情况不需要任何附加工具："

#: src/functor-applicative-monad/alternative.md:120
msgid ""
"```lean\n"
"def checkHumanBefore1970 (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=\n"
"  (checkYearIsNat input.birthYear).andThen fun y =>\n"
"    .humanBefore1970 <$>\n"
"      checkSubtype y (fun x => x > 999 ∧ x < 1970) (\"birth year\", \"less than 1970\") <*>\n"
"      pure input.name\n"
"\n"
"def checkHumanAfter1970 (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=\n"
"  (checkYearIsNat input.birthYear).andThen fun y =>\n"
"    .humanAfter1970 <$>\n"
"      checkSubtype y (· > 1970) (\"birth year\", \"greater than 1970\") <*>\n"
"      checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:134
#, fuzzy
msgid "The validators for the three cases can be combined using `<|>`:"
msgstr "三个案例的验证器可以使用 `<|>` 组合："

#: src/functor-applicative-monad/alternative.md:140
#, fuzzy
msgid ""
"The successful cases return constructors of `LegacyCheckedInput`, as "
"expected:"
msgstr "成功案例按预期返回 `LegacyCheckedInput` 的构造函数："

#: src/functor-applicative-monad/alternative.md:141
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"Johnny's Troll Groomers\", \"FIRM\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:144
msgid ""
"```output info\n"
"Validate.ok (LegacyCheckedInput.company \"Johnny's Troll Groomers\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:147
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"Johnny\", \"1963\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:150
msgid ""
"```output info\n"
"Validate.ok (LegacyCheckedInput.humanBefore1970 1963 \"Johnny\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:153
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"\", \"1963\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:156
msgid ""
"```output info\n"
"Validate.ok (LegacyCheckedInput.humanBefore1970 1963 \"\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:160
#, fuzzy
msgid "The worst possible input returns all the possible failures:"
msgstr "最差的可能输入返回所有可能的失败："

#: src/functor-applicative-monad/alternative.md:161
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"\", \"1970\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:164
msgid ""
"```output info\n"
"Validate.errors\n"
"  { head := (\"birth year\", \"FIRM if a company\"),\n"
"    tail := [(\"name\", \"Required\"),\n"
"             (\"birth year\", \"less than 1970\"),\n"
"             (\"birth year\", \"greater than 1970\"),\n"
"             (\"name\", \"Required\")] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:174
#, fuzzy
msgid "The `Alternative` Class"
msgstr "`Alternative` 类"

#: src/functor-applicative-monad/alternative.md:176
#, fuzzy
msgid ""
"Many types support a notion of failure and recovery. The `Many` monad from "
"the section on [evaluating arithmetic expressions in a variety of "
"monads](../monads/arithmetic.md#nondeterministic-search) is one such type, "
"as is `Option`. Both support failure without providing a reason (unlike, "
"say, `Except` and `Validate`, which require some indication of what went "
"wrong)."
msgstr ""
"许多类型支持失败和恢复的概念。[在各种单子中计算算术表达式](../monads/arithmetic.md#nondeterministic-"
"search) 部分中的 `Many` 单子就是其中之一，`Option` 也是如此。两者都支持失败，而不提供原因（与 `Except` 和 "
"`Validate` 不同，它们需要一些指示出错内容的指示）。"

#: src/functor-applicative-monad/alternative.md:180
#, fuzzy
msgid ""
"The `Alternative` class describes applicative functors that have additional "
"operators for failure and recovery:"
msgstr "`Alternative` 类描述了具有附加失败和恢复运算符的应用函子："

#: src/functor-applicative-monad/alternative.md:186
#, fuzzy
msgid ""
"Just as implementors of `Add α` get `HAdd α α α` instances for free, "
"implementors of `Alternative` get `OrElse` instances for free:"
msgstr ""
"就像 `Add α` 的实现者免费获得 `HAdd α α α` 实例一样，`Alternative` 的实现者免费获得 `OrElse` 实例："

#: src/functor-applicative-monad/alternative.md:192
#, fuzzy
msgid ""
"The implementation of `Alternative` for `Option` keeps the first none-`none`"
" argument:"
msgstr "`Option` 的 `Alternative` 实现保留第一个非 `none` 参数："

#: src/functor-applicative-monad/alternative.md:200
#, fuzzy
msgid ""
"Similarly, the implementation for `Many` follows the general structure of "
"`Many.union`, with minor differences due to the laziness-inducing `Unit` "
"parameters being placed differently:"
msgstr "同样，`Many` 的实现遵循 `Many.union` 的一般结构，由于惰性诱导 `Unit` 参数放置不同而有细微差别："

#: src/functor-applicative-monad/alternative.md:211
#, fuzzy
msgid ""
"Like other type classes, `Alternative` enables the definition of a variety "
"of operations that work for _any_ applicative functor that implements "
"`Alternative`. One of the most important is `guard`, which causes `failure` "
"when a decidable proposition is false:"
msgstr ""
"与其他类型类一样，`Alternative` 允许定义各种操作，这些操作适用于实现 `Alternative` 的任何应用函子。其中最重要的一个操作是 "
"`guard`，当可判定命题为假时，它会导致 `failure`："

#: src/functor-applicative-monad/alternative.md:219
#, fuzzy
msgid ""
"It is very useful in monadic programs to terminate execution early. In "
"`Many`, it can be used to filter out a whole branch of a search, as in the "
"following program that computes all even divisors of a natural number:"
msgstr "在单子程序中非常有用，可以提前终止执行。在 `Many` 中，它可用于过滤搜索的整个分支，如下程序计算自然数的所有偶数除数："

#: src/functor-applicative-monad/alternative.md:232
#, fuzzy
msgid "Running it on `20` yields the expected results:"
msgstr "运行它，得到预期结果："

#: src/functor-applicative-monad/alternative.md:243
#, fuzzy
msgid "Improve Validation Friendliness"
msgstr "改进验证友好性"

#: src/functor-applicative-monad/alternative.md:245
#, fuzzy
msgid ""
"The errors returned from `Validate` programs that use `<|>` can be difficult"
" to read, because inclusion in the list of errors simply means that the "
"error can be reached through _some_ code path. A more structured error "
"report can be used to guide the user through the process more accurately:"
msgstr ""
"使用 `<|>` 的 `Validate` 程序返回的错误可能难以阅读，因为包含在错误列表中仅仅意味着可以通过 _some_ "
"代码路径到达该错误。更结构化的错误报告可以更准确地指导用户完成该过程："

#: src/functor-applicative-monad/alternative.md:248
#, fuzzy
msgid ""
"Replace the `NonEmptyList` in `Validate.error` with a bare type variable, "
"and then update the definitions of the `Applicative (Validate ε)` and "
"`OrElse (Validate ε α)` instances to require only that there be an `Append "
"ε` instance available."
msgstr ""
"用一个裸类型变量替换 `Validate.error` 中的 `NonEmptyList`，然后更新 `Applicative (Validate "
"ε)` 和 `OrElse (Validate ε α)` 实例的定义，仅要求提供一个可用的 `Append ε` 实例。"

#: src/functor-applicative-monad/alternative.md:249
#, fuzzy
msgid ""
"Define a function `Validate.mapErrors : Validate ε α → (ε → ε') → Validate "
"ε' α` that transforms all the errors in a validation run."
msgstr ""
"定义一个函数 `Validate.mapErrors : Validate ε α → (ε → ε') → Validate ε' "
"α`，它转换验证运行中的所有错误。"

#: src/functor-applicative-monad/alternative.md:250
#, fuzzy
msgid ""
"Using the datatype `TreeError` to represent errors, rewrite the legacy "
"validation system to track its path through the three alternatives."
msgstr "使用数据类型 `TreeError` 来表示错误，重写旧验证系统以跟踪其通过三个备选方案的路径。"

#: src/functor-applicative-monad/alternative.md:251
#, fuzzy
msgid ""
"Write a function `report : TreeError → String` that outputs a user-friendly "
"view of the `TreeError`'s accumulated warnings and errors."
msgstr "编写一个函数 `report : TreeError → String`，它输出 `TreeError` 累积的警告和错误的用户友好视图。"
