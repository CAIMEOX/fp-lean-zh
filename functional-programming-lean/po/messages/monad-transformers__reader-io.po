#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/monad-transformers/reader-io.md:3
#, fuzzy
msgid ""
"One case where a reader monad can be useful is when there is some notion of "
"the \"current configuration\" of the application that is passed through many"
" recursive calls. An example of such a program is `tree`, which recursively "
"prints the files in the current directory and its subdirectories, indicating"
" their tree structure using characters. The version of `tree` in this "
"chapter, called `doug` after the mighty Douglas Fir tree that adorns the "
"west coast of North America, provides the option of Unicode box-drawing "
"characters or their ASCII equivalents when indicating directory structure."
msgstr ""
"读者单子有用的一个案例是当应用程序的“当前配置”的概念在许多递归调用中传递时。这样的程序的一个示例是 "
"`tree`，它递归地打印当前目录及其子目录中的文件，使用字符指示它们的树结构。本章中 `tree` 的版本称为 "
"`doug`，以装饰北美西海岸的巨型道格拉斯冷杉树命名，它提供了在指示目录结构时使用 Unicode 框图字符或其 ASCII 等效项的选项。"

#: src/monad-transformers/reader-io.md:7
#, fuzzy
msgid ""
"For example, the following commands create a directory structure and some "
"empty files in a directory called `doug-demo`:"
msgstr "例如，以下命令在名为 `doug-demo` 的目录中创建目录结构和一些空文件："

#: src/monad-transformers/reader-io.md:17
#, fuzzy
msgid "Running `doug` results in the following:"
msgstr "运行 `doug` 会产生以下结果："

#: src/monad-transformers/reader-io.md:32
#, fuzzy
msgid "Implementation"
msgstr "实现"

#: src/monad-transformers/reader-io.md:34
#, fuzzy
msgid ""
"Internally, `doug` passes a configuration value downwards as it recursively "
"traverses the directory structure. This configuration contains two fields: "
"`useASCII` determines whether to use Unicode box-drawing characters or ASCII"
" vertical line and dash characters to indicate structure, and "
"`currentPrefix` contains a string to prepend to each line of output. As the "
"current directory deepens, the prefix string accumulates indicators of being"
" in a directory. The configuration is a structure:"
msgstr ""
"在内部，`doug` 在递归遍历目录结构时向下传递一个配置值。此配置包含两个字段：`useASCII` 确定是否使用 Unicode 框图字符或 "
"ASCII 竖线和破折号字符来指示结构，而 `currentPrefix` "
"包含要添加到每行输出的字符串。随着当前目录的深入，前缀字符串会累积目录中的指示符。配置是一个结构："

#: src/monad-transformers/reader-io.md:38
msgid ""
"```lean\n"
"structure Config where\n"
"  useASCII : Bool := false\n"
"  currentPrefix : String := \"\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:43
#, fuzzy
msgid ""
"This structure has default definitions for both fields. The default `Config`"
" uses Unicode display with no prefix."
msgstr "此结构为这两个字段提供了默认定义。默认的 `Config` 使用 Unicode 显示，没有前缀。"

#: src/monad-transformers/reader-io.md:46
#, fuzzy
msgid ""
"Users who invoke `doug` will need to be able to provide command-line "
"arguments. The usage information is as follows:"
msgstr "调用 `doug` 的用户需要能够提供命令行参数。用法信息如下："

#: src/monad-transformers/reader-io.md:48
msgid ""
"```lean\n"
"def usage : String :=\n"
"  \"Usage: doug [--ascii]\n"
"Options:\n"
"\\t--ascii\\tUse ASCII characters to display the directory structure\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:54
#, fuzzy
msgid ""
"Accordingly, a configuration can be constructed by examining a list of "
"command-line arguments:"
msgstr "因此，可以通过检查命令行参数列表来构建配置："

#: src/monad-transformers/reader-io.md:55
msgid ""
"```lean\n"
"def configFromArgs : List String → Option Config\n"
"  | [] => some {} -- both fields default\n"
"  | [\"--ascii\"] => some {useASCII := true}\n"
"  | _ => none\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:62
#, fuzzy
msgid ""
"The `main` function is a wrapper around an inner worker, called `dirTree`, "
"that shows the contents of a directory using a configuration. Before calling"
" `dirTree`, `main` is responsible for processing command-line arguments. It "
"must also return the appropriate exit code to the operating system:"
msgstr ""
"`main` 函数是对内部工作器 `dirTree` 的包装，该工作器使用配置显示目录的内容。在调用 `dirTree` 之前，`main` "
"负责处理命令行参数。它还必须向操作系统返回适当的退出代码："

#: src/monad-transformers/reader-io.md:65
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 := do\n"
"  match configFromArgs args with\n"
"  | some config =>\n"
"    dirTree config (← IO.currentDir)\n"
"    pure 0\n"
"  | none =>\n"
"    IO.eprintln s!\"Didn't understand argument(s) {\" \".separate args}\\n\"\n"
"    IO.eprintln usage\n"
"    pure 1\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:77
#, fuzzy
msgid ""
"Not all paths should be shown in the directory tree. In particular, files "
"named `.` or `..` should be skipped, as they are actually features used for "
"navigation rather than files _per se_. Of those files that should be shown, "
"there are two kinds: ordinary files and directories:"
msgstr ""
"并非所有路径都应显示在目录树中。特别是，应跳过名为 `.` 或 `..` "
"的文件，因为它们实际上是用于导航而不是文件本身的功能。在应该显示的文件中，有两种类型：普通文件和目录："

#: src/monad-transformers/reader-io.md:85
#, fuzzy
msgid ""
"To determine whether a file should be shown, along with which kind of entry "
"it is, `doug` uses `toEntry`:"
msgstr "`doug` 使用 `toEntry` 来确定是否显示文件以及显示哪种类型的条目："

#: src/monad-transformers/reader-io.md:86
msgid ""
"```lean\n"
"def toEntry (path : System.FilePath) : IO (Option Entry) := do\n"
"  match path.components.getLast? with\n"
"  | none => pure (some (.dir \"\"))\n"
"  | some \".\" | some \"..\" => pure none\n"
"  | some name =>\n"
"    pure (some (if (← path.isDir) then .dir name else .file name))\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:94
#, fuzzy
msgid ""
"`System.FilePath.components` converts a path into a list of path components,"
" splitting the name at directory separators. If there is no last component, "
"then the path is the root directory. If the last component is a special "
"navigation file (`.` or `..`), then the file should be excluded. Otherwise, "
"directories and files are wrapped in the corresponding constructors."
msgstr ""
"`System.FilePath.components` "
"将路径转换为路径组件列表，在目录分隔符处拆分名称。如果没有最后一个组件，则路径是根目录。如果最后一个组件是特殊导航文件（`.` 或 "
"`..`），则应排除该文件。否则，目录和文件将被包装在相应的构造函数中。"

#: src/monad-transformers/reader-io.md:99
#, fuzzy
msgid ""
"Lean's logic has no way to know that directory trees are finite. Indeed, "
"some systems allow the construction of circular directory structures. Thus, "
"`dirTree` is declared `partial`:"
msgstr "Lean 的逻辑无法知道目录树是有限的。事实上，某些系统允许构建循环目录结构。因此，`dirTree` 被声明为 `partial`："

#: src/monad-transformers/reader-io.md:114
#, fuzzy
msgid ""
"The call to `toEntry` is a [nested action](../hello-"
"world/conveniences.md#nested-actions)—the parentheses are optional in "
"positions where the arrow couldn't have any other meaning, such as `match`. "
"When the filename doesn't correspond to an entry in the tree (e.g. because "
"it is `..`), `dirTree` does nothing. When the filename points to an ordinary"
" file, `dirTree` calls a helper to show it with the current configuration. "
"When the filename points to a directory, it is shown with a helper, and then"
" its contents are recursively shown in a new configuration in which the "
"prefix has been extended to account for being in a new directory."
msgstr ""
"对 `toEntry` 的调用是一个 [嵌套操作](../hello-world/conveniences.md#nested-"
"actions)——在箭头不可能有任何其他含义的位置（例如 `match`）中，括号是可选的。当文件名与树中的条目不对应（例如，因为它是 "
"`..`）时，`dirTree` 不执行任何操作。当文件名指向普通文件时，`dirTree` "
"调用一个帮助器来使用当前配置显示它。当文件名指向目录时，它将使用帮助器显示，然后以递归方式在其内容中显示一个新的配置，其中前缀已扩展为考虑在新目录中。"

#: src/monad-transformers/reader-io.md:119
#, fuzzy
msgid ""
"Showing the names of files and directories is achieved with `showFileName` "
"and `showDirName`:"
msgstr "使用 `showFileName` 和 `showDirName` 显示文件和目录的名称："

#: src/monad-transformers/reader-io.md:127
#, fuzzy
msgid ""
"Both of these helpers delegate to functions on `Config` that take the ASCII "
"vs Unicode setting into account:"
msgstr "这两个帮助器都委托给 `Config` 上的函数，这些函数考虑了 ASCII 与 Unicode 设置："

#: src/monad-transformers/reader-io.md:128
msgid ""
"```lean\n"
"def Config.preFile (cfg : Config) :=\n"
"  if cfg.useASCII then \"|--\" else \"├──\"\n"
"\n"
"def Config.preDir (cfg : Config) :=\n"
"  if cfg.useASCII then \"|  \" else \"│  \"\n"
"\n"
"def Config.fileName (cfg : Config) (file : String) : String :=\n"
"  s!\"{cfg.currentPrefix}{cfg.preFile} {file}\"\n"
"\n"
"def Config.dirName (cfg : Config) (dir : String) : String :=\n"
"  s!\"{cfg.currentPrefix}{cfg.preFile} {dir}/\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:141
#, fuzzy
msgid ""
"Similarly, `Config.inDirectory` extends the prefix with a directory marker:"
msgstr "类似地，`Config.inDirectory` 使用目录标记扩展前缀："

#: src/monad-transformers/reader-io.md:142
msgid ""
"```lean\n"
"def Config.inDirectory (cfg : Config) : Config :=\n"
"  {cfg with currentPrefix := cfg.preDir ++ \" \" ++ cfg.currentPrefix}\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:147
#, fuzzy
msgid ""
"Iterating an IO action over a list of directory contents is achieved using "
"`doList`. Because `doList` carries out all the actions in a list and does "
"not base control-flow decisions on the values returned by any of the "
"actions, the full power of `Monad` is not necessary, and it will work for "
"any `Applicative`:"
msgstr ""
"使用 `doList` 可以对目录内容列表执行 IO 操作。由于 `doList` "
"执行列表中的所有操作，并且不会根据任何操作返回的值做出控制流决策，因此不需要 `Monad` 的全部功能，并且它适用于任何 `Applicative`："

#: src/monad-transformers/reader-io.md:158
#, fuzzy
msgid "Using a Custom Monad"
msgstr "使用自定义单子"

#: src/monad-transformers/reader-io.md:160
#, fuzzy
msgid ""
"While this implementation of `doug` works, manually passing the "
"configuration around is verbose and error-prone. The type system will not "
"catch it if the wrong configuration is passed downwards, for instance. A "
"reader effect ensures that the same configuration is passed to all recursive"
" calls, unless it is manually overridden, and it helps make the code less "
"verbose."
msgstr ""
"虽然此 `doug` "
"实现有效，但手动传递配置既冗长又容易出错。例如，如果错误的配置向下传递，类型系统将无法捕获它。读取器效果确保将相同的配置传递给所有递归调用，除非手动覆盖它，并且它有助于减少代码冗长。"

#: src/monad-transformers/reader-io.md:164
#, fuzzy
msgid ""
"To create a version of `IO` that is also a reader of `Config`, first define "
"the type and its `Monad` instance, following the recipe from [the evaluator "
"example](../monads/arithmetic.md#custom-environments):"
msgstr ""
"要创建同时也是 `Config` 读取器的 `IO` 版本，请首先定义类型及其 `Monad` 实例，按照 "
"[评估器示例](../monads/arithmetic.md#custom-environments) 中的配方进行操作："

#: src/monad-transformers/reader-io.md:175
#, fuzzy
msgid ""
"The difference between this `Monad` instance and the one for `Reader` is "
"that this one uses `do`\\-notation in the `IO` monad as the body of the "
"function that `bind` returns, rather than applying `next` directly to the "
"value returned from `result`. Any `IO` effects performed by `result` must "
"occur before `next` is invoked, which is ensured by the `IO` monad's `bind` "
"operator. `ConfigIO` is not universe polymorphic because the underlying `IO`"
" type is also not universe polymorphic."
msgstr ""
"此 `Monad` 实例与 `Reader` 实例之间的区别在于，此实例在 `bind` 返回的函数中使用 `do` 符号作为 `IO` "
"单子中的主体，而不是将 `next` 直接应用于 `result` 返回的值。`result` 执行的任何 `IO` 效果都必须在调用 `next` "
"之前发生，这由 `IO` 单子的 `bind` 运算符确保。`ConfigIO` 不是 universe 多态的，因为底层的 `IO` 类型也不是 "
"universe 多态的。"

#: src/monad-transformers/reader-io.md:179
#, fuzzy
msgid ""
"Running a `ConfigIO` action involves transforming it into an `IO` action by "
"providing it with a configuration:"
msgstr "运行 `ConfigIO` 操作涉及通过提供配置将其转换为 `IO` 操作："

#: src/monad-transformers/reader-io.md:184
#, fuzzy
msgid ""
"This function is not really necessary, as a caller could simply provide the "
"configuration directly. However, naming the operation can make it easier to "
"see which parts of the code are intended to run in which monad."
msgstr "此函数不是必需的，因为调用者可以简单地直接提供配置。但是，命名操作可以更容易地看出代码的哪些部分旨在在哪个单子中运行。"

#: src/monad-transformers/reader-io.md:187
#, fuzzy
msgid ""
"The next step is to define a means of accessing the current configuration as"
" part of `ConfigIO`:"
msgstr "下一步是定义一种访问当前配置的方法，作为 `ConfigIO` 的一部分："

#: src/monad-transformers/reader-io.md:192
#, fuzzy
msgid ""
"This is just like `read` from [the evaluator "
"example](../monads/arithmetic.md#custom-environments), except it uses `IO`'s"
" `pure` to return its value rather than doing so directly. Because entering "
"a directory modifies the current configuration for the scope of a recursive "
"call, it will be necessary to have a way to override a configuration:"
msgstr ""
"这就像 [求值器示例](../monads/arithmetic.md#custom-environments) 中的 `read`，除了它使用 "
"`IO` 的 `pure` 来返回其值，而不是直接返回。因为进入目录会修改当前配置以进行递归调用，所以需要一种覆盖配置的方法："

#: src/monad-transformers/reader-io.md:199
#, fuzzy
msgid ""
"Much of the code used in `doug` has no need for configurations, and `doug` "
"calls ordinary Lean `IO` actions from the standard library that certainly "
"don't need a `Config`. Ordinary `IO` actions can be run using `runIO`, which"
" ignores the configuration argument:"
msgstr ""
"`doug` 中使用的许多代码不需要配置，并且 `doug` 从标准库中调用普通的 Lean `IO` 操作，这些操作肯定不需要 "
"`Config`。可以使用 `runIO` 运行普通的 `IO` 操作，它会忽略配置参数："

#: src/monad-transformers/reader-io.md:206
#, fuzzy
msgid ""
"With these components, `showFileName` and `showDirName` can be updated to "
"take their configuration arguments implicitly through the `ConfigIO` monad. "
"They use [nested actions](../hello-world/conveniences.md#nested-actions) to "
"retrieve the configuration, and `runIO` to actually execute the call to "
"`IO.println`:"
msgstr ""
"有了这些组件，`showFileName` 和 `showDirName` 可以更新为通过 `ConfigIO` 单子隐式获取其配置参数。它们使用 "
"[嵌套操作](../hello-world/conveniences.md#nested-actions) 来检索配置，并使用 `runIO` "
"来实际执行对 `IO.println` 的调用："

#: src/monad-transformers/reader-io.md:216
#, fuzzy
msgid ""
"In the new version of `dirTree`, the calls to `toEntry` and "
"`System.FilePath.readDir` are wrapped in `runIO`. Additionally, instead of "
"building a new configuration and then requiring the programmer to keep track"
" of which one to pass to recursive calls, it uses `locally` to naturally "
"delimit the modified configuration to only a small region of the program, in"
" which it is the _only_ valid configuration:"
msgstr ""
"在新版本的 `dirTree` 中，对 `toEntry` 和 `System.FilePath.readDir` 的调用被包装在 `runIO` "
"中。此外，它没有构建新配置，然后要求程序员跟踪将哪个配置传递给递归调用，而是使用 `locally` "
"将修改后的配置自然地限定为程序的一个小区域，在该区域中它是 _唯一_ 有效的配置："

#: src/monad-transformers/reader-io.md:231
#, fuzzy
msgid ""
"The new version of `main` uses `ConfigIO.run` to invoke `dirTree` with the "
"initial configuration:"
msgstr "新版本的 `main` 使用 `ConfigIO.run` 使用初始配置调用 `dirTree`："

#: src/monad-transformers/reader-io.md:232
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 := do\n"
"    match configFromArgs args with\n"
"    | some config =>\n"
"      (dirTree (← IO.currentDir)).run config\n"
"      pure 0\n"
"    | none =>\n"
"      IO.eprintln s!\"Didn't understand argument(s) {\" \".separate args}\\n\"\n"
"      IO.eprintln usage\n"
"      pure 1\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:244
#, fuzzy
msgid ""
"This custom monad has a number of advantages over passing configurations "
"manually:"
msgstr "这种自定义单子比手动传递配置具有许多优势："

#: src/monad-transformers/reader-io.md:246
#, fuzzy
msgid ""
"It is easier to ensure that configurations are passed down unchanged, except"
" when changes are desired"
msgstr "更容易确保配置按原样传递，除非需要更改"

#: src/monad-transformers/reader-io.md:247
#, fuzzy
msgid ""
"The concern of passing the configuration onwards is more clearly separated "
"from the concern of printing directory contents"
msgstr "传递配置的顾虑与打印目录内容的顾虑更加清晰地分离开来"

#: src/monad-transformers/reader-io.md:248
#, fuzzy
msgid ""
"As the program grows, there will be more and more intermediate layers that "
"do nothing with configurations except propagate them, and these layers don't"
" need to be rewritten as the configuration logic changes"
msgstr "随着程序的增长，将有越来越多的中间层对配置不执行任何操作，除了传播它们，并且这些层不需要在配置逻辑更改时重写"

#: src/monad-transformers/reader-io.md:250
#, fuzzy
msgid "However, there are also some clear downsides:"
msgstr "但是，也有一些明显的缺点："

#: src/monad-transformers/reader-io.md:252
#, fuzzy
msgid ""
"As the program evolves and the monad requires more features, each of the "
"basic operators such as `locally` and `currentConfig` will need to be "
"updated"
msgstr "随着程序的演进和单子需要更多功能，每个基本运算符（如 `locally` 和 `currentConfig`）都需要更新"

#: src/monad-transformers/reader-io.md:253
#, fuzzy
msgid ""
"Wrapping ordinary `IO` actions in `runIO` is noisy and distracts from the "
"flow of the program"
msgstr "将普通的 `IO` 操作包装在 `runIO` 中很嘈杂，并且会分散程序的流程"

#: src/monad-transformers/reader-io.md:254
#, fuzzy
msgid ""
"Writing monads instances by hand is repetitive, and the technique for adding"
" a reader effect to another monad is a design pattern that requires "
"documentation and communication overhead"
msgstr "手动编写单子实例很重复，并且将读取器效果添加到另一个单子的技术是一种设计模式，需要文档和通信开销"

#: src/monad-transformers/reader-io.md:256
#, fuzzy
msgid ""
"Using a technique called _monad transformers_, all of these downsides can be"
" addressed. A monad transformer takes a monad as an argument and returns a "
"new monad. Monad transformers consist of:"
msgstr "使用称为“单子转换器”的技术，可以解决所有这些缺点。单子转换器将单子作为参数并返回一个新单子。单子转换器包括："

#: src/monad-transformers/reader-io.md:259
#, fuzzy
msgid ""
"A definition of the transformer itself, which is typically a function from "
"types to types"
msgstr "转换器本身的定义，它通常是从类型到类型的函数"

#: src/monad-transformers/reader-io.md:260
#: src/monad-transformers/summary.md:12
#, fuzzy
msgid "A `Monad` instance that assumes the inner type is already a monad"
msgstr "一个 `Monad` 实例，它假定内部类型已经是一个单子"

#: src/monad-transformers/reader-io.md:261
#, fuzzy
msgid ""
"An operator to \"lift\" an action from the inner monad to the transformed "
"monad, akin to `runIO`"
msgstr "一个运算符，用于将操作从内部单子“提升”到转换后的单子，类似于 `runIO`"

#: src/monad-transformers/reader-io.md:263
#, fuzzy
msgid "Adding a Reader to Any Monad"
msgstr "将读取器添加到任何单子"

#: src/monad-transformers/reader-io.md:265
#, fuzzy
msgid ""
"Adding a reader effect to `IO` was accomplished in `ConfigIO` by wrapping "
"`IO α` in a function type. The Lean standard library contains a function "
"that can do this to _any_ polymorphic type, called `ReaderT`:"
msgstr ""
"通过将 `IO α` 包装在函数类型中，在 `ConfigIO` 中实现了向 `IO` 添加读取器效果。Lean 标准库包含一个函数，可以对 _any_"
" 多态类型执行此操作，称为 `ReaderT`："

#: src/monad-transformers/reader-io.md:271
#, fuzzy
msgid "Its arguments are as follows:"
msgstr "其参数如下："

#: src/monad-transformers/reader-io.md:272
#, fuzzy
msgid "`ρ` is the environment that is accessible to the reader"
msgstr "`ρ` 是可供读取器的环境"

#: src/monad-transformers/reader-io.md:273
#, fuzzy
msgid "`m` is the monad that is being transformed, such as `IO`"
msgstr "`m` 是要转换的单子，例如 `IO`"

#: src/monad-transformers/reader-io.md:274
#, fuzzy
msgid ""
"`α` is the type of values being returned by the monadic computation Both `α`"
" and `ρ` are in the same universe because the operator that retrieves the "
"environment in the monad will have type `m ρ`."
msgstr "`α` 是单子计算返回的值的类型"

#: src/monad-transformers/reader-io.md:277
#, fuzzy
msgid "With `ReaderT`, `ConfigIO` becomes:"
msgstr "`α` 和 `ρ` 都在同一个 universe 中，因为在单子中检索环境的运算符将具有类型 `m ρ`。"

#: src/monad-transformers/reader-io.md:281
#, fuzzy
msgid ""
"It is an `abbrev` because `ReaderT` has many useful features defined in the "
"standard library that a non-reducible definition would hide. Rather than "
"taking responsibility for making these work directly for `ConfigIO`, it's "
"easier to simply have `ConfigIO` behave identically to `ReaderT Config IO`."
msgstr "使用 `ReaderT`，`ConfigIO` 变为："

#: src/monad-transformers/reader-io.md:284
#, fuzzy
msgid ""
"The manually-written `currentConfig` obtained the environment out of the "
"reader. This effect can be defined in a generic form for all uses of "
"`ReaderT`, under the name `read`:"
msgstr ""
"它是一个 `abbrev`，因为 `ReaderT` 在标准库中定义了许多有用的特性，而不可约化的定义会隐藏这些特性。与其直接负责让这些特性对 "
"`ConfigIO` 起作用，不如简单地让 `ConfigIO` 的行为与 `ReaderT Config IO` 完全相同。"

#: src/monad-transformers/reader-io.md:290
#, fuzzy
msgid ""
"However, not every monad that provides a reader effect is built with "
"`ReaderT`. The type class `MonadReader` allows any monad to provide a `read`"
" operator:"
msgstr ""
"手动编写的 `currentConfig` 从读取器中获取环境。这种效果可以为 `ReaderT` 的所有用法定义一个通用形式，名称为 `read`："

#: src/monad-transformers/reader-io.md:301
#, fuzzy
msgid ""
"The type `ρ` is an output parameter because any given monad typically only "
"provides a single type of environment through a reader, so automatically "
"selecting it when the monad is known makes programs more convenient to "
"write."
msgstr ""
"但是，并非每个提供读取器效果的单子都是用 `ReaderT` 构建的。类型类 `MonadReader` 允许任何单子提供一个 `read` 运算符："

#: src/monad-transformers/reader-io.md:303
#, fuzzy
msgid ""
"The `Monad` instance for `ReaderT` is essentially the same as the `Monad` "
"instance for `ConfigIO`, except `IO` has been replaced by some arbitrary "
"monad argument `m`:"
msgstr "类型 `ρ` 是一个输出参数，因为任何给定的单子通常只通过读取器提供一种类型的环境，因此在已知单子时自动选择它使得程序更易于编写。"

#: src/monad-transformers/reader-io.md:313
#, fuzzy
msgid ""
"The next step is to eliminate uses of `runIO`. When Lean encounters a "
"mismatch in monad types, it automatically attempts to use a type class "
"called `MonadLift` to transform the actual monad into the expected monad. "
"This process is similar to the use of coercions. `MonadLift` is defined as "
"follows:"
msgstr ""
"`ReaderT` 的 `Monad` 实例与 `ConfigIO` 的 `Monad` 实例基本相同，只是 `IO` 已被某个任意的单子参数 `m` "
"替换："

#: src/monad-transformers/reader-io.md:321
#, fuzzy
msgid ""
"The method `monadLift` translates from the monad `m` to the monad `n`. The "
"process is called \"lifting\" because it takes an action in the embedded "
"monad and makes it into an action in the surrounding monad. In this case, it"
" will be used to \"lift\" from `IO` to `ReaderT Config IO`, though the "
"instance works for _any_ inner monad `m`:"
msgstr ""
"`monadLift` 方法将单子 `m` 转换为单子 "
"`n`。这个过程被称为“提升”，因为它将嵌入式单子中的动作转换为周围单子中的动作。在本例中，它将用于从 `IO` “提升”到 `ReaderT "
"Config IO`，尽管该实例适用于 _任何_ 内部单子 `m`："

#: src/monad-transformers/reader-io.md:328
#, fuzzy
msgid ""
"The implementation of `monadLift` is very similar to that of `runIO`. "
"Indeed, it is enough to define `showFileName` and `showDirName` without "
"using `runIO`:"
msgstr ""
"`monadLift` 的实现与 `runIO` 非常相似。事实上，只需在不使用 `runIO` 的情况下定义 `showFileName` 和 "
"`showDirName` 即可："

#: src/monad-transformers/reader-io.md:330
msgid ""
"```lean\n"
"def showFileName (file : String) : ConfigIO Unit := do\n"
"  IO.println s!\"{(← read).currentPrefix} {file}\"\n"
"\n"
"def showDirName (dir : String) : ConfigIO Unit := do\n"
"  IO.println s!\"{(← read).currentPrefix} {dir}/\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:338
#, fuzzy
msgid ""
"One final operation from the original `ConfigIO` remains to be translated to"
" a use of `ReaderT`: `locally`. The definition can be translated directly to"
" `ReaderT`, but the Lean standard library provides a more general version. "
"The standard version is called `withReader`, and it is part of a type class "
"called `MonadWithReader`:"
msgstr ""
"原始 `ConfigIO` 中的最后一个操作仍需转换为 `ReaderT` 的用法：`locally`。该定义可以直接转换为 `ReaderT`，但 "
"Lean 标准库提供了一个更通用的版本。标准版本称为 `withReader`，它是类型类 `MonadWithReader` 的一部分："

#: src/monad-transformers/reader-io.md:345
#, fuzzy
msgid ""
"Just as in `MonadReader`, the environment `ρ` is an `outParam`. The "
"`withReader` operation is exported, so that it doesn't need to be written "
"with the type class name before it:"
msgstr ""
"与 `MonadReader` 中一样，环境 `ρ` 是一个 `outParam`。`withReader` "
"操作被导出，因此无需在它之前编写类型类名称："

#: src/monad-transformers/reader-io.md:350
#, fuzzy
msgid ""
"The instance for `ReaderT` is essentially the same as the definition of "
"`locally`:"
msgstr "`ReaderT` 的实例本质上与 `locally` 的定义相同："

#: src/monad-transformers/reader-io.md:357
#, fuzzy
msgid ""
"With these definitions in place, the new version of `dirTree` can be "
"written:"
msgstr "有了这些定义，就可以编写新版本的 `dirTree`："

#: src/monad-transformers/reader-io.md:370
#, fuzzy
msgid ""
"Aside from replacing `locally` with `withReader`, it is the same as before."
msgstr "除了将 `locally` 替换为 `withReader` 之外，它与之前相同。"

#: src/monad-transformers/reader-io.md:373
#, fuzzy
msgid ""
"Replacing the custom `ConfigIO` type with `ReaderT` did not save a large "
"number of lines of code in this section. However, rewriting the code using "
"components from the standard library does have long-term benefits. First, "
"readers who know about `ReaderT` don't need to take time to understand the "
"`Monad` instance for `ConfigIO`, working backwards to the meaning of monad "
"itself. Instead, they can be confident in their initial understanding. Next,"
" adding further effects to the monad (such as a state effect to count the "
"files in each directory and display a count at the end) requires far fewer "
"changes to the code, because the monad transformers and `MonadLift` "
"instances provided in the library work well together. Finally, using a set "
"of type classes included in the standard library, polymorphic code can be "
"written in such a way that it can work with a variety of monads without "
"having to care about details like the order in which the monad transformers "
"were applied. Just as some functions work in any monad, others can work in "
"any monad that provides a certain type of state, or a certain type of "
"exceptions, without having to specifically describe the _way_ in which a "
"particular concrete monad provides the state or exceptions."
msgstr ""
"用 `ReaderT` 替换自定义 `ConfigIO` 类型并没有节省本节中的大量代码行。然而，使用标准库中的组件重写代码确实具有长期好处。首先，了解"
" `ReaderT` 的读者无需花时间理解 `ConfigIO` 的 `Monad` "
"实例，从而反向理解单子的含义。相反，他们可以确信自己最初的理解。接下来，向单子添加更多效果（例如状态效果来计算每个目录中的文件并显示结尾处的计数）需要对代码进行的更改要少得多，因为库中提供的单子转换器和"
" `MonadLift` "
"实例可以很好地协同工作。最后，使用标准库中包含的一组类型类，可以编写多态代码，使其可以与各种单子一起使用，而无需关心诸如应用单子转换器的顺序之类的细节。就像某些函数可以在任何单子中工作一样，其他函数可以在提供某种状态或某种异常的任何单子中工作，而无需具体描述特定具体单子提供状态或异常的方式。"

#: src/monad-transformers/reader-io.md:383
#, fuzzy
msgid "Controlling the Display of Dotfiles"
msgstr "控制点文件的显示"

#: src/monad-transformers/reader-io.md:385
#, fuzzy
msgid ""
"Files whose names begin with a dot character (`'.'`) typically represent "
"files that should usually be hidden, such as source-control metadata and "
"configuration files. Modify `doug` with an option to show or hide filenames "
"that begin with a dot. This option should be controlled with a `-a` command-"
"line option."
msgstr ""
"以点字符（'.'）开头的文件通常表示通常应该隐藏的文件，例如源代码控制元数据和配置文件。使用 `-a` 命令行选项修改 `doug` "
"以显示或隐藏以点开头的文件名。"

#: src/monad-transformers/reader-io.md:389
#, fuzzy
msgid "Starting Directory as Argument"
msgstr "起始目录作为参数"

#: src/monad-transformers/reader-io.md:391
#, fuzzy
msgid ""
"Modify `doug` so that it takes a starting directory as an additional "
"command-line argument."
msgstr "修改 `doug`，使其将起始目录作为附加命令行参数。"
