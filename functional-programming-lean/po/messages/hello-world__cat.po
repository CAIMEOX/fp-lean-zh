#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/hello-world/cat.md:3
#, fuzzy
msgid ""
"The standard Unix utility `cat` takes a number of command-line options, "
"followed by zero or more input files. If no files are provided, or if one of"
" them is a dash (`-`), then it takes the standard input as the corresponding"
" input instead of reading a file. The contents of the inputs are written, "
"one after the other, to the standard output. If a specified input file does "
"not exist, this is noted on standard error, but `cat` continues "
"concatenating the remaining inputs. A non-zero exit code is returned if any "
"of the input files do not exist."
msgstr ""
"标准 Unix 实用程序 `cat` 接受多个命令行选项，后跟零个或多个输入文件。如果没有提供文件，或者其中一个文件是破折号 "
"(`-`)，则它将标准输入作为相应的输入，而不是读取文件。输入的内容将按顺序写入标准输出。如果指定的输入文件不存在，则会在标准错误中注明，但 `cat`"
" 会继续连接剩余的输入。如果任何输入文件不存在，则返回非零退出代码。"

#: src/hello-world/cat.md:9
#, fuzzy
msgid ""
"This section describes a simplified version of `cat`, called `feline`. "
"Unlike commonly-used versions of `cat`, `feline` has no command-line options"
" for features such as numbering lines, indicating non-printing characters, "
"or displaying help text. Furthermore, it cannot read more than once from a "
"standard input that's associated with a terminal device."
msgstr ""
"本节介绍了 `cat` 的简化版本，称为 `feline`。与 `cat` 的常用版本不同，`feline` "
"没有用于诸如对行编号、指示不可打印字符或显示帮助文本等功能的命令行选项。此外，它无法从与终端设备关联的标准输入中读取多次。"

#: src/hello-world/cat.md:13
#, fuzzy
msgid ""
"To get the most benefit from this section, follow along yourself. It's OK to"
" copy-paste the code examples, but it's even better to type them in by hand."
" This makes it easier to learn the mechanical process of typing in code, "
"recovering from mistakes, and interpreting feedback from the compiler."
msgstr ""
"要充分利用本节，请自己动手操作。复制粘贴代码示例是可以的，但最好手动输入它们。这使得学习输入代码、从错误中恢复以及解释编译器反馈的机械过程变得更加容易。"

#: src/hello-world/cat.md:17
#, fuzzy
msgid "Getting started"
msgstr "开始"

#: src/hello-world/cat.md:19
#, fuzzy
msgid ""
"The first step in implementing `feline` is to create a package and decide "
"how to organize the code. In this case, because the program is so simple, "
"all the code will be placed in `Main.lean`. The first step is to run `lake "
"new feline`. Edit the Lakefile to remove the library, and delete the "
"generated library code and the reference to it from `Main.lean`. Once this "
"has been done, `lakefile.lean` should contain:"
msgstr ""
"第一步是创建包并决定如何组织代码。在本例中，由于程序非常简单，所有代码都将放在 `Main.lean` 中。第一步是运行 `lake new "
"feline`。编辑 `Lakefile` 以删除库，并删除生成的库代码及其在 `Main.lean` 中的引用。完成后，`lakefile.lean`"
" 应包含："

#: src/hello-world/cat.md:39
#, fuzzy
msgid "and `Main.lean` should contain something like:"
msgstr "`Main.lean` 应包含类似以下内容："

#: src/hello-world/cat.md:40
#, fuzzy
msgid ""
"```lean\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, cats!\"\n"
"```"
msgstr ""
"```lean\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, cats!\"\n"
"```"

#: src/hello-world/cat.md:44
#, fuzzy
msgid ""
"Alternatively, running `lake new feline exe` instructs `lake` to use a "
"template that does not include a library section, making it unnecessary to "
"edit the file."
msgstr "或者，运行 `lake new feline exe` 指示 `lake` 使用不包含库部分的模板，从而无需编辑文件。"

#: src/hello-world/cat.md:46
#, fuzzy
msgid "Ensure that the code can be built by running `lake build`."
msgstr "通过运行 `lake build` 确保可以构建代码。"

#: src/hello-world/cat.md:49
#, fuzzy
msgid "Concatenating Streams"
msgstr "连接流"

#: src/hello-world/cat.md:51
#, fuzzy
msgid ""
"Now that the basic skeleton of the program has been built, it's time to "
"actually enter the code. A proper implementation of `cat` can be used with "
"infinite IO streams, such as `/dev/random`, which means that it can't read "
"its input into memory before outputting it. Furthermore, it should not work "
"one character at a time, as this leads to frustratingly slow performance. "
"Instead, it's better to read contiguous blocks of data all at once, "
"directing the data to the standard output one block at a time."
msgstr ""
"现在已经构建了程序的基本框架，是时候实际输入代码了。`cat` 的正确实现可以与无限 IO 流（例如 "
"`/dev/random`）一起使用，这意味着它不能在输出之前将其输入读入内存。此外，它不应一次处理一个字符，因为这会导致令人沮丧的缓慢性能。相反，最好一次读取连续的数据块，一次将数据定向到标准输出。"

#: src/hello-world/cat.md:56
#, fuzzy
msgid ""
"The first step is to decide how big of a block to read. For the sake of "
"simplicity, this implementation uses a conservative 20 kilobyte block. "
"`USize` is analogous to `size_t` in C—it's an unsigned integer type that is "
"big enough to represent all valid array sizes."
msgstr ""
"第一步是确定要读取的块的大小。为了简单起见，此实现使用保守的 20 千字节块。`USize` 类似于 C 中的 "
"`size_t`——它是一个无符号整数类型，足够大以表示所有有效的数组大小。"

#: src/hello-world/cat.md:63
#, fuzzy
msgid "Streams"
msgstr "流"

#: src/hello-world/cat.md:65
#, fuzzy
msgid ""
"The main work of `feline` is done by `dump`, which reads input one block at "
"a time, dumping the result to standard output, until the end of the input "
"has been reached:"
msgstr "`feline` 的主要工作由 `dump` 完成，它一次读取一个块的输入，将结果转储到标准输出，直到达到输入的末尾："

#: src/hello-world/cat.md:76
#, fuzzy
msgid ""
"The `dump` function is declared `partial`, because it calls itself "
"recursively on input that is not immediately smaller than an argument. When "
"a function is declared to be partial, Lean does not require a proof that it "
"terminates. On the other hand, partial functions are also much less amenable"
" to proofs of correctness, because allowing infinite loops in Lean's logic "
"would make it unsound. However, there is no way to prove that `dump` "
"terminates, because infinite input (such as from `/dev/random`) would mean "
"that it does not, in fact, terminate. In cases like this, there is no "
"alternative to declaring the function `partial`."
msgstr ""
"`dump` 函数被声明为 `partial`，因为它在输入上递归调用自身，该输入不会立即小于一个参数。当一个函数被声明为 `partial` "
"时，Lean 不要求证明它会终止。另一方面，`partial` 函数也不太适合正确性证明，因为允许在 Lean "
"的逻辑中进行无限循环会使其不健全。然而，没有办法证明 `dump` 会终止，因为无限输入（例如来自 "
"`/dev/random`）意味着它实际上不会终止。在这种情况下，除了将函数声明为 `partial` 之外别无选择。"

#: src/hello-world/cat.md:82
#, fuzzy
msgid ""
"The type `IO.FS.Stream` represents a POSIX stream. Behind the scenes, it is "
"represented as a structure that has one field for each POSIX stream "
"operation. Each operation is represented as an IO action that provides the "
"corresponding operation:"
msgstr ""
"类型 `IO.FS.Stream` 表示一个 POSIX 流。在幕后，它被表示为一个结构，它为每个 POSIX 流操作有一个字段。每个操作都表示为一个 "
"IO 操作，它提供了相应的操作："

#: src/hello-world/cat.md:93
#, fuzzy
msgid ""
"The Lean compiler contains `IO` actions (such as `IO.getStdout`, which is "
"called in `dump`) to get streams that represent standard input, standard "
"output, and standard error. These are `IO` actions rather than ordinary "
"definitions because Lean allows these standard POSIX streams to be replaced "
"in a process, which makes it easier to do things like capturing the output "
"from a program into a string by writing a custom `IO.FS.Stream`."
msgstr ""
"Lean 编译器包含 `IO` 操作（例如 `IO.getStdout`，它在 `dump` "
"中被调用）以获取表示标准输入、标准输出和标准错误的流。这些是 `IO` 操作，而不是普通定义，因为 Lean 允许在进程中替换这些标准 POSIX "
"流，这使得通过编写自定义 `IO.FS.Stream` 将程序的输出捕获到字符串中变得更容易。"

#: src/hello-world/cat.md:96
#, fuzzy
msgid ""
"The control flow in `dump` is essentially a `while` loop. When `dump` is "
"called, if the stream has reached the end of the file, `pure ()` terminates "
"the function by returning the constructor for `Unit`. If the stream has not "
"yet reached the end of the file, one block is read, and its contents are "
"written to `stdout`, after which `dump` calls itself directly. The recursive"
" calls continue until `stream.read` returns an empty byte array, which "
"indicates that the end of the file has been reached."
msgstr ""
"`dump` 中的控制流本质上是一个 `while` 循环。当调用 `dump` 时，如果流已达到文件末尾，`pure ()` 通过返回 `Unit` "
"的构造函数来终止函数。如果流尚未达到文件末尾，则读取一个块，并将它的内容写入 `stdout`，之后 `dump` 直接调用自身。递归调用会一直持续到 "
"`stream.read` 返回一个空字节数组，这表示已达到文件末尾。"

#: src/hello-world/cat.md:101
#, fuzzy
msgid ""
"When an `if` expression occurs as a statement in a `do`, as in `dump`, each "
"branch of the `if` is implicitly provided with a `do`. In other words, the "
"sequence of steps following the `else` are treated as a sequence of `IO` "
"actions to be executed, just as if they had a `do` at the beginning. Names "
"introduced with `let` in the branches of the `if` are visible only in their "
"own branches, and are not in scope outside of the `if`."
msgstr ""
"当 `if` 表达式作为 `do` 中的语句出现时，如 `dump` 中，`if` 的每个分支都会隐式地提供一个 `do`。换句话说，跟在 `else`"
" 之后的步骤序列被视为要执行的 `IO` 动作序列，就像它们在开头有一个 `do` 一样。在 `if` 分支中用 `let` "
"引入的名称只在其自己的分支中可见，并且不在 `if` 之外的范围内。"

#: src/hello-world/cat.md:105
#, fuzzy
msgid ""
"There is no danger of running out of stack space while calling `dump` "
"because the recursive call happens as the very last step in the function, "
"and its result is returned directly rather than being manipulated or "
"computed with. This kind of recursion is called _tail recursion_, and it is "
"described in more detail [later in this book](../programs-proofs/tail-"
"recursion.md). Because the compiled code does not need to retain any state, "
"the Lean compiler can compile the recursive call to a jump."
msgstr ""
"在调用 `dump` 时，不会出现耗尽堆栈空间的危险，因为递归调用发生在函数的最后一步，并且其结果被直接返回，而不是被操作或计算。这种递归称为 "
"_尾递归_，将在 [本书后面](../programs-proofs/tail-recursion.md) "
"详细描述。由于编译后的代码不需要保留任何状态，因此 Lean 编译器可以将递归调用编译为跳转。"

#: src/hello-world/cat.md:109
#, fuzzy
msgid ""
"If `feline` only redirected standard input to standard output, then `dump` "
"would be sufficient. However, it also needs to be able to open files that "
"are provided as command-line arguments and emit their contents. When its "
"argument is the name of a file that exists, `fileStream` returns a stream "
"that reads the file's contents. When the argument is not a file, "
"`fileStream` emits an error and returns `none`."
msgstr ""
"如果 `feline` 只将标准输入重定向到标准输出，那么 `dump` "
"就足够了。但是，它还需要能够打开作为命令行参数提供的文件并输出其内容。当其参数是存在的文件名时，`fileStream` "
"返回读取文件内容的流。当参数不是文件时，`fileStream` 发出错误并返回 `none`。"

#: src/hello-world/cat.md:113
#, fuzzy
msgid ""
"```lean\n"
"def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do\n"
"  let fileExists ← filename.pathExists\n"
"  if not fileExists then\n"
"    let stderr ← IO.getStderr\n"
"    stderr.putStrLn s!\"File not found: {filename}\"\n"
"    pure none\n"
"  else\n"
"    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read\n"
"    pure (some (IO.FS.Stream.ofHandle handle))\n"
"```"
msgstr ""
"```lean\n"
"def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do\n"
"  let fileExists ← filename.pathExists\n"
"  if not fileExists then\n"
"    let stderr ← IO.getStderr\n"
"    stderr.putStrLn s!\"File not found: {filename}\"\n"
"    pure none\n"
"  else\n"
"    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read\n"
"    pure (some (IO.FS.Stream.ofHandle handle))\n"
"```"

#: src/hello-world/cat.md:124
#, fuzzy
msgid ""
"Opening a file as a stream takes two steps. First, a file handle is created "
"by opening the file in read mode. A Lean file handle tracks an underlying "
"file descriptor. When there are no references to the file handle value, a "
"finalizer closes the file descriptor. Second, the file handle is given the "
"same interface as a POSIX stream using `IO.FS.Stream.ofHandle`, which fills "
"each field of the `Stream` structure with the corresponding `IO` action that"
" works on file handles."
msgstr ""
"打开一个文件作为流需要两个步骤。首先，通过以读取模式打开文件来创建一个文件句柄。Lean "
"文件句柄跟踪底层文件描述符。当没有对文件句柄值进行引用时，终结器会关闭文件描述符。其次，使用 `IO.FS.Stream.ofHandle` "
"为文件句柄提供与 POSIX 流相同的接口，该接口使用在文件句柄上工作的相应 `IO` 操作填充 `Stream` 结构的每个字段。"

#: src/hello-world/cat.md:130
#, fuzzy
msgid "Handling Input"
msgstr "处理输入"

#: src/hello-world/cat.md:132
#, fuzzy
msgid ""
"The main loop of `feline` is another tail-recursive function, called "
"`process`. In order to return a non-zero exit code if any of the inputs "
"could not be read, `process` takes an argument `exitCode` that represents "
"the current exit code for the whole program. Additionally, it takes a list "
"of input files to be processed."
msgstr ""
"`feline` 的主循环是另一个尾递归函数，称为 `process`。为了在无法读取任何输入时返回非零退出代码，`process` 采用一个参数 "
"`exitCode`，该参数表示整个程序的当前退出代码。此外，它采用一个要处理的输入文件列表。"

#: src/hello-world/cat.md:135
#, fuzzy
msgid ""
"```lean\n"
"def process (exitCode : UInt32) (args : List String) : IO UInt32 := do\n"
"  match args with\n"
"  | [] => pure exitCode\n"
"  | \"-\" :: args =>\n"
"    let stdin ← IO.getStdin\n"
"    dump stdin\n"
"    process exitCode args\n"
"  | filename :: args =>\n"
"    let stream ← fileStream ⟨filename⟩\n"
"    match stream with\n"
"    | none =>\n"
"      process 1 args\n"
"    | some stream =>\n"
"      dump stream\n"
"      process exitCode args\n"
"```"
msgstr ""
"```lean\n"
"def process (exitCode : UInt32) (args : List String) : IO UInt32 := do\n"
"  match args with\n"
"  | [] => pure exitCode\n"
"  | \"-\" :: args =>\n"
"    let stdin ← IO.getStdin\n"
"    dump stdin\n"
"    process exitCode args\n"
"  | filename :: args =>\n"
"    let stream ← fileStream ⟨filename⟩\n"
"    match stream with\n"
"    | none =>\n"
"      process 1 args\n"
"    | some stream =>\n"
"      dump stream\n"
"      process exitCode args\n"
"```"

#: src/hello-world/cat.md:152
#, fuzzy
msgid ""
"Just as with `if`, each branch of a `match` that is used as a statement in a"
" `do` is implicitly provided with its own `do`."
msgstr "就像 `if` 一样，用作 `do` 中语句的 `match` 的每个分支都隐式地提供了自己的 `do`。"

#: src/hello-world/cat.md:154
#, fuzzy
msgid ""
"There are three possibilities. One is that no more files remain to be "
"processed, in which case `process` returns the error code unchanged. Another"
" is that the specified filename is `\"-\"`, in which case `process` dumps "
"the contents of the standard input and then processes the remaining "
"filenames. The final possibility is that an actual filename was specified. "
"In this case, `fileStream` is used to attempt to open the file as a POSIX "
"stream. Its argument is encased in `⟨ ... ⟩` because a `FilePath` is a "
"single-field structure that contains a string. If the file could not be "
"opened, it is skipped, and the recursive call to `process` sets the exit "
"code to `1`. If it could, then it is dumped, and the recursive call to "
"`process` leaves the exit code unchanged."
msgstr ""
"有三种可能性。一种是没有更多文件需要处理，在这种情况下，`process` 返回未更改的错误代码。另一种是指定的文件名为 `\"-\"`, "
"在这种情况下，`process` 转储标准输入的内容，然后处理剩余的文件名。最后一种可能性是指定了实际文件名。在这种情况下，`fileStream` "
"用于尝试将文件作为 POSIX 流打开。它的参数被封装在 `⟨ ... ⟩` 中，因为 `FilePath` "
"是一个包含字符串的单字段结构。如果无法打开文件，则跳过该文件，并且对 `process` 的递归调用将退出代码设置为 "
"`1`。如果可以，则将其转储，并且对 `process` 的递归调用将使退出代码保持不变。"

#: src/hello-world/cat.md:163
#, fuzzy
msgid ""
"`process` does not need to be marked `partial` because it is structurally "
"recursive. Each recursive call is provided with the tail of the input list, "
"and all Lean lists are finite. Thus, `process` does not introduce any non-"
"termination."
msgstr ""
"`process` 无需标记为 `partial`，因为它在结构上是递归的。每次递归调用都会提供输入列表的尾部，并且所有 Lean "
"列表都是有限的。因此，`process` 不会引入任何非终止。"

#: src/hello-world/cat.md:167
#, fuzzy
msgid "Main"
msgstr "Main"

#: src/hello-world/cat.md:169
#, fuzzy
msgid ""
"The final step is to write the `main` action. Unlike prior examples, `main` "
"in `feline` is a function. In Lean, `main` can have one of three types:"
msgstr ""
"最后一步是编写 `main` 动作。与之前的示例不同，`feline` 中的 `main` 是一个函数。在 Lean 中，`main` "
"可以有三种类型之一："

#: src/hello-world/cat.md:172
#, fuzzy
msgid ""
"`main : IO Unit` corresponds to programs that cannot read their command-line"
" arguments and always indicate success with an exit code of `0`,"
msgstr "`main : IO Unit` 对应于无法读取其命令行参数并始终以退出代码 `0` 表示成功的程序，"

#: src/hello-world/cat.md:173
#, fuzzy
msgid ""
"`main : IO UInt32` corresponds to `int main(void)` in C, for programs "
"without arguments that return exit codes, and"
msgstr "`main : IO UInt32` 对应于 C 中的 `int main(void)`，用于没有参数且返回退出代码的程序，"

#: src/hello-world/cat.md:174
#, fuzzy
msgid ""
"`main : List String → IO UInt32` corresponds to `int main(int argc, char "
"**argv)` in C, for programs that take arguments and signal success or "
"failure."
msgstr ""
"`main : List String → IO UInt32` 对应于 C 中的 `int main(int argc, char "
"**argv)`，用于获取参数并发出成功或失败信号的程序。"

#: src/hello-world/cat.md:176
#, fuzzy
msgid ""
"If no arguments were provided, `feline` should read from standard input as "
"if it were called with a single `\"-\"` argument. Otherwise, the arguments "
"should be processed one after the other."
msgstr "如果没有提供参数，`feline` 应从标准输入读取，就像使用单个 `\"-\"` 参数调用它一样。否则，应依次处理参数。"

#: src/hello-world/cat.md:178
#, fuzzy
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 :=\n"
"  match args with\n"
"  | [] => process 0 [\"-\"]\n"
"  | _ =>  process 0 args\n"
"```"
msgstr ""
"```lean\n"
"def main (args : List String) : IO UInt32 :=\n"
"  match args with\n"
"  | [] => process 0 [\"-\"]\n"
"  | _ =>  process 0 args\n"
"```"

#: src/hello-world/cat.md:186
#, fuzzy
msgid "Meow!"
msgstr "喵！"

#: src/hello-world/cat.md:188
#, fuzzy
msgid ""
"To check whether `feline` works, the first step is to build it with `lake "
"build`. First off, when called without arguments, it should emit what it "
"receives from standard input. Check that"
msgstr ""
"要检查 `feline` 是否工作，第一步是用 `lake build` "
"构建它。首先，在没有参数的情况下调用它时，它应该发出从标准输入接收到的内容。检查"

#: src/hello-world/cat.md:191
#, fuzzy
msgid ""
"```\n"
"echo \"It works!\" | ./build/bin/feline\n"
"```"
msgstr ""
"```\n"
"echo \"It works!\" | ./build/bin/feline\n"
"```"

#: src/hello-world/cat.md:194
#, fuzzy
msgid "emits `It works!`."
msgstr "发出 `It works!`。"

#: src/hello-world/cat.md:196
#, fuzzy
msgid ""
"Secondly, when called with files as arguments, it should print them. If the "
"file `test1.txt` contains"
msgstr "其次，当使用文件作为参数调用它时，它应该打印它们。如果文件 `test1.txt` 包含"

#: src/hello-world/cat.md:201
#, fuzzy
msgid "and `test2.txt` contains"
msgstr "而 `test2.txt` 包含"

#: src/hello-world/cat.md:205
#, fuzzy
msgid "then the command"
msgstr "那么命令"

#: src/hello-world/cat.md:209
#, fuzzy
msgid "should emit"
msgstr "最终，`-` 参数应得到适当处理。"

#: src/hello-world/cat.md:215
msgid "Finally, the `-` argument should be handled appropriately."
msgstr "最终，`-` 参数应得到适当处理。"

#: src/hello-world/cat.md:216
msgid ""
"```\n"
"echo \"and purr\" | ./build/bin/feline test1.txt - test2.txt\n"
"```"
msgstr ""
"```\n"
"echo \"and purr\" | ./build/bin/feline test1.txt - test2.txt\n"
"```"

#: src/hello-world/cat.md:219 src/type-classes/out-params.md:188
msgid "should yield"
msgstr "应产生"

#: src/hello-world/cat.md:228
msgid ""
"Extend `feline` with support for usage information. The extended version "
"should accept a command-line argument `--help` that causes documentation "
"about the available command-line options to be written to standard output."
msgstr "扩展 `feline` 以支持使用信息。扩展版本应接受命令行参数 `--help`，该参数会导致有关可用命令行选项的文档被写入标准输出。"
