#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/getting-to-know/functions-and-definitions.md:3
#, fuzzy
msgid ""
"In Lean, definitions are introduced using the `def` keyword. For instance, "
"to define the name `hello` to refer to the string `\"Hello\"`, write:"
msgstr "在 Lean 中，使用 `def` 关键字引入定义。例如，若要定义名称 `hello` 以引用字符串 `\"Hello\"`，请编写："

#: src/getting-to-know/functions-and-definitions.md:5
#, fuzzy
msgid ""
"```lean\n"
"def hello := \"Hello\"\n"
"```"
msgstr ""
"在 Lean 中，使用冒号加等号运算符 `:=` 而不是 `=` 来定义新名称。这是因为 `=` 用于描述现有表达式之间的相等性，而使用两个不同的运算符有助于防止混淆。\n"
"\n"
"在 `hello` 的定义中，表达式 `\"Hello\"` 足够简单，Lean 能够自动确定定义的类型。但是，大多数定义并不那么简单，因此通常需要添加类型。这可以通过在要定义的名称后使用冒号来完成。\n"
"\n"
"```lean\n"
"def lean : String := \"Lean\"\n"
"```\n"
"\n"
"现在已经定义了名称，就可以使用它们了，因此\n"
"\n"
"```Lean\n"
"#eval String.append hello (String.append \" \" lean)\n"
"```\n"
"\n"
"```Lean info\n"
"\"Hello Lean\"\n"
"```\n"
"\n"
"在 Lean 中，定义的名称只能在其定义之后使用。\n"
"\n"
"在许多语言中，函数的定义使用与其他值的定义不同的语法。例如，Python 函数定义以 `def` 关键字开头，而其他定义则以等号定义。在 Lean 中，函数使用与其他值相同的 `def` 关键字定义。尽管如此，诸如 `hello` 的定义引入了直接引用其值的名称，而不是每次调用时都返回等效结果的零参数函数。\n"
"\n"
"定义函数\n"
"\n"
"在 Lean 中有各种方法可以定义函数。最简单的方法是在定义的类型之前放置函数的参数，并用空格分隔。例如，可以编写一个将其参数加 1 的函数："

#: src/getting-to-know/functions-and-definitions.md:9
#, fuzzy
msgid ""
"In Lean, new names are defined using the colon-equal operator`:=` rather "
"than `=`. This is because `=` is used to describe equalities between "
"existing expressions, and using two different operators helps prevent "
"confusion."
msgstr ""
"在 Lean 中，使用冒号加等号运算符 `:=` 而不是 `=` 来定义新名称。这是因为 `=` "
"用于描述现有表达式之间的相等性，而使用两个不同的运算符有助于防止混淆。"

#: src/getting-to-know/functions-and-definitions.md:14
#, fuzzy
msgid ""
"In the definition of `hello`, the expression `\"Hello\"` is simple enough "
"that Lean is able to determine the definition's type automatically. However,"
" most definitions are not so simple, so it will usually be necessary to add "
"a type. This is done using a colon after the name being defined."
msgstr ""
"在 `hello` 的定义中，表达式 `\"Hello\"` 足够简单，Lean "
"能够自动确定定义的类型。但是，大多数定义并不那么简单，因此通常需要添加类型。这可以通过在要定义的名称后使用冒号来完成。"

#: src/getting-to-know/functions-and-definitions.md:18
#, fuzzy
msgid ""
"```lean\n"
"def lean : String := \"Lean\"\n"
"```"
msgstr ""
"```Lean\n"
"def lean : String := \"Lean\"\n"
"```"

#: src/getting-to-know/functions-and-definitions.md:22
#, fuzzy
msgid "Now that the names have been defined, they can be used, so"
msgstr "现在已经定义了名称，就可以使用它们了，因此"

#: src/getting-to-know/functions-and-definitions.md:23
#, fuzzy
msgid ""
"```Lean\n"
"#eval String.append hello (String.append \" \" lean)\n"
"```"
msgstr ""
"```Lean\n"
"#eval String.append hello (String.append \" \" lean)\n"
"```"

#: src/getting-to-know/functions-and-definitions.md:27
#, fuzzy
msgid ""
"```Lean info\n"
"\"Hello Lean\"\n"
"```"
msgstr ""
"```Lean info\n"
"\"Hello Lean\"\n"
"```"

#: src/getting-to-know/functions-and-definitions.md:30
#, fuzzy
msgid "In Lean, defined names may only be used after their definitions."
msgstr "在 Lean 中，定义的名称只能在其定义之后使用。"

#: src/getting-to-know/functions-and-definitions.md:32
#, fuzzy
msgid ""
"In many languages, definitions of functions use a different syntax than "
"definitions of other values. For instance, Python function definitions begin"
" with the `def` keyword, while other definitions are defined with an equals "
"sign. In Lean, functions are defined using the same `def` keyword as other "
"values. Nonetheless, definitions such as `hello` introduce names that refer "
"_directly_ to their values, rather than to zero-argument functions that "
"return equivalent results each time they are called."
msgstr ""
"在许多语言中，函数的定义使用与其他值的定义不同的语法。例如，Python 函数定义以 `def` 关键字开头，而其他定义则以等号定义。在 Lean "
"中，函数使用与其他值相同的 `def` 关键字定义。尽管如此，诸如 `hello` 的"

#: src/getting-to-know/functions-and-definitions.md:37
#, fuzzy
msgid "Defining Functions"
msgstr "定义函数"

#: src/getting-to-know/functions-and-definitions.md:39
#, fuzzy
msgid ""
"There are a variety of ways to define functions in Lean. The simplest is to "
"place the function's arguments before the definition's type, separated by "
"spaces. For instance, a function that adds one to its argument can be "
"written:"
msgstr ""
"在 Lean 中有各种方法可以定义函数。最简单的方法是在定义的类型之前放置函数的参数，并用空格分隔。例如，可以编写一个将其参数加 1 的函数："

#: src/getting-to-know/functions-and-definitions.md:45
#, fuzzy
msgid "Testing this function with `#eval` gives `8`, as expected:"
msgstr "测试此函数时，`#eval` 给出了 `8`，符合预期："

#: src/getting-to-know/functions-and-definitions.md:51
#, fuzzy
msgid ""
"Just as functions are applied to multiple arguments by writing spaces "
"between each argument, functions that accept multiple arguments are defined "
"with spaces between the arguments' names and types. The function `maximum`, "
"whose result is equal to the greatest of its two arguments, takes two `Nat` "
"arguments `n` and `k` and returns a `Nat`."
msgstr ""
"就像通过在每个参数之间写空格将函数应用于多个参数一样，接受多个参数的函数的定义是在参数名称和类型之间用空格分隔。函数 `maximum` "
"的结果等于其两个参数中最大的一个，它接受两个 `Nat` 参数 `n` 和 `k`，并返回一个 `Nat`。"

#: src/getting-to-know/functions-and-definitions.md:60
#, fuzzy
msgid ""
"When a defined function like `maximum` has been provided with its arguments,"
" the result is determined by first replacing the argument names with the "
"provided values in the body, and then evaluating the resulting body. For "
"example:"
msgstr "当像 `maximum` 这样的已定义函数被提供其参数时，结果是首先用提供的 body 中的值替换参数名称，然后计算结果 body。例如："

#: src/getting-to-know/functions-and-definitions.md:71
#, fuzzy
msgid ""
"Expressions that evaluate to natural numbers, integers, and strings have "
"types that say this (`Nat`, `Int`, and `String`, respectively). This is also"
" true of functions. A function that accepts a `Nat` and returns a `Bool` has"
" type `Nat → Bool`, and a function that accepts two `Nat`s and returns a "
"`Nat` has type `Nat → Nat → Nat`."
msgstr ""
"计算为自然数、整数和字符串的表达式具有表示这一点的类型（分别为 `Nat`、`Int` 和 `String`）。函数也是如此。接受一个 `Nat` "
"并返回一个 `Bool` 的函数的类型为 `Nat → Bool`，接受两个 `Nat` 并返回一个 `Nat` 的函数的类型为 `Nat → Nat "
"→ Nat`。"

#: src/getting-to-know/functions-and-definitions.md:75
#, fuzzy
msgid ""
"As a special case, Lean returns a function's signature when its name is used"
" directly with `#check`. Entering `#check add1` yields `add1 (n : Nat) : "
"Nat`. However, Lean can be \"tricked\" into showing the function's type by "
"writing the function's name in parentheses, which causes the function to be "
"treated as an ordinary expression, so `#check (add1)` yields `add1 : Nat → "
"Nat` and `#check (maximum)` yields `maximum : Nat → Nat → Nat`. This arrow "
"can also be written with an ASCII alternative arrow `->`, so the preceding "
"function types can be written `Nat -> Nat` and `Nat -> Nat -> Nat`, "
"respectively."
msgstr ""
"作为一个特例，当函数的名称直接与 `#check` 一起使用时，Lean 会返回函数的签名。输入 `#check add1` 会产生 `add1 (n "
": Nat) : Nat`。但是，可以通过用括号括住函数名称来“欺骗” Lean 显示函数的类型，这会导致函数被视为一个普通表达式，所以 `#check"
" (add1)` 会产生 `add1 : Nat → Nat`，而 `#check (maximum)` 会产生 `maximum : Nat → "
"Nat → Nat`。此箭头也可以用 ASCII 替代箭头 `->` 来写，因此前面的函数类型可以分别写成 `Nat -> Nat` 和 `Nat ->"
" Nat -> Nat`。"

#: src/getting-to-know/functions-and-definitions.md:80
#, fuzzy
msgid ""
"Behind the scenes, all functions actually expect precisely one argument. "
"Functions like `maximum` that seem to take more than one argument are in "
"fact functions that take one argument and then return a new function. This "
"new function takes the next argument, and the process continues until no "
"more arguments are expected. This can be seen by providing one argument to a"
" multiple-argument function: `#check maximum 3` yields `maximum 3 : Nat → "
"Nat` and `#check String.append \"Hello \"` yields `String.append \"Hello \" "
": String → String`. Using a function that returns a function to implement "
"multiple-argument functions is called _currying_ after the mathematician "
"Haskell Curry. Function arrows associate to the right, which means that `Nat"
" → Nat → Nat` should be parenthesized `Nat → (Nat → Nat)`."
msgstr ""
"幕后，所有函数实际上都精确地期望一个参数。像 `maximum` "
"这样的函数看起来需要多个参数，但实际上它们是接受一个参数并返回一个新函数的函数。这个新函数接受下一个参数，这个过程一直持续到不再需要更多参数。可以通过向一个多参数函数提供一个参数来看到这一点：`#check"
" maximum 3` 会生成 `maximum 3 : Nat → Nat`，而 `#check String.append \"Hello \"` "
"会生成 `String.append \"Hello \" : String → String`。使用返回函数的函数来实现多参数函数被称为 "
"_柯里化_，以数学家哈斯克尔·柯里命名。函数箭头向右关联，这意味着 `Nat → Nat → Nat` 应该用括号括起来 `Nat → (Nat → "
"Nat)`。"

#: src/getting-to-know/functions-and-definitions.md:89
#, fuzzy
msgid ""
"Define the function `joinStringsWith` with type `String -> String -> String "
"-> String` that creates a new string by placing its first argument between "
"its second and third arguments. `joinStringsWith \", \" \"one\" \"and "
"another\"` should evaluate to `\"one, and another\"`."
msgstr ""
"定义函数 `joinStringsWith`，类型为 `String -> String -> String -> "
"String`，它通过将第一个参数放在第二个和第三个参数之间来创建一个新字符串。`joinStringsWith \", \" \"one\" "
"\"and another\"` 应该求值为 `\"one, and another\"`。"

#: src/getting-to-know/functions-and-definitions.md:90
#, fuzzy
msgid "What is the type of `joinStringsWith \": \"`? Check your answer with Lean."
msgstr "`joinStringsWith \": \"` 的类型是什么？用 Lean 检查你的答案。"

#: src/getting-to-know/functions-and-definitions.md:91
#, fuzzy
msgid ""
"Define a function `volume` with type `Nat → Nat → Nat → Nat` that computes "
"the volume of a rectangular prism with the given height, width, and depth."
msgstr "定义一个函数 `volume`，类型为 `Nat → Nat → Nat → Nat`，它计算给定高度、宽度和深度的矩形棱柱的体积。"

#: src/getting-to-know/functions-and-definitions.md:93
#, fuzzy
msgid "Defining Types"
msgstr "定义类型"

#: src/getting-to-know/functions-and-definitions.md:95
#, fuzzy
msgid ""
"Most typed programming languages have some means of defining aliases for "
"types, such as C's `typedef`. In Lean, however, types are a first-class part"
" of the language - they are expressions like any other. This means that "
"definitions can refer to types just as well as they can refer to other "
"values."
msgstr ""
"大多数类型化编程语言都有一些方法来定义类型的别名，例如 C 语言的 `typedef`。然而，在 Lean "
"中，类型是语言的一等部分——它们与其他任何表达式一样都是表达式。这意味着定义可以引用类型，就像它们可以引用其他值一样。"

#: src/getting-to-know/functions-and-definitions.md:99
#, fuzzy
msgid ""
"For instance, if `String` is too much to type, a shorter abbreviation `Str` "
"can be defined:"
msgstr "例如，如果 `String` 输入起来太长，可以定义一个较短的缩写 `Str`："

#: src/getting-to-know/functions-and-definitions.md:103
#, fuzzy
msgid ""
"It is then possible to use `Str` as a definition's type instead of `String`:"
msgstr "然后就可以使用 `Str` 作为定义的类型，而不是 `String`："

#: src/getting-to-know/functions-and-definitions.md:104
#, fuzzy
msgid ""
"```lean\n"
"def aStr : Str := \"This is a string.\"\n"
"```"
msgstr ""
"```lean\n"
"def aStr : Str := \"这是一个字符串。\"\n"
"```"

#: src/getting-to-know/functions-and-definitions.md:108
#, fuzzy
msgid ""
"The reason this works is that types follow the same rules as the rest of "
"Lean. Types are expressions, and in an expression, a defined name can be "
"replaced with its definition. Because `Str` has been defined to mean "
"`String`, the definition of `aStr` makes sense."
msgstr ""
"之所以可行，是因为类型遵循与 Lean 其他部分相同的规则。类型是表达式，在表达式中，已定义的名称可以用其定义替换。由于 `Str` 已被定义为 "
"`String`，因此 `aStr` 的定义是有意义的。"

#: src/getting-to-know/functions-and-definitions.md:114
#, fuzzy
msgid ""
"Experimenting with using definitions for types is made more complicated by "
"the way that Lean supports overloaded integer literals. If `Nat` is too "
"short, a longer name `NaturalNumber` can be defined:"
msgstr ""
"由于 Lean 支持重载整数文字，因此使用定义作为类型进行实验变得更加复杂。如果 `Nat` 太短，可以定义一个较长的名称 "
"`NaturalNumber`："

#: src/getting-to-know/functions-and-definitions.md:119
#, fuzzy
msgid ""
"However, using `NaturalNumber` as a definition's type instead of `Nat` does "
"not have the expected effect. In particular, the definition:"
msgstr "但是，使用 `NaturalNumber` 作为定义的类型而不是 `Nat` 并没有预期的效果。特别是，定义："

#: src/getting-to-know/functions-and-definitions.md:124
#: src/type-classes/standard-classes.md:357
#, fuzzy
msgid "results in the following error:"
msgstr "导致以下错误："

#: src/getting-to-know/functions-and-definitions.md:130
#, fuzzy
msgid ""
"This error occurs because Lean allows number literals to be _overloaded_. "
"When it makes sense to do so, natural number literals can be used for new "
"types, just as if those types were built in to the system. This is part of "
"Lean's mission of making it convenient to represent mathematics, and "
"different branches of mathematics use number notation for very different "
"purposes. The specific feature that allows this overloading does not replace"
" all defined names with their definitions before looking for overloading, "
"which is what leads to the error message above."
msgstr ""
"出现此错误是因为 Lean 允许数字文字被 _重载_。当有意义时，自然数文字可用于新类型，就像这些类型内置于系统中一样。这是 Lean "
"使得表示数学变得方便的一部分，并且数学的不同分支将数字符号用于非常不同的目的。允许这种重载的特定功能不会在查找重载之前用其定义替换所有已定义的名称，这正是导致上述错误消息的原因。"

#: src/getting-to-know/functions-and-definitions.md:135
#, fuzzy
msgid ""
"One way to work around this limitation is by providing the type `Nat` on the"
" right-hand side of the definition, causing `Nat`'s overloading rules to be "
"used for `38`:"
msgstr "解决此限制的一种方法是在定义的右侧提供类型 `Nat`，从而导致 `Nat` 的重载规则用于 `38`："

#: src/getting-to-know/functions-and-definitions.md:139
#, fuzzy
msgid ""
"The definition is still type-correct because `NaturalNumber` is the same "
"type as `Nat`—by definition!"
msgstr "定义仍然类型正确，因为 `NaturalNumber` 与 `Nat` 是同一种类型——根据定义！"

#: src/getting-to-know/functions-and-definitions.md:141
#, fuzzy
msgid ""
"Another solution is to define an overloading for `NaturalNumber` that works "
"equivalently to the one for `Nat`. This requires more advanced features of "
"Lean, however."
msgstr ""
"另一种解决方案是为 `NaturalNumber` 定义一个重载，其作用等同于 `Nat` 的重载。然而，这需要 Lean 的更多高级特性。"

#: src/getting-to-know/functions-and-definitions.md:144
#, fuzzy
msgid ""
"Finally, defining the new name for `Nat` using `abbrev` instead of `def` "
"allows overloading resolution to replace the defined name with its "
"definition. Definitions written using `abbrev` are always unfolded. For "
"instance,"
msgstr ""
"最后，使用 `abbrev` 而不是 `def` 为 `Nat` 定义新名称允许重载解析用其定义替换已定义的名称。使用 `abbrev` "
"编写的定义始终展开。例如，"

#: src/getting-to-know/functions-and-definitions.md:150
#: src/hello-world/step-by-step.md:79 src/monads/io.md:30
#, fuzzy
msgid "and"
msgstr "和"

#: src/getting-to-know/functions-and-definitions.md:154
#, fuzzy
msgid "are accepted without issue."
msgstr "被接受且没有问题。"

#: src/getting-to-know/functions-and-definitions.md:156
#, fuzzy
msgid ""
"Behind the scenes, some definitions are internally marked as being "
"unfoldable during overload resolution, while others are not. Definitions "
"that are to be unfolded are called _reducible_. Control over reducibility is"
" essential to allow Lean to scale: fully unfolding all definitions can "
"result in very large types that are slow for a machine to process and "
"difficult for users to understand. Definitions produced with `abbrev` are "
"marked as reducible."
msgstr ""
"在幕后，一些定义在重载解析期间被内部标记为可展开的，而另一些则不被标记。要展开的定义称为 _可约的_。对可约性的控制对于允许 Lean "
"扩展至关重要：完全展开所有定义可能会导致非常大的类型，这对于机器处理和用户理解来说都很困难。使用 `abbrev` 生成的定义被标记为可约的。"
