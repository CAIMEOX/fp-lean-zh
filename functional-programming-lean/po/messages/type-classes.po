#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/type-classes.md:3
#, fuzzy
msgid ""
"In many languages, the built-in datatypes get special treatment. For "
"example, in C and Java, `+` can be used to add `float`s and `int`s, but not "
"arbitrary-precision numbers from a third-party library. Similarly, numeric "
"literals can be used directly for the built-in types, but not for user-"
"defined number types. Other languages provide an _overloading_ mechanism for"
" operators, where the same operator can be given a meaning for a new type. "
"In these languages, such as C++ and C#, a wide variety of built-in operators"
" can be overloaded, and the compiler uses the type checker to select a "
"particular implementation."
msgstr ""
"在许多语言中，内置数据类型会得到特殊处理。例如，在 C 和 Java 中，`+` 可用于添加 `float` 和 "
"`int`，但不能用于第三方库中的任意精度数字。类似地，数字文字可以直接用于内置类型，但不能用于用户定义的数字类型。其他语言为运算符提供了一个 _重载_"
" 机制，其中同一个运算符可以赋予新类型一个含义。在这些语言中，例如 C++ 和 "
"C#，可以重载各种内置运算符，并且编译器使用类型检查器来选择一个特定的实现。"

#: src/type-classes.md:9
#, fuzzy
msgid ""
"In addition to numeric literals and operators, many languages allow "
"overloading of functions or methods. In C++, Java, C# and Kotlin, multiple "
"implementations of a method are allowed, with differing numbers and types of"
" arguments. The compiler uses the number of arguments and their types to "
"determine which overload was intended."
msgstr ""
"除了数字文字和运算符之外，许多语言还允许重载函数或方法。在 C++、Java、C# 和 Kotlin "
"中，允许一个方法有多个实现，并且参数的数量和类型不同。编译器使用参数的数量及其类型来确定预期的重载。"

#: src/type-classes.md:13
#, fuzzy
msgid ""
"Function and operator overloading has a key limitation: polymorphic "
"functions can't restrict their type arguments to types for which a given "
"overload exists. For example, an overloaded method might be defined for "
"strings, byte arrays, and file pointers, but there's no way to write a "
"second method that works for any of these. Instead, this second method must "
"itself be overloaded for each type that has an overload of the original "
"method, resulting in many boilerplate definitions instead of a single "
"polymorphic definition. Another consequence of this restriction is that some"
" operators (such as equality in Java) end up being defined for _every_ "
"combination of arguments, even when it is not necessarily sensible to do so."
" If programmers are not very careful, this can lead to programs that crash "
"at runtime or silently compute an incorrect result."
msgstr ""
"函数和运算符重载有一个关键限制：多态函数不能将其类型参数限制为存在给定重载的类型。例如，可以为字符串、字节数组和文件指针定义一个重载方法，但无法编写一个适用于其中任何一个的第二个方法。相反，这个第二个方法本身必须针对具有原始方法重载的每种类型进行重载，从而导致许多样板定义而不是一个多态定义。此限制的另一个后果是，一些运算符（例如"
" Java 中的相等性）最终被定义为参数的 _每个_ 组合，即使这样做不一定明智。如果程序员不够小心，这会导致在运行时崩溃或静默计算不正确结果的程序。"

#: src/type-classes.md:19
#, fuzzy
msgid ""
"Lean implements overloading using a mechanism called _type classes_, "
"pioneered in Haskell, that allows overloading of operators, functions, and "
"literals in a manner that works well with polymorphism. A type class "
"describes a collection of overloadable operations. To overload these "
"operations for a new type, an _instance_ is created that contains an "
"implementation of each operation for the new type. For example, a type class"
" named `Add` describes types that allow addition, and an instance of `Add` "
"for `Nat` provides an implementation of addition for `Nat`."
msgstr ""
"Lean 使用一种称为“类型类”的机制来实现重载，该机制最早由 Haskell "
"提出，它允许以与多态性相适应的方式重载运算符、函数和字面量。类型类描述了一组可重载的操作。要为新类型重载这些操作，需要创建一个“实例”，其中包含针对新类型实现的每项操作。例如，名为"
" `Add` 的类型类描述了允许加法的类型，而 `Nat` 的 `Add` 实例为 `Nat` 提供了加法的实现。"

#: src/type-classes.md:24
#, fuzzy
msgid ""
"The terms _class_ and _instance_ can be confusing for those who are used to "
"object-oriented languages, because they are not closely related to classes "
"and instances in object-oriented languages. However, they do share common "
"roots: in everyday language, the term \"class\" refers to a group that "
"shares some common attributes. While classes in object-oriented programming "
"certainly describe groups of objects with common attributes, the term "
"additionally refers to a specific mechanism in a programming language for "
"describing such a group. Type classes are also a means of describing types "
"that share common attributes (namely, implementations of certain "
"operations), but they don't really have anything else in common with classes"
" as found in object-oriented programming."
msgstr ""
"对于习惯了面向对象语言的人来说，“类”和“实例”这两个术语可能会令人困惑，因为它们与面向对象语言中的类和实例没有密切关系。然而，它们确实有共同的根源：在日常语言中，“类”一词指的是具有某些共同属性的群体。虽然面向对象编程中的类当然描述了具有共同属性的对象组，但该术语还指编程语言中描述此类组的特定机制。类型类也是描述具有共同属性（即某些操作的实现）的类型的工具，但它们实际上与面向对象编程中的类没有任何其他共同点。"

#: src/type-classes.md:29
#, fuzzy
msgid ""
"A Lean type class is much more analogous to a Java or C# _interface_. Both "
"type classes and interfaces describe a conceptually related set of "
"operations that are implemented for a type or collection of types. "
"Similarly, an instance of a type class is akin to the code in a Java or C# "
"class that is prescribed by the implemented interfaces, rather than an "
"instance of a Java or C# class. Unlike Java or C#'s interfaces, types can be"
" given instances for type classes that the author of the type does not have "
"access to. In this way, they are very similar to Rust traits."
msgstr ""
"Lean 类型类更类似于 Java 或 C# "
"“接口”。类型类和接口都描述了一组概念上相关的操作，这些操作针对类型或类型集合实现。类似地，类型类的实例类似于 Java 或 C# "
"类中由已实现的接口规定的代码，而不是 Java 或 C# 类的实例。与 Java 或 C# "
"的接口不同，可以为类型类提供作者无法访问的类型的实例。这样，它们与 Rust 特征非常相似。"
