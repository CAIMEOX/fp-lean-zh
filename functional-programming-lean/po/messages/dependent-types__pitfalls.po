#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/dependent-types/pitfalls.md:3
#, fuzzy
msgid ""
"The flexibility of dependent types allows more useful programs to be "
"accepted by a type checker, because the language of types is expressive "
"enough to describe variations that less-expressive type systems cannot. At "
"the same time, the ability of dependent types to express very fine-grained "
"specifications allows more buggy programs to be rejected by a type checker. "
"This power comes at a cost."
msgstr ""
"依赖类型的灵活性允许类型检查器接受更多有用的程序，因为类型的语言足够表达力来描述不那么表达力的类型系统无法描述的变化。同时，依赖类型表达非常细粒度规范的能力允许类型检查器拒绝更多有缺陷的程序。这种能力是有代价的。"

#: src/dependent-types/pitfalls.md:7
#, fuzzy
msgid ""
"The close coupling between the internals of type-returning functions such as"
" `Row` and the types that they produce is an instance of a bigger "
"difficulty: the distinction between the interface and the implementation of "
"functions begins to break down when functions are used in types. Normally, "
"all refactorings are valid as long as they don't change the type signature "
"or input-output behavior of a function. Functions can be rewritten to use "
"more efficient algorithms and data structures, bugs can be fixed, and code "
"clarity can be improved without breaking client code. When the function is "
"used in a type, however, the internals of the function's implementation "
"become part of the type, and thus part of the _interface_ to another "
"program."
msgstr ""
"类型返回函数（如 "
"`Row`）的内部结构与其产生的类型之间的紧密耦合是一个更大困难的一个实例：当函数用于类型时，函数的接口和实现之间的区别开始消失。通常，只要不更改函数的类型签名或输入输出行为，所有重构都是有效的。可以重写函数以使用更有效的算法和数据结构，可以修复错误，并且可以在不破坏客户端代码的情况下提高代码清晰度。但是，当函数用于类型时，函数实现的内部结构将成为类型的一部分，从而成为另一个程序的"
" _接口_ 的一部分。"

#: src/dependent-types/pitfalls.md:12
#, fuzzy
msgid ""
"As an example, take the following two implementations of addition on `Nat`. "
"`Nat.plusL` is recursive on its first argument:"
msgstr "以`Nat`上的加法为例，`Nat.plusL`对第一个参数进行递归："

#: src/dependent-types/pitfalls.md:19
#, fuzzy
msgid "`Nat.plusR`, on the other hand, is recursive on its second argument:"
msgstr "而`Nat.plusR`对第二个参数进行递归："

#: src/dependent-types/pitfalls.md:25
#, fuzzy
msgid ""
"Both implementations of addition are faithful to the underlying mathematical"
" concept, and they thus return the same result when given the same "
"arguments."
msgstr "这两种加法的实现都忠实于底层的数学概念，因此在给定相同参数时返回相同的结果。"

#: src/dependent-types/pitfalls.md:27
#, fuzzy
msgid ""
"However, these two implementations present quite different interfaces when "
"they are used in types. As an example, take a function that appends two "
"`Vect`s. This function should return a `Vect` whose length is the sum of the"
" length of the arguments. Because `Vect` is essentially a `List` with a more"
" informative type, it makes sense to write the function just as one would "
"for `List.append`, with pattern matching and recursion on the first "
"argument. Starting with a type signature and initial pattern match pointing "
"at placeholders yields two messages:"
msgstr ""
"然而，当在类型中使用时，这两种实现呈现出截然不同的接口。例如，考虑一个连接两个`Vect`的函数。此函数应返回一个`Vect`，其长度是参数长度的和。由于`Vect`本质上是一个具有更丰富类型的`List`，因此用模式匹配和对第一个参数进行递归来编写函数是有意义的，就像对`List.append`所做的那样。从类型签名和指向占位符的初始模式匹配开始，会产生两条消息："

#: src/dependent-types/pitfalls.md:37
#, fuzzy
msgid ""
"The first message, in the `nil` case, states that the placeholder should be "
"replaced by a `Vect` with length `plusL 0 k`:"
msgstr "在`nil`情况下，第一条消息指出占位符应替换为长度为`plusL 0 k`的`Vect`："

#: src/dependent-types/pitfalls.md:46
#, fuzzy
msgid ""
"The second message, in the `cons` case, states that the placeholder should "
"be replaced by a `Vect` with length `plusL (n✝ + 1) k`:"
msgstr "在`cons`情况下，第二条消息指出占位符应替换为长度为`plusL (n✝ + 1) k`的`Vect`："

#: src/dependent-types/pitfalls.md:57
#, fuzzy
msgid ""
"The symbol after `n`, called a _dagger_, is used to indicate names that Lean"
" has internally invented. Behind the scenes, pattern matching on the first "
"`Vect` implicitly caused the value of the first `Nat` to be refined as well,"
" because the index on the constructor `cons` is `n + 1`, with the tail of "
"the `Vect` having length `n`. Here, `n✝` represents the `Nat` that is one "
"less than the argument `n`."
msgstr ""
"`n`后面的符号称为“十字架”，用于表示Lean内部发明的新名称。在幕后，对第一个`Vect`的模式匹配隐式地导致第一个`Nat`的值也被细化，因为构造函数`cons`上的索引是`n"
" + 1`，`Vect`的尾部长度为`n`。这里，`n✝`表示比参数`n`小1的`Nat`。"

#: src/dependent-types/pitfalls.md:61
#, fuzzy
msgid "Definitional Equality"
msgstr "定义相等"

#: src/dependent-types/pitfalls.md:63
#, fuzzy
msgid ""
"In the definition of `plusL`, there is a pattern case `0, k => k`. This "
"applies in the length used in the first placeholder, so another way to write"
" the underscore's type `Vect α (Nat.plusL 0 k)` is `Vect α k`. Similarly, "
"`plusL` contains a pattern case `n + 1, k => plusN n k + 1`. This means that"
" the type of the second underscore can be equivalently written `Vect α "
"(plusL n✝ k + 1)`."
msgstr ""
"在 `plusL` 的定义中，有一个模式匹配 `0, k => k`。它适用于第一个占位符中使用的长度，因此用下划线表示的类型 `Vect α "
"(Nat.plusL 0 k)` 的另一种写法是 `Vect α k`。类似地，`plusL` 包含一个模式匹配 `n + 1, k => plusN "
"n k + 1`。这意味着第二个下划线类型的等价写法是 `Vect α (plusL n✝ k + 1)`。"

#: src/dependent-types/pitfalls.md:68
#, fuzzy
msgid ""
"To expose what is going on behind the scenes, the first step is to write the"
" `Nat` arguments explicitly, which also results in daggerless error messages"
" because the names are now written explicitly in the program:"
msgstr "为了揭示幕后发生的事情，第一步是显式地写出 `Nat` 参数，这也导致了无尖括号的错误消息，因为现在名称已在程序中显式写出："

#: src/dependent-types/pitfalls.md:92
#, fuzzy
msgid ""
"Annotating the underscores with the simplified versions of the types does "
"not introduce a type error, which means that the types as written in the "
"program are equivalent to the ones that Lean found on its own:"
msgstr "用简化版本的类型对下划线进行注释不会引入类型错误，这意味着程序中编写的类型等同于 Lean 自行找到的类型："

#: src/dependent-types/pitfalls.md:117
#, fuzzy
msgid ""
"The first case demands a `Vect α k`, and `ys` has that type. This is "
"parallel to the way that appending the empty list to any other list returns "
"that other list. Refining the definition with `ys` instead of the first "
"underscore yields a program with only one remaining underscore to be filled "
"out:"
msgstr ""
"第一个匹配需要一个 `Vect α k`，而 `ys` 具有该类型。这与将空列表附加到任何其他列表并返回该其他列表的方式类似。用 `ys` "
"代替第一个下划线来优化定义，得到一个程序，其中只有一个剩余的下划线需要填充："

#: src/dependent-types/pitfalls.md:136
#, fuzzy
msgid ""
"Something very important has happened here. In a context where Lean expected"
" a `Vect α (Nat.plusL 0 k)`, it received a `Vect α k`. However, `Nat.plusL` "
"is not an `abbrev`, so it may seem like it shouldn't be running during type "
"checking. Something else is happening."
msgstr ""
"这里发生了一件非常重要的事情。在 Lean 期望 `Vect α (Nat.plusL 0 k)` 的上下文中，它接收到了 `Vect α "
"k`。但是，`Nat.plusL` 不是 `abbrev`，因此在类型检查期间它似乎不应该运行。发生了别的事情。"

#: src/dependent-types/pitfalls.md:141
#, fuzzy
msgid ""
"The key to understanding what's going on is that Lean doesn't just expand "
"`abbrev`s while type checking. It can also perform computation while "
"checking whether two types are equivalent to one another, such that any "
"expression of one type can be used in a context that expects the other type."
" This property is called _definitional equality_, and it is subtle."
msgstr ""
"理解正在发生的事情的关键在于，Lean 不仅在类型检查时扩展 "
"`abbrev`。它还可以在检查两个类型是否相等时执行计算，以便一个类型的任何表达式都可以在期望另一个类型的上下文中使用。此属性称为 "
"_定义相等_，它很微妙。"

#: src/dependent-types/pitfalls.md:145
#, fuzzy
msgid ""
"Certainly, two types that are written identically are considered to be "
"definitionally equal—`Nat` and `Nat` or `List String` and `List String` "
"should be considered equal. Any two concrete types built from different "
"datatypes are not equal, so `List Nat` is not equal to `Int`. Additionally, "
"types that differ only by renaming internal names are equal, so `(n : Nat) →"
" Vect String n` is the same as `(k : Nat) → Vect String k`. Because types "
"can contain ordinary data, definitional equality must also describe when "
"data are equal. Uses of the same constructors are equal, so `0` equals `0` "
"and `[5, 3, 1]` equals `[5, 3, 1]`."
msgstr ""
"当然，两个书写形式相同的类型被认为是定义相等的——`Nat` 和 `Nat` 或 `List String` 和 `List String` 应该被认为是相等的。任何两个由不同数据类型构建的具体类型是不相等的，所以 `List Nat` 不等于 `Int`。此外，仅通过重命名内部名称而不同的类型是相等的，所以 `(n : Nat) → Vect String n` 与 `(k : Nat) → Vect String k` 相同。由于类型可以包含普通数据，因此定义相等还必须描述何时数据相等。相同构造器的使用是相等的，所以 `0` 等于 `0`，`[5, 3, 1]` 等于 `[5, 3, 1]`。\n"
"\n"
"然而，类型包含的不仅仅是函数箭头、数据类型和构造器。它们还包含 _变量_ 和 _函数_。变量的定义相等相对简单：每个变量仅等于它自身，所以 `(n k : Nat) → Vect Int n` 与 `(n k : Nat) → Vect Int k` 在定义上不相等。另一方面，函数则更复杂。虽然数学认为如果两个函数具有相同的输入输出行为，则它们相等，但没有有效的算法来检查这一点，而定义相等性的全部意义在于让 Lean 检查两个类型是否可互换。相反，Lean 认为函数在定义上相等，当它们都是具有定义上相等的主体的 `fun` 表达式时。换句话说，两个函数必须使用 _相同的算法_ 来调用 _相同的帮助器_，才能被认为在定义上相等。这通常不是很有帮助，因此函数的定义相等主要用于在两种类型中出现完全相同的已定义函数时。"

#: src/dependent-types/pitfalls.md:151
#, fuzzy
msgid ""
"Types contain more than just function arrows, datatypes, and constructors, "
"however. They also contain _variables_ and _functions_. Definitional "
"equality of variables is relatively simple: each variable is equal only to "
"itself, so `(n k : Nat) → Vect Int n` is not definitionally equal to `(n k :"
" Nat) → Vect Int k`. Functions, on the other hand, are more complicated. "
"While mathematics considers two functions to be equal if they have identical"
" input-output behavior, there is no efficient algorithm to check that, and "
"the whole point of definitional equality is for Lean to check whether two "
"types are interchangeable. Instead, Lean considers functions to be "
"definitionally equal either when they are both `fun`\\-expressions with "
"definitionally equal bodies. In other words, two functions must use _the "
"same algorithm_ that calls _the same helpers_ to be considered "
"definitionally equal. This is not typically very helpful, so definitional "
"equality of functions is mostly used when the exact same defined function "
"occurs in two types."
msgstr "?"

#: src/dependent-types/pitfalls.md:160
#, fuzzy
msgid ""
"When functions are _called_ in a type, checking definitional equality may "
"involve reducing the function call. The type `Vect String (1 + 4)` is "
"definitionally equal to the type `Vect String (3 + 2)` because `1 + 4` is "
"definitionally equal to `3 + 2`. To check their equality, both are reduced "
"to `5`, and then the constructor rule can be used five times. Definitional "
"equality of functions applied to data can be checked first by seeing if "
"they're already the same—there's no need to reduce `[\"a\", \"b\"] ++ "
"[\"c\"]` to check that it's equal to `[\"a\", \"b\"] ++ [\"c\"]`, after all."
" If not, the function is called and replaced with its value, and the value "
"can then be checked."
msgstr ""
"当函数在类型中被调用时，检查定义相等可能涉及到化简函数调用。类型 `Vect String (1 + 4)` 与类型 `Vect String (3 +"
" 2)` 定义相等，因为 `1 + 4` 与 `3 + 2` 定义相等。为了检查它们的相等性，两者都被化简为 "
"`5`，然后构造器规则可以被使用五次。应用于数据的函数的定义相等性可以通过首先查看它们是否已经相同来检查——毕竟，没有必要将 `[\"a\", "
"\"b\"] ++ [\"c\"]` 化简为 `[\"a\", \"b\"] ++ [\"c\"]` "
"来检查它是否相等。如果不是，则调用该函数并用它的值替换它，然后可以检查该值。"

#: src/dependent-types/pitfalls.md:166
#, fuzzy
msgid ""
"Not all function arguments are concrete data. For example, types may contain"
" `Nat`s that are not built from the `zero` and `succ` constructors. In the "
"type `(n : Nat) → Vect String n`, the variable `n` is a `Nat`, but it is "
"impossible to know _which_ `Nat` it is before the function is called. "
"Indeed, the function may be called first with `0`, and then later with `17`,"
" and then again with `33`. As seen in the definition of `appendL`, variables"
" with type `Nat` may also be passed to functions such as `plusL`. Indeed, "
"the type `(n : Nat) → Vect String n` is definitionally equal to the type `(n"
" : Nat) → Vect String (Nat.plusL 0 n)`."
msgstr ""
"并非所有函数参数都是具体数据。例如，类型可能包含不是由 `zero` 和 `succ` 构造器构建的 `Nat`。在类型 `(n : Nat) → "
"Vect String n` 中，变量 `n` 是一个 `Nat`，但在调用函数之前不可能知道它是什么 `Nat`。事实上，该函数可能首先用 `0` "
"调用，然后用 `17` 调用，然后再次用 `33` 调用。如 `appendL` 的定义所示，类型为 `Nat` 的变量也可以传递给诸如 `plusL`"
" 的函数。事实上，类型 `(n : Nat) → Vect String n` 与类型 `(n : Nat) → Vect String "
"(Nat.plusL 0 n)` 定义相等。"

#: src/dependent-types/pitfalls.md:173
#, fuzzy
msgid ""
"The reason that `n` and `Nat.plusL 0 n` are definitionally equal is that "
"`plusL`'s pattern match examines its _first_ argument. This is problematic: "
"`(n : Nat) → Vect String n` is _not_ definitionally equal to `(n : Nat) → "
"Vect String (Nat.plusL n 0)`, even though zero should be both a left and a "
"right identity of addition. This happens because pattern matching gets stuck"
" when it encounters variables. Until the actual value of `n` becomes known, "
"there is no way to know which case of `Nat.plusL n 0` should be selected."
msgstr ""
"`n` 和 `Nat.plusL 0 n` 定义相等的原因是 `plusL` 的模式匹配检查它的第一个参数。这是有问题的：`(n : Nat) → "
"Vect String n` 与 `(n : Nat) → Vect String (Nat.plusL n 0)` "
"并不定义相等，即使零应该是加法的左单位元和右单位元。发生这种情况是因为当遇到变量时，模式匹配会卡住。在 `n` "
"的实际值变得已知之前，没有办法知道应该选择 `Nat.plusL n 0` 的哪种情况。"

#: src/dependent-types/pitfalls.md:178
#, fuzzy
msgid ""
"The same issue appears with the `Row` function in the query example. The "
"type `Row (c :: cs)` does not reduce to any datatype because the definition "
"of `Row` has separate cases for singleton lists and lists with at least two "
"entries. In other words, it gets stuck when trying to match the variable "
"`cs` against concrete `List` constructors. This is why almost every function"
" that takes apart or constructs a `Row` needs to match the same three cases "
"as `Row` itself: getting it unstuck reveals concrete types that can be used "
"for either pattern matching or constructors."
msgstr ""
"`Row` 函数在查询示例中也出现了同样的问题。类型 `Row (c :: cs)` 不会缩减为任何数据类型，因为 `Row` "
"的定义对单例列表和至少有两个条目的列表有单独的情况。换句话说，它在尝试将变量 `cs` 与具体的 `List` "
"构造函数进行匹配时会卡住。这就是为什么几乎每个分解或构造 `Row` 的函数都需要与 `Row` "
"本身匹配相同的三种情况：解除其卡住状态会显示可用于模式匹配或构造函数的具体类型。"

#: src/dependent-types/pitfalls.md:183
#, fuzzy
msgid ""
"The missing case in `appendL` requires a `Vect α (Nat.plusL n k + 1)`. The "
"`+ 1` in the index suggests that the next step is to use `Vect.cons`:"
msgstr ""
"`appendL` 中缺少的情况需要一个 `Vect α (Nat.plusL n k + 1)`。索引中的 `+ 1` 表明下一步是使用 "
"`Vect.cons`："

#: src/dependent-types/pitfalls.md:200
#, fuzzy
msgid ""
"A recursive call to `appendL` can construct a `Vect` with the desired "
"length:"
msgstr "对 `appendL` 的递归调用可以构造一个具有所需长度的 `Vect`："

#: src/dependent-types/pitfalls.md:206
#, fuzzy
msgid ""
"Now that the program is finished, removing the explicit matching on `n` and "
"`k` makes it easier to read and easier to call the function:"
msgstr "现在程序已完成，删除对 `n` 和 `k` 的显式匹配使其更易于阅读和调用函数："

#: src/dependent-types/pitfalls.md:213
#, fuzzy
msgid ""
"Comparing types using definitional equality means that everything involved "
"in definitional equality, including the internals of function definitions, "
"becomes part of the _interface_ of programs that use dependent types and "
"indexed families. Exposing the internals of a function in a type means that "
"refactoring the exposed program may cause programs that use it to no longer "
"type check. In particular, the fact that `plusL` is used in the type of "
"`appendL` means that the definition of `plusL` cannot be replaced by the "
"otherwise-equivalent `plusR`."
msgstr ""
"使用定义相等性比较类型意味着涉及定义相等性的所有内容（包括函数定义的内部）都成为使用依赖类型和索引族的程序的 _接口_ "
"的一部分。在类型中公开函数的内部意味着重构公开的程序可能会导致使用它的程序不再进行类型检查。特别是，`plusL` 用于 `appendL` "
"的类型这一事实意味着 `plusL` 的定义不能被其他等效的 `plusR` 替换。"

#: src/dependent-types/pitfalls.md:217
#, fuzzy
msgid "Getting Stuck on Addition"
msgstr "卡在加法上"

#: src/dependent-types/pitfalls.md:219
#, fuzzy
msgid ""
"What happens if append is defined with `plusR` instead? Beginning in the "
"same way, with explicit lengths and placeholder underscores in each case, "
"reveals the following useful error messages:"
msgstr "如果使用 `plusR` 定义 `append` 会发生什么？同样以显式长度和占位符下划线开始，会显示以下有用的错误消息："

#: src/dependent-types/pitfalls.md:244
#, fuzzy
msgid ""
"However, attempting to place a `Vect α k` type annotation around the first "
"placeholder results in an type mismatch error:"
msgstr "然而，尝试在第一个占位符周围放置 `Vect α k` 类型注释会导致类型不匹配错误："

#: src/dependent-types/pitfalls.md:258
#, fuzzy
msgid ""
"This error is pointing out that `plusR 0 k` and `k` are _not_ definitionally"
" equal."
msgstr "此错误指出 `plusR 0 k` 和 `k` _不是_ 定义相等的。"

#: src/dependent-types/pitfalls.md:260
#, fuzzy
msgid "This is because `plusR` has the following definition:"
msgstr "这是因为 `plusR` 具有以下定义："

#: src/dependent-types/pitfalls.md:266
#, fuzzy
msgid ""
"Its pattern matching occurs on the _second_ argument, not the first "
"argument, which means that the presence of the variable `k` in that position"
" prevents it from reducing. `Nat.add` in Lean's standard library is "
"equivalent to `plusR`, not `plusL`, so attempting to use it in this "
"definition results in precisely the same difficulties:"
msgstr ""
"它的模式匹配发生在 _第二个_ 参数上，而不是第一个参数，这意味着变量 `k` 在该位置的存在阻止了它的化简。Lean 标准库中的 `Nat.add` "
"等效于 `plusR`，而不是 `plusL`，因此尝试在此定义中使用它会导致完全相同的问题："

#: src/dependent-types/pitfalls.md:282
#, fuzzy
msgid ""
"Addition is getting _stuck_ on the variables. Getting it unstuck requires "
"[propositional equality](../type-classes/standard-classes.md#equality-and-"
"ordering)."
msgstr ""
"加法在变量上 _卡住了_。要解除卡住，需要 [命题相等](../type-classes/standard-classes.md#equality-"
"and-ordering)。"

#: src/dependent-types/pitfalls.md:285
#, fuzzy
msgid "Propositional Equality"
msgstr "命题相等"

#: src/dependent-types/pitfalls.md:287
#, fuzzy
msgid ""
"Propositional equality is the mathematical statement that two expressions "
"are equal. While definitional equality is a kind of ambient fact that Lean "
"automatically checks when required, statements of propositional equality "
"require explicit proofs. Once an equality proposition has been proved, it "
"can be used in a program to modify a type, replacing one side of the "
"equality with the other, which can unstick the type checker."
msgstr ""
"命题相等是两个表达式相等的数学陈述。虽然定义相等是一种环境事实，Lean "
"在需要时会自动检查，但命题相等陈述需要明确的证明。一旦证明了一个相等命题，就可以在程序中使用它来修改类型，用相等的一侧替换另一侧，这可以解除类型检查器的卡住。"

#: src/dependent-types/pitfalls.md:291
#, fuzzy
msgid ""
"The reason why definitional equality is so limited is to enable it to be "
"checked by an algorithm. Propositional equality is much richer, but the "
"computer cannot in general check whether two expressions are propositionally"
" equal, though it can verify that a purported proof is in fact a proof. The "
"split between definitional and propositional equality represents a division "
"of labor between humans and machines: the most boring equalities are checked"
" automatically as part of definitional equality, freeing the human mind to "
"work on the interesting problems available in propositional equality. "
"Similarly, definitional equality is invoked automatically by the type "
"checker, while propositional equality must be specifically appealed to."
msgstr ""
"定义相等之所以如此有限，是为了使其能够通过算法进行检查。命题相等要丰富得多，但计算机通常无法检查两个表达式是否命题相等，尽管它可以验证一个所谓的证明实际上是一个证明。定义相等和命题相等之间的分歧代表了人机之间的分工：最无聊的相等作为定义相等的一部分自动检查，从而使人的思想可以解决命题相等中出现的有意思的问题。类似地，定义相等由类型检查器自动调用，而命题相等必须被专门调用。"

#: src/dependent-types/pitfalls.md:297
#, fuzzy
msgid ""
"In [Propositions, Proofs, and Indexing](../props-proofs-indexing.md), some "
"equality statements are proved using `simp`. All of these equality "
"statements are ones in which the propositional equality is in fact already a"
" definitional equality. Typically, statements of propositional equality are "
"proved by first getting them into a form where they are either definitional "
"or close enough to existing proved equalities, and then using tools like "
"`simp` to take care of the simplified cases. The `simp` tactic is quite "
"powerful: behind the scenes, it uses a number of fast, automated tools to "
"construct a proof. A simpler tactic called `rfl` specifically uses "
"definitional equality to prove propositional equality. The name `rfl` is "
"short for _reflexivity_, which is the property of equality that states that "
"everything equals itself."
msgstr ""
"在 [命题、证明和索引](../props-proofs-indexing.md) 中，一些等式语句使用 `simp` "
"证明。所有这些等式语句都是命题等式实际上已经是定义等式的情况。通常，命题等式的陈述首先将它们转换为定义形式或接近于现有已证明等式，然后使用 `simp`"
" 等工具来处理简化情况。`simp` 战术非常强大：在幕后，它使用许多快速、自动化的工具来构建证明。一个称为 `rfl` "
"的更简单的战术专门使用定义等式来证明命题等式。`rfl` 名称是 _自反性_ 的缩写，这是等式的属性，它指出所有事物都等于自身。"

#: src/dependent-types/pitfalls.md:304
#, fuzzy
msgid ""
"Unsticking `appendR` requires a proof that `k = Nat.plusR 0 k`, which is not"
" a definitional equality because `plusR` is stuck on the variable in its "
"second argument. To get it to compute, the `k` must become a concrete "
"constructor. This is a job for pattern matching."
msgstr ""
"取消粘贴 `appendR` 需要证明 `k = Nat.plusR 0 k`，这不是定义等式，因为 `plusR` "
"粘贴在第二个参数中的变量上。为了计算它，`k` 必须成为一个具体构造器。这是模式匹配的工作。"

#: src/dependent-types/pitfalls.md:308
#, fuzzy
msgid ""
"In particular, because `k` could be _any_ `Nat`, this task requires a "
"function that can return evidence that `k = Nat.plusR 0 k` for _any_ `k` "
"whatsoever. This should be a function that returns a proof of equality, with"
" type `(k : Nat) → k = Nat.plusR 0 k`. Getting it started with initial "
"patterns and placeholders yields the following messages:"
msgstr ""
"特别是，因为 `k` 可以是 _任何_ `Nat`，所以此任务需要一个函数，该函数可以返回证据，证明 `k = Nat.plusR 0 k` 适用于 "
"_任何_ `k`。这应该是一个返回等式证明的函数，类型为 `(k : Nat) → k = Nat.plusR 0 "
"k`。使用初始模式和占位符开始它会产生以下消息："

#: src/dependent-types/pitfalls.md:327
#, fuzzy
msgid ""
"Having refined `k` to `0` via pattern matching, the first placeholder stands"
" for evidence of a statement that does hold definitionally. The `rfl` tactic"
" takes care of it, leaving only the second placeholder:"
msgstr "通过模式匹配将 `k` 细化为 `0`，第一个占位符代表对定义上成立的语句的证据。`rfl` 战术处理它，只留下第二个占位符："

#: src/dependent-types/pitfalls.md:335
#, fuzzy
msgid ""
"The second placeholder is a bit trickier. The expression `Nat.plusR 0 k + 1`"
" is definitionally equal to `Nat.plusR 0 (k + 1)`. This means that the goal "
"could also be written `k + 1 = Nat.plusR 0 k + 1`:"
msgstr ""
"第二个占位符有点棘手。表达式 `Nat.plusR 0 k + 1` 在定义上等于 `Nat.plusR 0 (k + 1)`。这意味着目标也可以写成 "
"`k + 1 = Nat.plusR 0 k + 1`："

#: src/dependent-types/pitfalls.md:350
#, fuzzy
msgid ""
"Underneath the `+ 1` on each side of the equality statement is another "
"instance of what the function itself returns. In other words, a recursive "
"call on `k` would return evidence that `k = Nat.plusR 0 k`. Equality "
"wouldn't be equality if it didn't apply to function arguments.  In other "
"words, if `x = y`, then `f x = f y`. The standard library contains a "
"function `congrArg` that takes a function and an equality proof and returns "
"a new proof where the function has been applied to both sides of the "
"equality. In this case, the function is `(· + 1)`:"
msgstr ""
"等式语句两边的 `+ 1` 下面是函数本身返回的另一个实例。换句话说，对 `k` 的递归调用将返回 `k = Nat.plusR 0 k` "
"的证据。如果不适用于函数参数，等式就不再是等式。换句话说，如果 `x = y`，则 `f x = f y`。标准库包含一个函数 "
"`congrArg`，它接受一个函数和一个相等证明，并返回一个新的证明，其中函数已应用于等式的双方。在这种情况下，函数是 `(· + 1)`："

#: src/dependent-types/pitfalls.md:363
#, fuzzy
msgid ""
"Propositional equalities can be deployed in a program using the rightward "
"triangle operator `▸`. Given an equality proof as its first argument and "
"some other expression as its second, this operator replaces instances of the"
" left side of the equality with the right side of the equality in the second"
" argument's type. In other words, the following definition contains no type "
"errors:"
msgstr ""
"命题等式可以使用右三角形运算符 `▸` "
"在程序中部署。给定一个相等证明作为其第一个参数和一些其他表达式作为其第二个参数，此运算符将第二个参数类型中相等性的左侧实例替换为相等性的右侧。换句话说，以下定义不包含类型错误："

#: src/dependent-types/pitfalls.md:371
#, fuzzy
msgid "The first placeholder has the expected type:"
msgstr "第一个占位符具有预期的类型："

#: src/dependent-types/pitfalls.md:380
#, fuzzy
msgid "It can now be filled in with `ys`:"
msgstr "现在可以用 `ys` 填充它："

#: src/dependent-types/pitfalls.md:387
#, fuzzy
msgid ""
"Filling in the remaining placeholder requires unsticking another instance of"
" addition:"
msgstr "填充剩余的占位符需要取消另一个加法实例："

#: src/dependent-types/pitfalls.md:398
#, fuzzy
msgid ""
"Here, the statement to be proved is that `Nat.plusR (n + 1) k = Nat.plusR n "
"k + 1`, which can be used with `▸` to draw the `+ 1` out to the top of the "
"expression so that it matches the index of `cons`."
msgstr ""
"这里，要证明的陈述是 `Nat.plusR (n + 1) k = Nat.plusR n k + 1`，它可以与 `▸` 一起使用，将 `+ 1` "
"绘制到表达式的顶部，以便它与 `cons` 的索引匹配。"

#: src/dependent-types/pitfalls.md:400
#, fuzzy
msgid ""
"The proof is a recursive function that pattern matches on the second "
"argument to `plusR`, namely `k`. This is because `plusR` itself pattern "
"matches on its second argument, so the proof can \"unstick\" it through "
"pattern matching, exposing the computational behavior. The skeleton of the "
"proof is very similar to that of `plusR_zero_left`:"
msgstr ""
"证明是一个递归函数，它对 `plusR` 的第二个参数（即 `k`）进行模式匹配。这是因为 `plusR` "
"本身对其第二个参数进行模式匹配，因此证明可以通过模式匹配“取消”它，从而暴露计算行为。证明的骨架与 `plusR_zero_left` 非常相似："

#: src/dependent-types/pitfalls.md:409
#, fuzzy
msgid ""
"The remaining case's type is definitionally equal to `Nat.plusR (n + 1) k + "
"1 = Nat.plusR n (k + 1) + 1`, so it can be solved with `congrArg`, just as "
"in `plusR_zero_left`:"
msgstr ""
"剩余情况的类型定义上等于 `Nat.plusR (n + 1) k + 1 = Nat.plusR n (k + 1) + 1`，因此可以使用 "
"`congrArg` 来解决，就像在 `plusR_zero_left` 中一样："

#: src/dependent-types/pitfalls.md:416
#, fuzzy
msgid "This results in a finished proof:"
msgstr "这导致了一个完成的证明："

#: src/dependent-types/pitfalls.md:423
#, fuzzy
msgid ""
"The finished proof can be used to unstick the second case in `appendR`:"
msgstr "完成的证明可以用来取消 `appendR` 中的第二个情况："

#: src/dependent-types/pitfalls.md:429
#, fuzzy
msgid ""
"When making the length arguments to `appendR` implicit again, they are no "
"longer explicitly named to be appealed to in the proofs. However, Lean's "
"type checker has enough information to fill them in automatically behind the"
" scenes, because no other values would allow the types to match:"
msgstr ""
"当再次使 `appendR` 的长度参数变为隐式时，它们不再被显式命名，以便在证明中被调用。然而，Lean "
"的类型检查器有足够的信息在幕后自动填充它们，因为没有其他值允许类型匹配："

#: src/dependent-types/pitfalls.md:437
#, fuzzy
msgid "Pros and Cons"
msgstr "优缺点"

#: src/dependent-types/pitfalls.md:439
#, fuzzy
msgid ""
"Indexed families have an important property: pattern matching on them "
"affects definitional equality. For example, in the `nil` case in a `match` "
"expression on a `Vect`, the length simply _becomes_ `0`. Definitional "
"equality can be very convenient, because it is always active and does not "
"need to be invoked explicitly."
msgstr ""
"索引族有一个重要的属性：模式匹配会影响定义上的相等性。例如，在 `Vect` 上的 `match` 表达式的 `nil` "
"情况下，长度简单地“变成”`0`。定义上的相等性非常方便，因为它总是处于活动状态，不需要显式调用。"

#: src/dependent-types/pitfalls.md:443
#, fuzzy
msgid ""
"However, the use of definitional equality with dependent types and pattern "
"matching has serious software engineering drawbacks. First off, functions "
"must be written especially to be used in types, and functions that are "
"convenient to use in types may not use the most efficient algorithms. Once a"
" function has been exposed through using it in a type, its implementation "
"has become part of the interface, leading to difficulties in future "
"refactoring. Secondly, definitional equality can be slow. When asked to "
"check whether two expressions are definitionally equal, Lean may need to run"
" large amounts of code if the functions in question are complicated and have"
" many layers of abstraction. Third, error messages that result from failures"
" of definitional equality are not always very easy to understand, because "
"they may be phrased in terms of the internals of functions. It is not always"
" easy to understand the provenance of the expressions in the error messages."
" Finally, encoding non-trivial invariants in a collection of indexed "
"families and dependently-typed functions can often be brittle. It is often "
"necessary to change early definitions in a system when the exposed reduction"
" behavior of functions proves to not provide convenient definitional "
"equalities. The alternative is to litter the program with appeals to "
"equality proofs, but these can become quite unwieldy."
msgstr ""
"然而，在依赖类型和模式匹配中使用定义上的相等性有严重的软件工程缺点。首先，必须专门编写函数以用于类型中，并且在类型中方便使用的函数可能不会使用最有效的算法。一旦通过在类型中使用函数公开函数，其实现就成为接口的一部分，导致未来重构的困难。其次，定义上的相等性可能很慢。当要求检查两个表达式是否在定义上相等时，如果所讨论的函数很复杂并且具有多层抽象，Lean"
" "
"可能需要运行大量的代码。第三，由定义上的相等性失败导致的错误消息并不总是很容易理解，因为它们可能用函数内部的术语表述。理解错误消息中表达式的来源并不总是容易的。最后，在索引族和依赖类型函数的集合中对非平凡的不变式进行编码通常是脆弱的。当函数的公开归约行为被证明不能提供方便的定义上的相等性时，通常需要更改系统中的早期定义。另一种方法是在程序中散布对相等性证明的调用，但这些调用可能会变得相当笨拙。"

#: src/dependent-types/pitfalls.md:454
#, fuzzy
msgid ""
"In idiomatic Lean code, indexed datatypes are not used very often. Instead, "
"subtypes and explicit propositions are typically used to enforce important "
"invariants. This approach involves many explicit proofs, and very few "
"appeals to definitional equality. As befits an interactive theorem prover, "
"Lean has been designed to make explicit proofs convenient. Generally "
"speaking, this approach should be preferred in most cases."
msgstr ""
"在惯用的 Lean "
"代码中，很少使用索引数据类型。相反，通常使用子类型和显式命题来强制执行重要的不变量。这种方法涉及许多显式证明，很少诉诸定义相等。正如交互式定理证明器所应有的，Lean"
" 被设计为使显式证明变得方便。一般来说，在大多数情况下都应该优先采用这种方法。"

#: src/dependent-types/pitfalls.md:460
#, fuzzy
msgid ""
"However, understanding indexed families of datatypes is important. Recursive"
" functions such as `plusR_zero_left` and `plusR_succ_left` are in fact "
"_proofs by mathematical induction_. The base case of the recursion "
"corresponds to the base case in induction, and the recursive call represents"
" an appeal to the induction hypothesis. More generally, new propositions in "
"Lean are often defined as inductive types of evidence, and these inductive "
"types usually have indices. The process of proving theorems is in fact "
"constructing expressions with these types behind the scenes, in a process "
"not unlike the proofs in this section. Also, indexed datatypes are sometimes"
" exactly the right tool for the job. Fluency in their use is an important "
"part of knowing when to use them."
msgstr ""
"然而，理解数据类型的索引族非常重要。诸如 `plusR_zero_left` 和 `plusR_succ_left` 之类的递归函数实际上是 "
"_数学归纳法证明_。递归的基本情况对应于归纳法中的基本情况，递归调用表示对归纳假设的诉求。更一般地说，Lean "
"中的新命题通常被定义为归纳证据类型，这些归纳类型通常有索引。证明定理的过程实际上是在幕后构造具有这些类型的表达式，这个过程与本节中的证明非常相似。此外，索引数据类型有时正是这项工作的正确工具。熟练使用它们是知道何时使用它们的重要组成部分。"

#: src/dependent-types/pitfalls.md:472
#, fuzzy
msgid ""
"Using a recursive function in the style of `plusR_succ_left`, prove that for"
" all `Nat`s `n` and `k`, `n.plusR k = n + k`."
msgstr ""
"使用 `plusR_succ_left` 样式的递归函数，证明对于所有 `Nat` 的 `n` 和 `k`，`n.plusR k = n + k`。"

#: src/dependent-types/pitfalls.md:473
#, fuzzy
msgid ""
"Write a function on `Vect` for which `plusR` is more natural than `plusL`, "
"where `plusL` would require proofs to be used in the definition."
msgstr "为 `Vect` 编写一个函数，其中 `plusR` 比 `plusL` 更自然，其中 `plusL` 需要在定义中使用证明。"
