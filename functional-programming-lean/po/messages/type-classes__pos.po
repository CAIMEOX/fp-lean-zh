#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/type-classes/pos.md:3
#, fuzzy
msgid ""
"In some applications, only positive numbers make sense. For example, "
"compilers and interpreters typically use one-indexed line and column numbers"
" for source positions, and a datatype that represents only non-empty lists "
"will never report a length of zero. Rather than relying on natural numbers, "
"and littering the code with assertions that the number is not zero, it can "
"be useful to design a datatype that represents only positive numbers."
msgstr ""
"在某些应用中，只有正数才有意义。例如，编译器和解释器通常使用从 1 "
"开始的行号和列号表示源代码位置，而表示非空列表的数据类型永远不会报告长度为零。与其依赖自然数并用断言来充斥代码以表明该数字不为零，不如设计一个仅表示正数的数据类型。"

#: src/type-classes/pos.md:7
#, fuzzy
msgid ""
"One way to represent positive numbers is very similar to `Nat`, except with "
"`one` as the base case instead of `zero`:"
msgstr "表示正数的一种方法与 `Nat` 非常相似，只是以 `one` 作为基本情况，而不是 `zero`："

#: src/type-classes/pos.md:13
#, fuzzy
msgid ""
"This datatype represents exactly the intended set of values, but it is not "
"very convenient to use. For example, numeric literals are rejected:"
msgstr "此数据类型准确表示预期值集，但使用起来不太方便。例如，数字字面量会被拒绝："

#: src/type-classes/pos.md:22
#, fuzzy
msgid "Instead, the constructors must be used directly:"
msgstr "相反，必须直接使用构造器："

#: src/type-classes/pos.md:28
#, fuzzy
msgid "Similarly, addition and multiplication are not easy to use:"
msgstr "同样，加法和乘法也不容易使用："

#: src/type-classes/pos.md:44
#, fuzzy
msgid ""
"Each of these error messages begins with `failed to synthesize instance`. "
"This indicates that the error is due to an overloaded operation that has not"
" been implemented, and it describes the type class that must be implemented."
msgstr "每个错误消息都以“未能合成实例”开头。这表明错误是由于未实现的重载操作引起的，并且描述了必须实现的类型类。"

#: src/type-classes/pos.md:47
#, fuzzy
msgid "Classes and Instances"
msgstr "类和实例"

#: src/type-classes/pos.md:49
#, fuzzy
msgid ""
"A type class consists of a name, some parameters, and a collection of "
"_methods_. The parameters describe the types for which overloadable "
"operations are being defined, and the methods are the names and type "
"signatures of the overloadable operations. Once again, there is a "
"terminology clash with object-oriented languages. In object-oriented "
"programming, a method is essentially a function that is connected to a "
"particular object in memory, with special access to the object's private "
"state. Objects are interacted with via their methods. In Lean, the term "
"\"method\" refers to an operation that has been declared to be overloadable,"
" with no special connection to objects or values or private fields."
msgstr ""
"类型类由名称、一些参数和一组_方法_组成。参数描述了为其定义可重载操作的类型，而方法是可重载操作的名称和类型签名。同样，这里与面向对象语言存在术语冲突。在面向对象编程中，方法本质上是一个连接到内存中特定对象的函数，可以特别访问对象的私有状态。通过方法与对象进行交互。在"
" Lean 中，“方法”一词是指已声明为可重载的操作，与对象、值或私有字段没有特殊连接。"

#: src/type-classes/pos.md:56
#, fuzzy
msgid ""
"One way to overload addition is to define a type class named `Plus`, with an"
" addition method named `plus`. Once an instance of `Plus` for `Nat` has been"
" defined, it becomes possible to add two `Nat`s using `Plus.plus`:"
msgstr ""
"一种重载加法的方法是定义一个名为 `Plus` 的类型类，其中包含一个名为 `plus` 的加法方法。一旦为 `Nat` 定义了 `Plus` "
"的实例，就可以使用 `Plus.plus` 来添加两个 `Nat`："

#: src/type-classes/pos.md:64
#, fuzzy
msgid ""
"Adding more instances allows `Plus.plus` to take more types of arguments."
msgstr "添加更多实例允许 `Plus.plus` 接受更多类型的参数。"

#: src/type-classes/pos.md:66
#, fuzzy
msgid ""
"In the following type class declaration, `Plus` is the name of the class, `α"
" : Type` is the only argument, and `plus : α → α → α` is the only method:"
msgstr "在以下类型类声明中，`Plus` 是类的名称，`α : Type` 是唯一参数，`plus : α → α → α` 是唯一方法："

#: src/type-classes/pos.md:71
#, fuzzy
msgid ""
"This declaration says that there is a type class `Plus` that overloads "
"operations with respect to a type `α`. In particular, there is one "
"overloaded operation called `plus` that takes two `α`s and returns an `α`."
msgstr ""
"此声明表示存在一个类型类 `Plus`，它针对类型 `α` 重载运算。特别是，有一个名为 `plus` 的重载运算，它接受两个 `α` 并返回一个 "
"`α`。"

#: src/type-classes/pos.md:74
#, fuzzy
msgid ""
"Type classes are first class, just as types are first class. In particular, "
"a type class is another kind of type. The type of `Plus` is `Type → Type`, "
"because it takes a type as an argument (`α`) and results in a new type that "
"describes the overloading of `Plus`'s operation for `α`."
msgstr ""
"类型类是一等公民，就像类型是一等公民一样。特别是，类型类是另一种类型的类型。`Plus` 的类型是 `Type → "
"Type`，因为它接受一个类型作为参数（`α`）并生成一个新类型，该类型描述 `Plus` 的运算针对 `α` 的重载。"

#: src/type-classes/pos.md:79
#, fuzzy
msgid "To overload `plus` for a particular type, write an instance:"
msgstr "要为特定类型重载 `plus`，请编写一个实例："

#: src/type-classes/pos.md:84
#, fuzzy
msgid ""
"The colon after `instance` indicates that `Plus Nat` is indeed a type. Each "
"method of class `Plus` should be assigned a value using `:=`. In this case, "
"there is only one method: `plus`."
msgstr ""
"`instance` 后面的冒号表示 `Plus Nat` 确实是一个类型。`Plus` 类的每个方法都应使用 `:=` "
"赋值。在这种情况下，只有一个方法：`plus`。"

#: src/type-classes/pos.md:88
#, fuzzy
msgid ""
"By default, type class methods are defined in a namespace with the same name"
" as the type class. It can be convenient to `open` the namespace so that "
"users don't need to type the name of the class first. Parentheses in an "
"`open` command indicate that only the indicated names from the namespace are"
" to be made accessible:"
msgstr ""
"默认情况下，类型类方法在与类型类同名的命名空间中定义。`open` 命名空间很方便，这样用户就不必先键入类的名称。`open` "
"命令中的括号表示仅使命名空间中指示的名称可访问："

#: src/type-classes/pos.md:100
#, fuzzy
msgid ""
"Defining an addition function for `Pos` and an instance of `Plus Pos` allows"
" `plus` to be used to add both `Pos` and `Nat` values:"
msgstr "为 `Pos` 定义一个加法函数和一个 `Plus Pos` 实例允许使用 `plus` 来添加 `Pos` 和 `Nat` 值："

#: src/type-classes/pos.md:112
#, fuzzy
msgid ""
"Because there is not yet an instance of `Plus Float`, attempting to add two "
"floating-point numbers with `plus` fails with a familiar message:"
msgstr "由于尚未定义 `Plus Float` 实例，尝试使用 `plus` 对两个浮点数进行加法运算时会失败，并出现一条熟悉的错误消息："

#: src/type-classes/pos.md:120
#, fuzzy
msgid ""
"These errors mean that Lean was unable to find an instance for a given type "
"class."
msgstr "这些错误意味着 Lean 无法找到给定类型类的实例。"

#: src/type-classes/pos.md:122
#, fuzzy
msgid "Overloaded Addition"
msgstr "重载加法"

#: src/type-classes/pos.md:124
#, fuzzy
msgid ""
"Lean's built-in addition operator is syntactic sugar for a type class called"
" `HAdd`, which flexibly allows the arguments to addition to have different "
"types. `HAdd` is short for _heterogeneous addition_. For example, an `HAdd` "
"instance can be written to allow a `Nat` to be added to a `Float`, resulting"
" in a new `Float`. When a programmer writes `x + y`, it is interpreted as "
"meaning `HAdd.hAdd x y`."
msgstr ""
"Lean 的内置加法运算符是类型类 `HAdd` 的语法糖，它灵活地允许加法运算符的参数具有不同的类型。`HAdd` 是 _异构加法_ "
"的缩写。例如，可以编写一个 `HAdd` 实例以允许将 `Nat` 添加到 `Float` 中，从而生成一个新的 `Float`。当程序员编写 `x +"
" y` 时，它被解释为 `HAdd.hAdd x y`。"

#: src/type-classes/pos.md:129
#, fuzzy
msgid ""
"While an understanding of the full generality of `HAdd` relies on features "
"that are discussed in [another section in this chapter](out-params.md), "
"there is a simpler type class called `Add` that does not allow the types of "
"the arguments to be mixed. The Lean libraries are set up so that an instance"
" of `Add` will be found when searching for an instance of `HAdd` in which "
"both arguments have the same type."
msgstr ""
"虽然对 `HAdd` 的全面理解依赖于 [本章另一部分](out-params.md) 中讨论的特性，但有一个更简单的类型类 "
"`Add`，它不允许混合参数的类型。Lean 库的设置方式是，在搜索两个参数具有相同类型的 `HAdd` 实例时，将找到 `Add` 的实例。"

#: src/type-classes/pos.md:132
#, fuzzy
msgid ""
"Defining an instance of `Add Pos` allows `Pos` values to use ordinary "
"addition syntax:"
msgstr "定义 `Add Pos` 的实例允许 `Pos` 值使用普通的加法语法："

#: src/type-classes/pos.md:140
#, fuzzy
msgid "Conversion to Strings"
msgstr "转换为字符串"

#: src/type-classes/pos.md:142
#, fuzzy
msgid ""
"Another useful built-in class is called `ToString`. Instances of `ToString` "
"provide a standard way of converting values from a given type into strings. "
"For example, a `ToString` instance is used when a value occurs in an "
"interpolated string, and it determines how the `IO.println` function used at"
" the [beginning of the description of `IO`](../hello-world/running-a-"
"program.html#running-a-program) will display a value."
msgstr ""
"另一个有用的内置类称为 `ToString`。`ToString` "
"的实例提供了一种将给定类型的值转换为字符串的标准方法。例如，当一个值出现在插值字符串中时，将使用 `ToString` 实例，并且它决定 [IO "
"描述开头](../hello-world/running-a-program.html#running-a-program) 中使用的 "
"`IO.println` 函数将如何显示一个值。"

#: src/type-classes/pos.md:146
#, fuzzy
msgid ""
"For example, one way to convert a `Pos` into a `String` is to reveal its "
"inner structure. The function `posToString` takes a `Bool` that determines "
"whether to parenthesize uses of `Pos.succ`, which should be `true` in the "
"initial call to the function and `false` in all recursive calls."
msgstr ""
"例如，将 `Pos` 转换为 `String` 的一种方法是揭示其内部结构。函数 `posToString` 接受一个 `Bool`，该 `Bool` "
"确定是否对 `Pos.succ` 的使用进行括号化，在对该函数的初始调用中应为 `true`，在所有递归调用中应为 `false`。"

#: src/type-classes/pos.md:148
#, fuzzy
msgid ""
"```lean\n"
"def posToString (atTop : Bool) (p : Pos) : String :=\n"
"  let paren s := if atTop then s else \"(\" ++ s ++ \")\"\n"
"  match p with\n"
"  | Pos.one => \"Pos.one\"\n"
"  | Pos.succ n => paren s!\"Pos.succ {posToString false n}\"\n"
"```"
msgstr ""
"```lean\n"
"def posToString (atTop : Bool) (p : Pos) : String :=\n"
"  let paren s := if atTop then s else \"(\" ++ s ++ \")\"\n"
"  match p with\n"
"  | Pos.one => \"Pos.one\"\n"
"  | Pos.succ n => paren s!\"Pos.succ {posToString false n}\"\n"
"```"

#: src/type-classes/pos.md:155
#, fuzzy
msgid "Using this function for a `ToString` instance:"
msgstr "使用此函数作为 `ToString` 实例："

#: src/type-classes/pos.md:160
#, fuzzy
msgid "results in informative, yet overwhelming, output:"
msgstr "会产生内容丰富但令人不知所措的输出："

#: src/type-classes/pos.md:161
#, fuzzy
msgid ""
"```lean\n"
"#eval s!\"There are {seven}\"\n"
"```"
msgstr ""
"```lean\n"
"#eval s!\"There are {seven}\"\n"
"```"

#: src/type-classes/pos.md:164
#, fuzzy
msgid ""
"```output info\n"
"\"There are Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ Pos.one)))))\"\n"
"```"
msgstr ""
"```output info\n"
"\"There are Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ Pos.one)))))\"\n"
"```"

#: src/type-classes/pos.md:168
#, fuzzy
msgid ""
"On the other hand, every positive number has a corresponding `Nat`. "
"Converting it to a `Nat` and then using the `ToString Nat` instance (that "
"is, the overloading of `toString` for `Nat`) is a quick way to generate much"
" shorter output:"
msgstr ""
"另一方面，每个正数都有一个对应的 `Nat`。将其转换为 `Nat`，然后使用 `ToString Nat` 实例（即 `Nat` 的 "
"`toString` 重载）是生成更短输出的快速方法："

#: src/type-classes/pos.md:170
#, fuzzy
msgid ""
"```lean\n"
"def Pos.toNat : Pos → Nat\n"
"  | Pos.one => 1\n"
"  | Pos.succ n => n.toNat + 1\n"
"\n"
"instance : ToString Pos where\n"
"  toString x := toString (x.toNat)\n"
"\n"
"#eval s!\"There are {seven}\"\n"
"```"
msgstr ""
"```lean\n"
"def Pos.toNat : Pos → Nat\n"
"  | Pos.one => 1\n"
"  | Pos.succ n => n.toNat + 1\n"
"\n"
"instance : ToString Pos where\n"
"  toString x := toString (x.toNat)\n"
"\n"
"#eval s!\"There are {seven}\"\n"
"```"

#: src/type-classes/pos.md:180
#, fuzzy
msgid ""
"```output info\n"
"\"There are 7\"\n"
"```"
msgstr ""
"```output info\n"
"\"There are 7\"\n"
"```"

#: src/type-classes/pos.md:183
#, fuzzy
msgid ""
"When more than one instance is defined, the most recent takes precedence. "
"Additionally, if a type has a `ToString` instance, then it can be used to "
"display the result of `#eval` even if the type in question was not defined "
"with `deriving Repr`, so `#eval seven` outputs `7`."
msgstr ""
"当定义了多个实例时，最近的实例优先。此外，如果一个类型有一个 `ToString` 实例，那么它可以用来显示 `#eval` 的结果，即使该类型没有用 "
"`deriving Repr` 定义，所以 `#eval seven` 输出 `7`。"

#: src/type-classes/pos.md:186
#, fuzzy
msgid "Overloaded Multiplication"
msgstr "重载乘法"

#: src/type-classes/pos.md:188
#, fuzzy
msgid ""
"For multiplication, there is a type class called `HMul` that allows mixed "
"argument types, just like `HAdd`. Just as `x + y` is interpreted as "
"`HAdd.hAdd x y`, `x * y` is interpreted as `HMul.hMul x y`. For the common "
"case of multiplication of two arguments with the same type, a `Mul` instance"
" suffices."
msgstr ""
"对于乘法，有一个类型类称为 `HMul`，它允许混合参数类型，就像 `HAdd` 一样。正如 `x + y` 被解释为 `HAdd.hAdd x "
"y`，`x * y` 被解释为 `HMul.hMul x y`。对于两个具有相同类型的参数相乘的常见情况，`Mul` 实例就足够了。"

#: src/type-classes/pos.md:192
#, fuzzy
msgid ""
"An instance of `Mul` allows ordinary multiplication syntax to be used with "
"`Pos`:"
msgstr "`Mul` 实例允许使用普通乘法语法与 `Pos` 一起使用："

#: src/type-classes/pos.md:201
#, fuzzy
msgid "With this instance, multiplication works as expected:"
msgstr "有了这个实例，乘法按预期工作："

#: src/type-classes/pos.md:211
#, fuzzy
msgid "Literal Numbers"
msgstr "字面数字"

#: src/type-classes/pos.md:213
#, fuzzy
msgid ""
"It is quite inconvenient to write out a sequence of constructors for "
"positive numbers. One way to work around the problem would be to provide a "
"function to convert a `Nat` into a `Pos`. However, this approach has "
"downsides. First off, because `Pos` cannot represent `0`, the resulting "
"function would either convert a `Nat` to a bigger number, or it would return"
" `Option Pos`. Neither is particularly convenient for users. Secondly, the "
"need to call the function explicitly would make programs that use positive "
"numbers much less convenient to write than programs that use `Nat`. Having a"
" trade-off between precise types and convenient APIs means that the precise "
"types become less useful."
msgstr ""
"为正数写出一系列构造函数非常不方便。解决这个问题的一种方法是提供一个将 `Nat` 转换为 `Pos` 的函数。然而，这种方法有缺点。首先，因为 "
"`Pos` 不能表示 `0`，所以结果函数要么将 `Nat` 转换为一个更大的数字，要么返回 `Option "
"Pos`。对于用户来说，这两种方式都不太方便。其次，需要显式调用函数会使使用正数的程序比使用 `Nat` 的程序更不方便编写。在精确类型和方便的 API"
" 之间进行权衡意味着精确类型变得不太有用。"

#: src/type-classes/pos.md:221
#, fuzzy
msgid ""
"In Lean, natural number literals are interpreted using a type class called "
"`OfNat`:"
msgstr "在 Lean 中，自然数文字使用名为 `OfNat` 的类型类进行解释："

#: src/type-classes/pos.md:226
#, fuzzy
msgid ""
"This type class takes two arguments: `α` is the type for which a natural "
"number is overloaded, and the unnamed `Nat` argument is the actual literal "
"number that was encountered in the program. The method `ofNat` is then used "
"as the value of the numeric literal. Because the class contains the `Nat` "
"argument, it becomes possible to define only instances for those values "
"where the number makes sense."
msgstr ""
"此类型类有两个参数：`α` 是自然数重载的类型，未命名的 `Nat` 参数是程序中遇到的实际文字数字。然后将 `ofNat` "
"方法用作数字文字的值。因为该类包含 `Nat` 参数，所以只为数字有意义的值定义实例成为可能。"

#: src/type-classes/pos.md:230
#, fuzzy
msgid ""
"`OfNat` demonstrates that the arguments to type classes do not need to be "
"types. Because types in Lean are first-class participants in the language "
"that can be passed as arguments to functions and given definitions with "
"`def` and `abbrev`, there is no barrier that prevents non-type arguments in "
"positions where a less-flexible language could not permit them. This "
"flexibility allows overloaded operations to be provided for particular "
"values as well as particular types."
msgstr ""
"`OfNat` 证明了类型类的参数不必是类型。因为 Lean 中的类型是语言中的一等参与者，可以作为参数传递给函数，并使用 `def` 和 "
"`abbrev` 给出定义，所以没有障碍可以阻止在不太灵活的语言不允许的位置使用非类型参数。这种灵活性允许为特定值和特定类型提供重载操作。"

#: src/type-classes/pos.md:234
#, fuzzy
msgid ""
"For example, a sum type that represents natural numbers less than four can "
"be defined as follows:"
msgstr "例如，一个表示小于 4 的自然数的和类型可以定义如下："

#: src/type-classes/pos.md:243
#, fuzzy
msgid ""
"While it would not make sense to allow _any_ literal number to be used for "
"this type, numbers less than four clearly make sense:"
msgstr "虽然允许 _任何_ 字面数字用于此类型毫无意义，但小于 4 的数字显然有意义："

#: src/type-classes/pos.md:257
#, fuzzy
msgid "With these instances, the following examples work:"
msgstr "有了这些实例，以下示例有效："

#: src/type-classes/pos.md:270
#, fuzzy
msgid "On the other hand, out-of-bounds literals are still not allowed:"
msgstr "另一方面，仍然不允许越界的字面量："

#: src/type-classes/pos.md:279
#, fuzzy
msgid ""
"For `Pos`, the `OfNat` instance should work for _any_ `Nat` other than "
"`Nat.zero`. Another way to phrase this is to say that for all natural "
"numbers `n`, the instance should work for `n + 1`. Just as names like `α` "
"automatically become implicit arguments to functions that Lean fills out on "
"its own, instances can take automatic implicit arguments. In this instance, "
"the argument `n` stands for any `Nat`, and the instance is defined for a "
"`Nat` that's one greater:"
msgstr ""
"对于 `Pos`，`OfNat` 实例应该适用于 _任何_ `Nat`，除了 `Nat.zero`。另一种说法是，对于所有自然数 "
"`n`，该实例应该适用于 `n + 1`。就像 `α` 等名称自动成为 Lean "
"自行填充的函数的隐式参数一样，实例可以采用自动隐式参数。在此实例中，参数 `n` 表示任何 `Nat`，并且该实例被定义为比用户编写的 `Nat` 大 "
"1："

#: src/type-classes/pos.md:291
#, fuzzy
msgid ""
"Because `n` stands for a `Nat` that's one less than what the user wrote, the"
" helper function `natPlusOne` returns a `Pos` that's one greater than its "
"argument. This makes it possible to use natural number literals for positive"
" numbers, but not for zero:"
msgstr ""
"因为 `n` 表示比用户编写的 `Nat` 小 1，所以辅助函数 `natPlusOne` 返回一个比其参数大 1 的 "
"`Pos`。这使得可以使用自然数字面量表示正数，但不能表示零："

#: src/type-classes/pos.md:305
#, fuzzy
msgid "Another Representation"
msgstr "另一种表示"

#: src/type-classes/pos.md:307
#, fuzzy
msgid ""
"An alternative way to represent a positive number is as the successor of "
"some `Nat`. Replace the definition of `Pos` with a structure whose "
"constructor is named `succ` that contains a `Nat`:"
msgstr ""
"表示正数的另一种方法是将其表示为某个 `Nat` 的后继。用一个构造函数名为 `succ` 并包含一个 `Nat` 的结构替换 `Pos` 的定义："

#: src/type-classes/pos.md:314
#, fuzzy
msgid ""
"Define instances of `Add`, `Mul`, `ToString`, and `OfNat` that allow this "
"version of `Pos` to be used conveniently."
msgstr "定义 `Add`、`Mul`、`ToString` 和 `OfNat` 的实例，以便方便地使用此版本的 `Pos`。"

#: src/type-classes/pos.md:316
#, fuzzy
msgid "Even Numbers"
msgstr "偶数"

#: src/type-classes/pos.md:318
#, fuzzy
msgid ""
"Define a datatype that represents only even numbers. Define instances of "
"`Add`, `Mul`, and `ToString` that allow it to be used conveniently. `OfNat` "
"requires a feature that is introduced in [the next "
"section](polymorphism.md)."
msgstr ""
"定义一个仅表示偶数的数据类型。定义 `Add`、`Mul` 和 `ToString` 的实例，以便方便地使用它。`OfNat` 需要 "
"[下一节](polymorphism.md) 中引入的一个特性。"

#: src/type-classes/pos.md:321
#, fuzzy
msgid "HTTP Requests"
msgstr "HTTP 请求"

#: src/type-classes/pos.md:323
#, fuzzy
msgid ""
"An HTTP request begins with an identification of a HTTP method, such as "
"`GET` or `POST`, along with a URI and an HTTP version. Define an inductive "
"type that represents an interesting subset of the HTTP methods, and a "
"structure that represents HTTP responses. Responses should have a `ToString`"
" instance that makes it possible to debug them. Use a type class to "
"associate different `IO` actions with each HTTP method, and write a test "
"harness as an `IO` action that calls each method and prints the result."
msgstr ""
"HTTP 请求以 HTTP 方法的标识符开头，例如 `GET` 或 `POST`，以及一个 URI 和一个 HTTP 版本。定义一个归纳类型来表示 "
"HTTP 方法的一个有趣子集，以及一个表示 HTTP 响应的结构。响应应该有一个 `ToString` 实例，以便调试它们。使用类型类将不同的 `IO`"
" 操作与每个 HTTP 方法关联起来，并编写一个测试框架作为 `IO` 操作，调用每个方法并打印结果。"
