#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/programs-proofs/inequalities.md:3
#, fuzzy
msgid ""
"Lean's built-in proof automation is sufficient to check that "
"`arrayMapHelper` and `findHelper` terminate. All that was needed was to "
"provide an expression whose value decreases with each recursive call. "
"However, Lean's built-in automation is not magic, and it often needs some "
"help."
msgstr ""
"Lean 的内置证明自动化足以检查 `arrayMapHelper` 和 `findHelper` "
"是否终止。所需要做的就是提供一个其值随着每次递归调用而减小的表达式。但是，Lean 的内置自动化不是万能的，它通常需要一些帮助。"

#: src/programs-proofs/inequalities.md:7
#, fuzzy
msgid "Merge Sort"
msgstr "归并排序"

#: src/programs-proofs/inequalities.md:9
#, fuzzy
msgid ""
"One example of a function whose termination proof is non-trivial is merge "
"sort on `List`. Merge sort consists of two phases: first, a list is split in"
" half. Each half is sorted using merge sort, and then the results are merged"
" using a function that combines two sorted lists into a larger sorted list. "
"The base cases are the empty list and the singleton list, both of which are "
"already considered to be sorted."
msgstr ""
"一个终止证明非平凡的函数示例是 `List` "
"上的归并排序。归并排序包含两个阶段：首先，将列表分成两半。使用归并排序对每一半进行排序，然后使用一个将两个已排序列表合并为一个更大的已排序列表的函数合并结果。基本情况是空列表和单元素列表，它们都被认为已经排序。"

#: src/programs-proofs/inequalities.md:14
#, fuzzy
msgid "To merge two sorted lists, there are two basic cases to consider:"
msgstr "要合并两个已排序列表，需要考虑两个基本情况："

#: src/programs-proofs/inequalities.md:15
#, fuzzy
msgid "If one of the input lists is empty, then the result is the other list."
msgstr "如果一个输入列表为空，则结果是另一个列表。"

#: src/programs-proofs/inequalities.md:16
#, fuzzy
msgid ""
"If both lists are non-empty, then their heads should be compared. The result"
" of the function is the smaller of the two heads, followed by the result of "
"merging the remaining entries of both lists."
msgstr "如果两个列表都不为空，则应比较它们的头部。该函数的结果是两个头部中较小的一个，后面是合并两个列表的剩余项的结果。"

#: src/programs-proofs/inequalities.md:18
#, fuzzy
msgid ""
"This is not structurally recursive on either list. The recursion terminates "
"because an entry is removed from one of the two lists in each recursive "
"call, but it could be either list. The `termination_by` clause uses the sum "
"of the length of both lists as a decreasing value:"
msgstr ""
"这在任何列表上都不是结构递归。递归终止是因为在每次递归调用中都会从两个列表中的一个中删除一个项，但它可能是任何一个列表。`termination_by`"
" 子句使用两个列表长度的和作为递减值："

#: src/programs-proofs/inequalities.md:33
#, fuzzy
msgid ""
"In addition to using the lengths of the lists, a pair that contains both "
"lists can also be provided:"
msgstr "除了使用列表的长度，还可以提供包含两个列表的元组："

#: src/programs-proofs/inequalities.md:45
#, fuzzy
msgid ""
"This works because Lean has a built-in notion of sizes of data, expressed "
"through a type class called `WellFoundedRelation`. The instance for pairs "
"automatically considers them to be smaller if either the first or the second"
" item in the pair shrinks."
msgstr ""
"这有效是因为 Lean 有一个内置的数据大小概念，通过一个称为 `WellFoundedRelation` "
"的类型类来表示。元组的实例会自动认为它们更小，如果元组中的第一个或第二个项缩小。"

#: src/programs-proofs/inequalities.md:48
#, fuzzy
msgid ""
"A simple way to split a list is to add each entry in the input list to two "
"alternating output lists:"
msgstr "分割列表的一个简单方法是将输入列表中的每个项添加到两个交替的输出列表中："

#: src/programs-proofs/inequalities.md:58
#, fuzzy
msgid ""
"Merge sort checks whether a base case has been reached. If so, it returns "
"the input list. If not, it splits the input, and merges the result of "
"sorting each half:"
msgstr "归并排序检查是否已达到基本情况。如果是，则返回输入列表。如果不是，则分割输入，并合并对每一半排序的结果："

#: src/programs-proofs/inequalities.md:71
#, fuzzy
msgid ""
"Lean's pattern match compiler is able to tell that the assumption `h` "
"introduced by the `if` that tests whether `xs.length < 2` rules out lists "
"longer than one entry, so there is no \"missing cases\" error. However, even"
" though this program always terminates, it is not structurally recursive:"
msgstr ""
"Lean 的模式匹配编译器能够判断由测试 `xs.length < 2` 的 `if` 引入的前提 `h` "
"排除了长度超过一个条目的列表，因此没有“缺少情况”错误。然而，即使此程序总是终止，它也不是结构递归的："

#: src/programs-proofs/inequalities.md:85
#, fuzzy
msgid ""
"The reason it terminates is that `splitList` always returns lists that are "
"shorter than its input. Thus, the length of `halves.fst` and `halves.snd` "
"are less than the length of `xs`. This can be expressed using a "
"`termination_by` clause:"
msgstr ""
"它终止的原因是 `splitList` 总是返回比其输入短的列表。因此，`halves.fst` 和 `halves.snd` 的长度小于 `xs` "
"的长度。这可以使用 `termination_by` 子句来表示："

#: src/programs-proofs/inequalities.md:99
#, fuzzy
msgid ""
"With this clause, the error message changes. Instead of complaining that the"
" function isn't structurally recursive, Lean instead points out that it was "
"unable to automatically prove that `(splitList xs).fst.length < xs.length`:"
msgstr ""
"有了这个子句，错误信息就变了。Lean 不会抱怨函数不是结构递归的，而是指出它无法自动证明 `(splitList xs).fst.length < "
"xs.length`："

#: src/programs-proofs/inequalities.md:113
#, fuzzy
msgid "Splitting a List Makes it Shorter"
msgstr "分割列表使其变短"

#: src/programs-proofs/inequalities.md:115
#, fuzzy
msgid ""
"It will also be necessary to prove that `(splitList xs).snd.length < "
"xs.length`. Because `splitList` alternates between adding entries to the two"
" lists, it is easiest to prove both statements at once, so the structure of "
"the proof can follow the algorithm used to implement `splitList`. In other "
"words, it is easiest to prove that `∀(lst : List), (splitList "
"lst).fst.length < lst.length ∧ (splitList lst).snd.length < lst.length`."
msgstr ""
"还需要证明 `(splitList xs).snd.length < xs.length`。由于 `splitList` "
"在向两个列表添加条目之间交替进行，因此最简单的方法是同时证明这两个语句，这样证明的结构就可以遵循用于实现 `splitList` "
"的算法。换句话说，最简单的方法是证明 `∀(lst : List), (splitList lst).fst.length < lst.length ∧"
" (splitList lst).snd.length < lst.length`。"

#: src/programs-proofs/inequalities.md:119
#, fuzzy
msgid ""
"Unfortunately, the statement is false. In particular, `splitList []` is "
"`([], [])`. Both output lists have length `0`, which is not less than `0`, "
"the length of the input list. Similarly, `splitList [\"basalt\"]` evaluates "
"to `([\"basalt\"], [])`, and `[\"basalt\"]` is not shorter than "
"`[\"basalt\"]`. However, `splitList [\"basalt\", \"granite\"]` evaluates to "
"`([\"basalt\"], [\"granite\"])`, and both of these output lists are shorter "
"than the input list."
msgstr ""
"不幸的是，这个说法是错误的。特别是，`splitList []` 是 `([], [])`。两个输出列表的长度都是 `0`，这并不小于输入列表的长度 "
"`0`。类似地，`splitList [\"basalt\"]` 计算为 `([\"basalt\"], [])`，而 `[\"basalt\"]` "
"并不比 `[\"basalt\"]` 短。然而，`splitList [\"basalt\", \"granite\"]` 计算为 "
"`([\"basalt\"], [\"granite\"])`，这两个输出列表都比输入列表短。"

#: src/programs-proofs/inequalities.md:124
#, fuzzy
msgid ""
"It turns out that the lengths of the output lists are always less than or "
"equal to the length of the input list, but they are only strictly shorter "
"when the input list contains at least two entries. It turns out to be "
"easiest to prove the former statement, then extend it to the latter "
"statement. Begin with a theorem statement:"
msgstr ""
"输出列表的长度始终小于或等于输入列表的长度，但仅当输入列表至少包含两个条目时，它们才严格较短。事实证明，最容易证明前一个陈述，然后将其扩展到后一个陈述。从定理陈述开始："

#: src/programs-proofs/inequalities.md:139
#, fuzzy
msgid ""
"Because `splitList` is structurally recursive on the list, the proof should "
"use induction. The structural recursion in `splitList` fits a proof by "
"induction perfectly: the base case of the induction matches the base case of"
" the recursion, and the inductive step matches the recursive call. The "
"`induction` tactic gives two goals:"
msgstr ""
"由于 `splitList` 在列表上是结构递归的，因此证明应使用归纳法。`splitList` "
"中的结构递归非常适合归纳证明：归纳法的基本情况与递归的基本情况匹配，归纳步骤与递归调用匹配。`induction` 战术给出了两个目标："

#: src/programs-proofs/inequalities.md:167
#, fuzzy
msgid ""
"The goal for the `nil` case can be proved by invoking the simplifier and "
"instructing it to unfold the definition of `splitList`, because the length "
"of the empty list is less than or equal to the length of the empty list. "
"Similarly, simplifying with `splitList` in the `cons` case places `Nat.succ`"
" around the lengths in the goal:"
msgstr ""
"可以通过调用简化器并指示它展开 `splitList` 的定义来证明 `nil` 情况的目标，因为空列表的长度小于或等于空列表的长度。类似地，在 "
"`cons` 情况下使用 `splitList` 简化会在目标中的长度周围放置 `Nat.succ`："

#: src/programs-proofs/inequalities.md:188
#, fuzzy
msgid ""
"This is because the call to `List.length` consumes the head of the list `x "
":: xs`, converting it to a `Nat.succ`, in both the length of the input list "
"and the length of the first output list."
msgstr ""
"这是因为对 `List.length` 的调用消耗了列表 `x :: xs` 的头部，将其转换为 "
"`Nat.succ`，既在输入列表的长度中，也在第一个输出列表的长度中。"

#: src/programs-proofs/inequalities.md:190
#, fuzzy
msgid ""
"Writing `A ∧ B` in Lean is short for `And A B`. `And` is a structure type in"
" the `Prop` universe:"
msgstr "在 Lean 中编写 `A ∧ B` 是 `And A B` 的缩写。`And` 是 `Prop` 宇宙中的一个结构类型："

#: src/programs-proofs/inequalities.md:198
#, fuzzy
msgid ""
"In other words, a proof of `A ∧ B` consists of the `And.intro` constructor "
"applied to a proof of `A` in the `left` field and a proof of `B` in the "
"`right` field."
msgstr ""
"换句话说，`A ∧ B` 的证明包括应用于 `left` 域中 `A` 的证明和应用于 `right` 域中 `B` 的证明的 `And.intro` "
"构造函数。"

#: src/programs-proofs/inequalities.md:200
#, fuzzy
msgid ""
"The `cases` tactic allows a proof to consider each constructor of a datatype"
" or each potential proof of a proposition in turn. It corresponds to a "
"`match` expression without recursion. Using `cases` on a structure results "
"in the structure being broken apart, with an assumption added for each field"
" of the structure, just as a pattern match expression extracts the field of "
"a structure for use in a program. Because structures have only one "
"constructor, using `cases` on a structure does not result in additional "
"goals."
msgstr ""
"`cases` 战术允许证明依次考虑数据类型的每个构造函数或命题的每个潜在证明。它对应于没有递归的 `match` 表达式。对结构使用 `cases` "
"会导致结构被分解，并为结构的每个字段添加一个假设，就像模式匹配表达式提取结构的字段以用于程序中一样。由于结构只有一个构造函数，因此对结构使用 "
"`cases` 不会产生额外的目标。"

#: src/programs-proofs/inequalities.md:205
#, fuzzy
msgid ""
"Because `ih` is a proof of `List.length (splitList xs).fst ≤ List.length xs "
"∧ List.length (splitList xs).snd ≤ List.length xs`, using `cases ih` results"
" in an assumption that `List.length (splitList xs).fst ≤ List.length xs` and"
" an assumption that `List.length (splitList xs).snd ≤ List.length xs`:"
msgstr ""
"由于 `ih` 是 `List.length (splitList xs).fst ≤ List.length xs ∧ List.length "
"(splitList xs).snd ≤ List.length xs` 的证明，使用 `cases ih` 会产生一个假设 `List.length "
"(splitList xs).fst ≤ List.length xs` 和一个假设 `List.length (splitList xs).snd ≤"
" List.length xs`："

#: src/programs-proofs/inequalities.md:228
#, fuzzy
msgid ""
"Because the goal of the proof is also an `And`, the `constructor` tactic can"
" be used to apply `And.intro`, resulting in a goal for each argument:"
msgstr ""
"由于证明的目标也是一个 `And`，因此可以使用 `constructor` 策略应用 `And.intro`，从而为每个参数生成一个目标："

#: src/programs-proofs/inequalities.md:259
#, fuzzy
msgid ""
"The `left` goal is very similar to the `left✝` assumption, except the goal "
"wraps both sides of the inequality in `Nat.succ`. Likewise, the `right` goal"
" resembles the `right✝` assumption, except the goal adds a `Nat.succ` only "
"to the length of the input list. It's time to prove that these wrappings of "
"`Nat.succ` preserve the truth of the statement."
msgstr ""
"`left` 目标与 `left✝` 假设非常相似，除了目标用 `Nat.succ` 包装不等式的两侧。同样，`right` 目标类似于 "
"`right✝` 假设，除了目标仅将 `Nat.succ` 添加到输入列表的长度。现在是时候证明 `Nat.succ` 的这些包装保留了语句的真值。"

#: src/programs-proofs/inequalities.md:263
#, fuzzy
msgid "Adding One to Both Sides"
msgstr "在两边都加一"

#: src/programs-proofs/inequalities.md:265
#, fuzzy
msgid ""
"For the `left` goal, the statement to prove is `Nat.succ_le_succ : n ≤ m → "
"Nat.succ n ≤ Nat.succ m`. In other words, if `n ≤ m`, then adding one to "
"both sides doesn't change this fact. Why is this true? The proof that `n ≤ "
"m` is a `Nat.le.refl` constructor with `m - n` instances of the "
"`Nat.le.step` constructor wrapped around it. Adding one to both sides simply"
" means that the `refl` applies to a number that's one larger than before, "
"with the same number of `step` constructors."
msgstr ""
"对于 `left` 目标，要证明的语句是 `Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ "
"m`。换句话说，如果 `n ≤ m`，那么在两边都加一并不会改变这一事实。为什么这是真的？证明 `n ≤ m` 是一个 `Nat.le.refl` "
"构造器，周围有 `m - n` 个 `Nat.le.step` 构造器的实例。在两边都加一只是意味着 `refl` "
"应用于比之前大一个数的数，并且具有相同数量的 `step` 构造器。"

#: src/programs-proofs/inequalities.md:271
#, fuzzy
msgid ""
"More formally, the proof is by induction on the evidence that `n ≤ m`. If "
"the evidence is `refl`, then `n = m`, so `Nat.succ n = Nat.succ m` and "
"`refl` can be used again. If the evidence is `step`, then the induction "
"hypothesis provides evidence that `Nat.succ n ≤ Nat.succ m`, and the goal is"
" to show that `Nat.succ n ≤ Nat.succ (Nat.succ m)`. This can be done by "
"using `step` together with the induction hypothesis."
msgstr ""
"更正式地说，证明是通过归纳法来证明 `n ≤ m` 的证据。如果证据是 `refl`，则 `n = m`，所以 `Nat.succ n = "
"Nat.succ m`，并且可以再次使用 `refl`。如果证据是 `step`，则归纳假设提供了 `Nat.succ n ≤ Nat.succ m` "
"的证据，并且目标是证明 `Nat.succ n ≤ Nat.succ (Nat.succ m)`。这可以通过将 `step` 与归纳假设一起使用来完成。"

#: src/programs-proofs/inequalities.md:276
#, fuzzy
msgid "In Lean, the theorem statement is:"
msgstr "在 Lean 中，定理陈述为："

#: src/programs-proofs/inequalities.md:281
#, fuzzy
msgid "and the error message recapitulates it:"
msgstr "错误信息对其进行了概括："

#: src/programs-proofs/inequalities.md:288
#, fuzzy
msgid ""
"The first step is to use the `intro` tactic, bringing the hypothesis that `n"
" ≤ m` into scope and giving it a name:"
msgstr "第一步是使用 `intro` 策略，将假设 `n ≤ m` 引入作用域并为其命名："

#: src/programs-proofs/inequalities.md:300
#, fuzzy
msgid ""
"Because the proof is by induction on the evidence that `n ≤ m`, the next "
"tactic is `induction h`:"
msgstr "由于证明是通过归纳法对证据 `n ≤ m` 进行的，因此下一个策略是 `induction h`："

#: src/programs-proofs/inequalities.md:306
#, fuzzy
msgid "This results in two goals, once for each constructor of `Nat.le`:"
msgstr "这会产生两个目标，每个目标对应于 `Nat.le` 的一个构造器："

#: src/programs-proofs/inequalities.md:319
#, fuzzy
msgid ""
"The goal for `refl` can itself be solved using `refl`, which the "
"`constructor` tactic selects. The goal for `step` will also require a use of"
" the `step` constructor:"
msgstr ""
"`refl` 的目标可以使用 `refl` 本身来解决，`constructor` 策略会选择它。`step` 的目标还需要使用 `step` 构造器："

#: src/programs-proofs/inequalities.md:336
#, fuzzy
msgid ""
"The goal is no longer shown using the `≤` operator, but it is equivalent to "
"the induction hypothesis `ih`. The `assumption` tactic automatically selects"
" an assumption that fulfills the goal, and the proof is complete:"
msgstr "该目标不再使用 `≤` 运算符显示，但它等价于归纳假设 `ih`。`assumption` 策略会自动选择一个满足目标的假设，证明完成："

#: src/programs-proofs/inequalities.md:348
#, fuzzy
msgid "Written as a recursive function, the proof is:"
msgstr "写成递归函数，证明如下："

#: src/programs-proofs/inequalities.md:354
#, fuzzy
msgid ""
"It can be instructional to compare the tactic-based proof by induction with "
"this recursive function. Which proof steps correspond to which parts of the "
"definition?"
msgstr "将基于策略的归纳证明与这个递归函数进行比较是有指导意义的。哪些证明步骤对应于定义的哪些部分？"

#: src/programs-proofs/inequalities.md:357
#, fuzzy
msgid "Adding One to the Greater Side"
msgstr "将 1 加到较大的一侧"

#: src/programs-proofs/inequalities.md:359
#, fuzzy
msgid ""
"The second inequality needed to prove `splitList_shorter_le` is `∀(n m : "
"Nat), n ≤ m → n ≤ Nat.succ m`. This proof is almost identical to "
"`Nat.succ_le_succ`. Once again, the incoming assumption that `n ≤ m` "
"essentially tracks the difference between `n` and `m` in the number of "
"`Nat.le.step` constructors. Thus, the proof should add an extra "
"`Nat.le.step` in the base case. The proof can be written:"
msgstr ""
"证明 `splitList_shorter_le` 所需的第二个不等式是 `∀(n m : Nat), n ≤ m → n ≤ Nat.succ "
"m`。这个证明几乎与 `Nat.succ_le_succ` 相同。同样，传入的假设 `n ≤ m` 基本上跟踪了 `n` 和 `m` 在 "
"`Nat.le.step` 构造器数量上的差异。因此，证明应该在基本情况下添加一个额外的 `Nat.le.step`。证明可以写成："

#: src/programs-proofs/inequalities.md:372
#, fuzzy
msgid ""
"To reveal what's going on behind the scenes, the `apply` and `exact` tactics"
" can be used to indicate exactly which constructor is being applied. The "
"`apply` tactic solves the current goal by applying a function or constructor"
" whose return type matches, creating new goals for each argument that was "
"not provided, while `exact` fails if any new goals would be needed:"
msgstr ""
"为了揭示幕后发生的事情，`apply` 和 `exact` 策略可用于准确指示正在应用哪个构造器。`apply` "
"策略通过应用一个返回类型匹配的函数或构造器来解决当前目标，为每个未提供的参数创建新的目标，而如果需要任何新目标，`exact` 就会失败："

#: src/programs-proofs/inequalities.md:382
#, fuzzy
msgid "The proof can be golfed:"
msgstr "证明可以简化："

#: src/programs-proofs/inequalities.md:387
#, fuzzy
msgid ""
"In this short tactic script, both goals introduced by `induction` are "
"addressed using `repeat (first | constructor | assumption)`. The tactic "
"`first | T1 | T2 | ... | Tn` means to use try `T1` through `Tn` in order, "
"using the first tactic that succeeds. In other words, `repeat (first | "
"constructor | assumption)` applies constructors as long as it can, and then "
"attempts to solve the goal using an assumption."
msgstr ""
"在这个简短的策略脚本中，由 `induction` 引入的两个目标都使用 `repeat (first | constructor | "
"assumption)` 来解决。策略 `first | T1 | T2 | ... | Tn` 表示按顺序尝试 `T1` 到 "
"`Tn`，使用第一个成功的策略。换句话说，`repeat (first | constructor | assumption)` "
"会尽可能地应用构造器，然后尝试使用假设来解决目标。"

#: src/programs-proofs/inequalities.md:391
#, fuzzy
msgid "Finally, the proof can be written as a recursive function:"
msgstr "最后，证明可以写成一个递归函数："

#: src/programs-proofs/inequalities.md:398
#, fuzzy
msgid ""
"Each style of proof can be appropriate to different circumstances. The "
"detailed proof script is useful in cases where beginners may be reading the "
"code, or where the steps of the proof provide some kind of insight. The "
"short, highly-automated proof script is typically easier to maintain, "
"because automation is frequently both flexible and robust in the face of "
"small changes to definitions and datatypes. The recursive function is "
"typically both harder to understand from the perspective of mathematical "
"proofs and harder to maintain, but it can be a useful bridge for programmers"
" who are beginning to work with interactive theorem proving."
msgstr ""
"每种证明风格都适用于不同的情况。详细的证明脚本在初学者阅读代码或证明步骤提供某种见解的情况下很有用。简短、高度自动化的证明脚本通常更容易维护，因为自动化通常在面对定义和数据类型的细微更改时既灵活又健壮。递归函数通常从数学证明的角度来看更难理解，也更难维护，但对于开始使用交互式定理证明的程序员来说，它可能是一个有用的桥梁。"

#: src/programs-proofs/inequalities.md:403
#, fuzzy
msgid "Finishing the Proof"
msgstr "完成证明"

#: src/programs-proofs/inequalities.md:405
#, fuzzy
msgid ""
"Now that both helper theorems have been proved, the rest of "
"`splitList_shorter_le` will be completed quickly. The current proof state "
"has two goals, for the left and right sides of the `And`:"
msgstr ""
"现在已经证明了两个辅助定理，`splitList_shorter_le` 的其余部分将很快完成。当前的证明状态有两个目标，用于 `And` "
"的左侧和右侧："

#: src/programs-proofs/inequalities.md:426
#, fuzzy
msgid ""
"The goals are named for the fields of the `And` structure. This means that "
"the `case` tactic (not to be confused with `cases`) can be used to focus on "
"each of them in turn:"
msgstr "目标以 `And` 结构的字段命名。这意味着 `case` 策略（不要与 `cases` 混淆）可用于依次关注每个目标："

#: src/programs-proofs/inequalities.md:439
#, fuzzy
msgid ""
"Instead of a single error that lists both unsolved goals, there are now two "
"messages, one on each `skip`. For the `left` goal, `Nat.succ_le_succ` can be"
" used:"
msgstr ""
"现在不再是单一的错误列出所有未解决的目标，而是有两个消息，每个`skip`上一个。对于`left`目标，可以使用`Nat.succ_le_succ`："

#: src/programs-proofs/inequalities.md:450
#, fuzzy
msgid "In the right goal, `Nat.le_suc_of_le` fits:"
msgstr "在右侧目标中，`Nat.le_suc_of_le`适合："

#: src/programs-proofs/inequalities.md:460
#, fuzzy
msgid ""
"Both theorems include the precondition that `n ≤ m`. These can be found as "
"the `left✝` and `right✝` assumptions, which means that the `assumption` "
"tactic takes care of the final goals:"
msgstr ""
"这两个定理都包含前提条件`n ≤ m`。这些可以作为`left✝`和`right✝`假设找到，这意味着`assumption`策略处理最终目标："

#: src/programs-proofs/inequalities.md:475
#, fuzzy
msgid ""
"The next step is to return to the actual theorem that is needed to prove "
"that merge sort terminates: that so long as a list has at least two entries,"
" both results of splitting it are strictly shorter."
msgstr "下一步是返回到证明归并排序终止所需的实际定理：只要一个列表至少有两个条目，则分割它的两个结果都严格短于它。"

#: src/programs-proofs/inequalities.md:489
#, fuzzy
msgid ""
"Pattern matching works just as well in tactic scripts as it does in "
"programs. Because `lst` has at least two entries, they can be exposed with "
"`match`, which also refines the type through dependent pattern matching:"
msgstr ""
"模式匹配在策略脚本中与在程序中一样有效。因为`lst`至少有两个条目，所以它们可以用`match`暴露出来，它还通过依赖模式匹配来细化类型："

#: src/programs-proofs/inequalities.md:509
#, fuzzy
msgid ""
"Simplifying using `splitList` removes `x` and `y`, resulting in the computed"
" lengths of lists each gaining a `Nat.succ`:"
msgstr "使用`splitList`简化会删除`x`和`y`，导致列表的计算长度每个都获得`Nat.succ`："

#: src/programs-proofs/inequalities.md:528
#, fuzzy
msgid ""
"Replacing `simp` with `simp_arith` removes these `Nat.succ` constructors, "
"because `simp_arith` makes use of the fact that `n + 1 < m + 1` implies `n <"
" m`:"
msgstr ""
"用`simp_arith`替换`simp`会删除这些`Nat.succ`构造器，因为`simp_arith`利用了`n + 1 < m + "
"1`意味着`n < m`的事实："

#: src/programs-proofs/inequalities.md:546
#, fuzzy
msgid ""
"This goal now matches `splitList_shorter_le`, which can be used to conclude "
"the proof:"
msgstr "此目标现在匹配`splitList_shorter_le`，可用于结束证明："

#: src/programs-proofs/inequalities.md:557
#, fuzzy
msgid ""
"The facts needed to prove that `mergeSort` terminates can be pulled out of "
"the resulting `And`:"
msgstr "证明`mergeSort`终止所需的事实可以从结果`And`中提取出来："

#: src/programs-proofs/inequalities.md:568
#, fuzzy
msgid "Merge Sort Terminates"
msgstr "归并排序终止"

#: src/programs-proofs/inequalities.md:570
#, fuzzy
msgid ""
"Merge sort has two recursive calls, one for each sub-list returned by "
"`splitList`. Each recursive call will require a proof that the length of the"
" list being passed to it is shorter than the length of the input list. It's "
"usually convenient to write a termination proof in two steps: first, write "
"down the propositions that will allow Lean to verify termination, and then "
"prove them. Otherwise, it's possible to put a lot of effort into proving the"
" propositions, only to find out that they aren't quite what's needed to "
"establish that the recursive calls are on smaller inputs."
msgstr ""
"归并排序有两个递归调用，一个用于`splitList`返回的每个子列表。每个递归调用都需要证明传递给它的列表的长度短于输入列表的长度。通常方便分两步编写终止证明：首先，写下允许"
" Lean 验证终止的命题，然后证明它们。否则，可能会投入大量精力来证明命题，却发现它们并不是建立递归调用在较小输入上的所需内容。"

#: src/programs-proofs/inequalities.md:575
#, fuzzy
msgid ""
"The `sorry` tactic can prove any goal, even false ones. It isn't intended "
"for use in production code or final proofs, but it is a convenient way to "
"\"sketch out\" a proof or program ahead of time. Any definitions or theorems"
" that use `sorry` are annotated with a warning."
msgstr ""
"`sorry` 战术可以证明任何目标，即使是错误的目标。它不适用于生产代码或最终证明，但它是一种方便的方法，可以提前“勾勒出”证明或程序。任何使用 "
"`sorry` 的定义或定理都会附有警告。"

#: src/programs-proofs/inequalities.md:579
#, fuzzy
msgid ""
"The initial sketch of `mergeSort`'s termination argument that uses `sorry` "
"can be written by copying the goals that Lean couldn't prove into "
"`have`\\-expressions. In Lean, `have` is similar to `let`. When using "
"`have`, the name is optional. Typically, `let` is used to define names that "
"refer to interesting values, while `have` is used to locally prove "
"propositions that can be found when Lean is searching for evidence that an "
"array lookup is in-bounds or that a function terminates."
msgstr ""
"使用 `sorry` 的 `mergeSort` 终止论证的初始草图可以通过将 Lean 无法证明的目标复制到 `have` 表达式中来编写。在 "
"Lean 中，`have` 类似于 `let`。使用 `have` 时，名称是可选的。通常，`let` 用于定义引用有趣值的名称，而 `have` "
"用于局部证明命题，当 Lean 寻找数组查找是否在范围内或函数是否终止的证据时，可以找到这些命题。"

#: src/programs-proofs/inequalities.md:598
#, fuzzy
msgid "The warning is located on the name `mergeSort`:"
msgstr "警告位于名称 `mergeSort` 上："

#: src/programs-proofs/inequalities.md:602
#, fuzzy
msgid ""
"Because there are no errors, the proposed propositions are enough to "
"establish termination."
msgstr "因为没有错误，所以建议的命题足以建立终止。"

#: src/programs-proofs/inequalities.md:604
#, fuzzy
msgid "The proofs begin by applying the helper theorems:"
msgstr "证明从应用辅助定理开始："

#: src/programs-proofs/inequalities.md:620
#, fuzzy
msgid ""
"Both proofs fail, because `splitList_shorter_fst` and "
"`splitList_shorter_snd` both require a proof that `xs.length ≥ 2`:"
msgstr ""
"两个证明都失败了，因为 `splitList_shorter_fst` 和 `splitList_shorter_snd` 都需要证明 "
"`xs.length ≥ 2`："

#: src/programs-proofs/inequalities.md:631
#, fuzzy
msgid ""
"To check that this will be enough to complete the proof, add it using "
"`sorry` and check for errors:"
msgstr "要检查这是否足以完成证明，请使用 `sorry` 添加它并检查错误："

#: src/programs-proofs/inequalities.md:650
#, fuzzy
msgid "Once again, there is only a warning."
msgstr "同样，只会有一个警告。"

#: src/programs-proofs/inequalities.md:655
#, fuzzy
msgid ""
"There is one promising assumption available: `h : ¬List.length xs < 2`, "
"which comes from the `if`. Clearly, if it is not the case that `xs.length < "
"2`, then `xs.length ≥ 2`. The Lean library provides this theorem under the "
"name `Nat.ge_of_not_lt`. The program is now complete:"
msgstr ""
"有一个有希望的假设可用：`h : ¬List.length xs < 2`，它来自 `if`。显然，如果不是 `xs.length < 2`，那么 "
"`xs.length ≥ 2`。Lean 库以 `Nat.ge_of_not_lt` 的名称提供了此定理。程序现在已完成："

#: src/programs-proofs/inequalities.md:680
#, fuzzy
msgid "The function can be tested on examples:"
msgstr "该函数可以在示例上进行测试："

#: src/programs-proofs/inequalities.md:681
msgid ""
"```lean\n"
"#eval mergeSort [\"soapstone\", \"geode\", \"mica\", \"limestone\"]\n"
"```"
msgstr ""

#: src/programs-proofs/inequalities.md:684
msgid ""
"```output info\n"
"[\"geode\", \"limestone\", \"mica\", \"soapstone\"]\n"
"```"
msgstr ""

#: src/programs-proofs/inequalities.md:694
#, fuzzy
msgid "Division as Iterated Subtraction"
msgstr "除法作为迭代减法"

#: src/programs-proofs/inequalities.md:696
#, fuzzy
msgid ""
"Just as multiplication is iterated addition and exponentiation is iterated "
"multiplication, division can be understood as iterated subtraction. The "
"[very first description of recursive functions in this book](../getting-to-"
"know/datatypes-and-patterns.md#recursive-functions) presents a version of "
"division that terminates when the divisor is not zero, but that Lean does "
"not accept. Proving that division terminates requires the use of a fact "
"about inequalities."
msgstr ""
"正如乘法是迭代加法，指数是迭代乘法，除法可以理解为迭代减法。[本书中对递归函数的第一个描述](../getting-to-know/datatypes-"
"and-patterns.md#recursive-functions)给出了一个除法版本，当除数不为零时终止，但 Lean "
"并不接受。证明除法终止需要使用关于不等式的事实。"

#: src/programs-proofs/inequalities.md:700
#, fuzzy
msgid ""
"The first step is to refine the definition of division so that it requires "
"evidence that the divisor is not zero:"
msgstr "第一步是细化除法的定义，使其需要证据证明除数不为零："

#: src/programs-proofs/inequalities.md:708
#, fuzzy
msgid ""
"The error message is somewhat longer, due to the additional argument, but it"
" contains essentially the same information:"
msgstr "由于增加了参数，错误信息会稍长一些，但它包含基本相同的信息："

#: src/programs-proofs/inequalities.md:736
#, fuzzy
msgid ""
"This definition of `div` terminates because the first argument `n` is "
"smaller on each recursive call. This can be expressed using a "
"`termination_by` clause:"
msgstr "`div` 的这个定义终止，因为第一个参数 `n` 在每次递归调用时都更小。这可以使用 `termination_by` 子句来表示："

#: src/programs-proofs/inequalities.md:746
#, fuzzy
msgid "Now, the error is confined to the recursive call:"
msgstr "现在，错误仅限于递归调用："

#: src/programs-proofs/inequalities.md:758
#, fuzzy
msgid ""
"This can be proved using a theorem from the standard library, `Nat.sub_lt`. "
"This theorem states that `∀ {n k : Nat}, 0 < n → 0 < k → n - k < n` (the "
"curly braces indicate that `n` and `k` are implicit arguments). Using this "
"theorem requires demonstrating that both `n` and `k` are greater than zero. "
"Because `k > 0` is syntactic sugar for `0 < k`, the only necessary goal is "
"to show that `0 < n`. There are two possibilities: either `n` is `0`, or it "
"is `n' + 1` for some other `Nat` `n'`. But `n` cannot be `0`. The fact that "
"the `if` selected the second branch means that `¬ n < k`, but if `n = 0` and"
" `k > 0` then `n` must be less than `k`, which would be a contradiction. "
"This, `n = Nat.succ n'`, and `Nat.succ n'` is clearly greater than `0`."
msgstr ""
"这可以使用标准库中的定理 `Nat.sub_lt` 来证明。该定理指出 `∀ {n k : Nat}, 0 < n → 0 < k → n - k < "
"n`（花括号表示 `n` 和 `k` 是隐式参数）。使用此定理需要证明 `n` 和 `k` 都大于零。因为 `k > 0` 是 `0 < k` "
"的语法糖，所以唯一必要的目标是证明 `0 < n`。有两种可能性：`n` 为 `0`，或它为某个其他 `Nat` `n'` 的 `n' + 1`。但 "
"`n` 不能为 `0`。`if` 选择第二个分支的事实意味着 `¬ n < k`，但如果 `n = 0` 且 `k > 0`，则 `n` 必须小于 "
"`k`，这将是一个矛盾。这，`n = Nat.succ n'`，并且 `Nat.succ n'` 明显大于 `0`。"

#: src/programs-proofs/inequalities.md:767
#, fuzzy
msgid "The full definition of `div`, including the termination proof, is:"
msgstr "`div` 的完整定义，包括终止证明："

#: src/programs-proofs/inequalities.md:786
#, fuzzy
msgid "Prove the following theorems:"
msgstr "证明以下定理："

#: src/programs-proofs/inequalities.md:788
#, fuzzy
msgid "For all natural numbers \\\\( n \\\\), \\\\( 0 \\< n + 1 \\\\)."
msgstr "对于所有自然数 \\\\( n \\\\)，\\\\( 0 \\< n + 1 \\\\)。"

#: src/programs-proofs/inequalities.md:789
#, fuzzy
msgid "For all natural numbers \\\\( n \\\\), \\\\( 0 \\\\leq n \\\\)."
msgstr "对于所有自然数 \\\\( n \\\\)，\\\\( 0 \\\\leq n \\\\)。"

#: src/programs-proofs/inequalities.md:790
#, fuzzy
msgid "For all natural numbers \\\\( n \\\\) and \\\\( k \\\\), \\\\( (n + 1) - (k + 1) = n - k \\\\)"
msgstr "对于所有自然数 \\\\( n \\\\) 和 \\\\( k \\\\)，\\\\( (n + 1) - (k + 1) = n - k \\\\)"

#: src/programs-proofs/inequalities.md:791
#, fuzzy
msgid "For all natural numbers \\\\( n \\\\) and \\\\( k \\\\), if \\\\( k \\< n \\\\) then \\\\( n \\neq 0 \\\\)"
msgstr "对于所有自然数 \\\\( n \\\\) 和 \\\\( k \\\\)，如果 \\\\( k \\< n \\\\)，则 \\\\( n \\neq 0 \\\\)"

#: src/programs-proofs/inequalities.md:792
#, fuzzy
msgid "For all natural numbers \\\\( n \\\\), \\\\( n - n = 0 \\\\)"
msgstr "对于所有自然数 \\\\( n \\\\)，\\\\( n - n = 0 \\\\)"

#: src/programs-proofs/inequalities.md:793
#, fuzzy
msgid ""
"For all natural numbers \\\\( n \\\\) and \\\\( k \\\\), if \\\\( n + 1 \\< "
"k \\\\) then \\\\( n \\< k \\\\)"
msgstr "对于所有自然数 \\\\( n \\\\) 和 \\\\( k \\\\)，如果 \\\\( n + 1 \\< k \\\\)，则 \\\\( n \\< k \\\\)"
