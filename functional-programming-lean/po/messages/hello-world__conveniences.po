#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/hello-world/conveniences.md:4
msgid "Nested Actions"
msgstr "嵌套操作"

#: src/hello-world/conveniences.md:6
msgid ""
"Many of the functions in `feline` exhibit a repetitive pattern in which an "
"`IO` action's result is given a name, and then used immediately and only "
"once. For instance, in `dump`:"
msgstr ""
"`feline` 中的许多函数都表现出一种重复模式，其中 `IO` 操作的结果被赋予一个名称，然后立即且仅使用一次。例如，在 `dump` 中："

#: src/hello-world/conveniences.md:18
msgid "the pattern occurs for `stdout`:"
msgstr "模式发生在 `stdout` 中："

#: src/hello-world/conveniences.md:23
msgid "Similarly, `fileStream` contains the following snippet:"
msgstr "同样，`fileStream` 包含以下代码段："

#: src/hello-world/conveniences.md:29
msgid ""
"When Lean is compiling a `do` block, expressions that consist of a left "
"arrow immediately under parentheses are lifted to the nearest enclosing "
"`do`, and their results are bound to a unique name. This unique name "
"replaces the origin of the expression. This means that `dump` can also be "
"written as follows:"
msgstr ""
"当 Lean 编译 `do` 块时，由括号下方的左箭头组成的表达式会被提升到最近的封闭 `do` "
"中，并且其结果会被绑定到一个唯一名称。这个唯一名称替换了表达式的来源。这意味着 `dump` 也可以写成如下形式："

#: src/hello-world/conveniences.md:41
msgid ""
"This version of `dump` avoids introducing names that are used only once, "
"which can greatly simplify a program. `IO` actions that Lean lifts from a "
"nested expression context are called _nested actions_."
msgstr ""
"此版本的 `dump` 避免了引入仅使用一次的名称，这可以极大地简化程序。Lean 从嵌套表达式上下文中提升的 `IO` 操作称为 _嵌套操作_。"

#: src/hello-world/conveniences.md:44
msgid "`fileStream` can be simplified using the same technique:"
msgstr "`fileStream` 可以使用相同的技术进行简化："

#: src/hello-world/conveniences.md:45
msgid ""
"```lean\n"
"def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do\n"
"  if not (← filename.pathExists) then\n"
"    (← IO.getStderr).putStrLn s!\"File not found: {filename}\"\n"
"    pure none\n"
"  else\n"
"    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read\n"
"    pure (some (IO.FS.Stream.ofHandle handle))\n"
"```"
msgstr ""
"```lean\n"
"def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do\n"
"  if not (← filename.pathExists) then\n"
"    (← IO.getStderr).putStrLn s!\"文件未找到: {filename}\"\n"
"    pure none\n"
"  else\n"
"    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read\n"
"    pure (some (IO.FS.Stream.ofHandle handle))\n"
"```"

#: src/hello-world/conveniences.md:54
#, fuzzy
msgid ""
"In this case, the local name of `handle` could also have been eliminated "
"using nested actions, but the resulting expression would have been long and "
"complicated. Even though it's often good style to use nested actions, it can"
" still sometimes be helpful to name intermediate results."
msgstr ""
"在这种情况下，局部名称“handle”也可以使用嵌套操作来消除，但由此产生的表达式会很长且复杂。尽管使用嵌套操作通常是一种良好的风格，但有时对中间结果进行命名仍然很有帮助。"

#: src/hello-world/conveniences.md:57
#, fuzzy
msgid ""
"It is important to remember, however, that nested actions are only a shorter"
" notation for `IO` actions that occur in a surrounding `do` block. The side "
"effects that are involved in executing them still occur in the same order, "
"and execution of side effects is not interspersed with the evaluation of "
"expressions. For an example of where this might be confusing, consider the "
"following helper definitions that return data after announcing to the world "
"that they have been executed:"
msgstr ""
"然而，重要的是要记住，嵌套操作只是对包围在“do”块中的“IO”操作的一种更短的表示法。执行它们所涉及的副作用仍然按相同的顺序发生，并且副作用的执行不会与表达式的求值交错进行。对于可能令人困惑的示例，请考虑以下返回数据的帮助程序定义，在向世界宣布它们已执行后："

#: src/hello-world/conveniences.md:60
#, fuzzy
msgid ""
"```lean\n"
"def getNumA : IO Nat := do\n"
"  (← IO.getStdout).putStrLn \"A\"\n"
"  pure 5\n"
"\n"
"def getNumB : IO Nat := do\n"
"  (← IO.getStdout).putStrLn \"B\"\n"
"  pure 7\n"
"```"
msgstr ""
"```lean\n"
"def getNumA : IO Nat := do\n"
"  (← IO.getStdout).putStrLn \"A\"\n"
"  pure 5\n"
"\n"
"def getNumB : IO Nat := do\n"
"  (← IO.getStdout).putStrLn \"B\"\n"
"  pure 7\n"
"```"

#: src/hello-world/conveniences.md:69
#, fuzzy
msgid ""
"These definitions are intended to stand in for more complicated `IO` code "
"that might validate user input, read a database, or open a file."
msgstr "这些定义旨在代表更复杂的“IO”代码，这些代码可能验证用户输入、读取数据库或打开文件。"

#: src/hello-world/conveniences.md:71
#, fuzzy
msgid ""
"A program that prints `0` when number A is five, or number `B` otherwise, "
"can be written as follows:"
msgstr "当数字 A 为 5 时打印“0”，否则打印数字“B”的程序可以写成如下形式："

#: src/hello-world/conveniences.md:72
#, fuzzy
msgid ""
"```lean\n"
"def test : IO Unit := do\n"
"  let a : Nat := if (← getNumA) == 5 then 0 else (← getNumB)\n"
"  (← IO.getStdout).putStrLn s!\"The answer is {a}\"\n"
"```"
msgstr ""
"```lean\n"
"def test : IO Unit := do\n"
"  let a : Nat := if (← getNumA) == 5 then 0 else (← getNumB)\n"
"  (← IO.getStdout).putStrLn s!\"The answer is {a}\"\n"
"```"

#: src/hello-world/conveniences.md:77
#, fuzzy
msgid ""
"However, this program probably has more side effects (such as prompting for "
"user input or reading a database) than was intended. The definition of "
"`getNumA` makes it clear that it will always return `5`, and thus the "
"program should not read number B. However, running the program results in "
"the following output:"
msgstr ""
"但是，此程序可能具有比预期更多的副作用（例如提示用户输入或读取数据库）。`getNumA` 的定义明确指出它将始终返回“5”，因此程序不应读取数字 "
"B。但是，运行程序会产生以下输出："

#: src/hello-world/conveniences.md:85
#, fuzzy
msgid ""
"`getNumB` was executed because `test` is equivalent to this definition:"
msgstr "`getNumB` 被执行是因为 `test` 等价于这个定义："

#: src/hello-world/conveniences.md:86
#, fuzzy
msgid ""
"```lean\n"
"def test : IO Unit := do\n"
"  let x ← getNumA\n"
"  let y ← getNumB\n"
"  let a : Nat := if x == 5 then 0 else y\n"
"  (← IO.getStdout).putStrLn s!\"The answer is {a}\"\n"
"```"
msgstr ""
"```lean\n"
"def test : IO Unit := do\n"
"  let x ← getNumA\n"
"  let y ← getNumB\n"
"  let a : Nat := if x == 5 then 0 else y\n"
"  (← IO.getStdout).putStrLn s!\"The answer is {a}\"\n"
"```"

#: src/hello-world/conveniences.md:93
#, fuzzy
msgid ""
"This is due to the rule that nested actions are lifted to the _closest "
"enclosing_ `do` block. The branches of the `if` were not implicitly wrapped "
"in `do` blocks because the `if` is not itself a statement in the `do` "
"block—the statement is the `let` that defines `a`. Indeed, they could not be"
" wrapped this way, because the type of the conditional expression is `Nat`, "
"not `IO Nat`."
msgstr ""
"这是因为嵌套动作被提升到最接近的包含 `do` 块的规则。`if` 的分支没有被隐式地包装在 `do` 块中，因为 `if` 本身不是 `do` "
"块中的语句——语句是定义 `a` 的 `let`。事实上，它们不能这样包装，因为条件表达式的类型是 `Nat`，而不是 `IO Nat`。"

#: src/hello-world/conveniences.md:97
#, fuzzy
msgid "Flexible Layouts for `do`"
msgstr "`do` 的灵活布局"

#: src/hello-world/conveniences.md:99
#, fuzzy
msgid ""
"In Lean, `do` expressions are whitespace-sensitive. Each `IO` action or "
"local binding in the `do` is expected to start on its own line, and they "
"should all have the same indentation. Almost all uses of `do` should be "
"written this way. In some rare contexts, however, manual control over "
"whitespace and indentation may be necessary, or it may be convenient to have"
" multiple small actions on a single line. In these cases, newlines can be "
"replaced with a semicolon and indentation can be replaced with curly braces."
msgstr ""
"在 Lean 中，`do` 表达式对空格敏感。`do` 中的每个 `IO` 动作或局部绑定都应该从自己的行开始，并且它们都应该有相同的缩进。几乎所有 "
"`do` "
"的用法都应该这样写。然而，在一些罕见的情况下，可能需要手动控制空格和缩进，或者在单行上有多个小动作可能很方便。在这些情况下，换行符可以用分号替换，缩进可以用花括号替换。"

#: src/hello-world/conveniences.md:105
#, fuzzy
msgid "For instance, all of the following programs are equivalent:"
msgstr "例如，以下所有程序都是等价的："

#: src/hello-world/conveniences.md:106
#, fuzzy
msgid ""
"```lean\n"
"-- This version uses only whitespace-sensitive layout\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let name := (← stdin.getLine).trim\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"\n"
"-- This version is as explicit as possible\n"
"def main : IO Unit := do {\n"
"  let stdin ← IO.getStdin;\n"
"  let stdout ← IO.getStdout;\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\";\n"
"  let name := (← stdin.getLine).trim;\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"}\n"
"\n"
"-- This version uses a semicolon to put two actions on the same line\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin; let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let name := (← stdin.getLine).trim\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"-- 这个版本只使用空格敏感的布局\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let name := (← stdin.getLine).trim\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"\n"
"-- 这个版本尽可能明确\n"
"def main : IO Unit := do {\n"
"  let stdin ← IO.getStdin;\n"
"  let stdout ← IO.getStdout;\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\";\n"
"  let name := (← stdin.getLine).trim;\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"}\n"
"\n"
"-- 这个版本使用分号将两个动作放在同一行\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin; let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let name := (← stdin.getLine).trim\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/conveniences.md:135
#, fuzzy
msgid "Idiomatic Lean code uses curly braces with `do` very rarely."
msgstr "Idiomatic Lean 代码极少使用带有 `do` 的大括号。"

#: src/hello-world/conveniences.md:137
#, fuzzy
msgid "Running `IO` Actions With `#eval`"
msgstr "使用 `#eval` 运行 `IO` 动作"

#: src/hello-world/conveniences.md:139
#, fuzzy
msgid ""
"Lean's `#eval` command can be used to execute `IO` actions, rather than just"
" evaluating them. Normally, adding a `#eval` command to a Lean file causes "
"Lean to evaluate the provided expression, convert the resulting value to a "
"string, and provide that string as a tooltip and in the info window. Rather "
"than failing because `IO` actions can't be converted to strings, `#eval` "
"executes them, carrying out their side effects. If the result of execution "
"is the `Unit` value `()`, then no result string is shown, but if it is a "
"type that can be converted to a string, then Lean displays the resulting "
"value."
msgstr ""
"Lean 的 `#eval` 命令可用于执行 `IO` 动作，而不仅仅是评估它们。通常，向 Lean 文件添加 `#eval` 命令会导致 Lean "
"评估提供的表达式，将结果值转换为字符串，并在工具提示和信息窗口中提供该字符串。`#eval` 不会因为 `IO` "
"动作无法转换为字符串而失败，而是执行它们，执行它们的副作用。如果执行结果是 `Unit` 值 "
"`()`，则不显示结果字符串，但如果它是可以转换为字符串的类型，则 Lean 会显示结果值。"

#: src/hello-world/conveniences.md:144
#, fuzzy
msgid ""
"This means that, given the prior definitions of `countdown` and "
"`runActions`,"
msgstr "这意味着，给定 `countdown` 和 `runActions` 的先前定义，"

#: src/hello-world/conveniences.md:148
#, fuzzy
msgid "displays"
msgstr "显示"

#: src/hello-world/conveniences.md:155
#, fuzzy
msgid ""
"This is the output produced by running the `IO` action, rather than some "
"opaque representation of the action itself. In other words, for `IO` "
"actions, `#eval` both _evaluates_ the provided expression and _executes_ the"
" resulting action value."
msgstr ""
"这是运行 `IO` 动作产生的输出，而不是动作本身的不透明表示。换句话说，对于 `IO` 动作，`#eval` "
"既_评估_提供的表达式，又_执行_结果动作值。"

#: src/hello-world/conveniences.md:158
#, fuzzy
msgid ""
"Quickly testing `IO` actions with `#eval` can be much more convenient that "
"compiling and running whole programs. However, there are some limitations. "
"For instance, reading from standard input simply returns empty input. "
"Additionally, the `IO` action is re-executed whenever Lean needs to update "
"the diagnostic information that it provides to users, and this can happen at"
" unpredictable times. An action that reads and writes files, for instance, "
"may do so at inconvenient times."
msgstr ""
"使用 `#eval` 快速测试 `IO` 动作比编译和运行整个程序方便得多。但是，有一些限制。例如，从标准输入读取只会返回空输入。此外，每当 Lean "
"需要更新它提供给用户的诊断信息时，`IO` 动作都会重新执行，这可能会在不可预测的时间发生。例如，读取和写入文件的动作可能会在不方便的时间执行。"
