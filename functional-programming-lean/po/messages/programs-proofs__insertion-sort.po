#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/programs-proofs/insertion-sort.md:3
#, fuzzy
msgid ""
"While insertion sort does not have the optimal worst-case time complexity "
"for a sorting algorithm, it still has a number of useful properties:"
msgstr "虽然插入排序没有排序算法最优的糟糕情况时间复杂度，但它仍然有一些有用的属性："

#: src/programs-proofs/insertion-sort.md:4
#, fuzzy
msgid "It is simple and straightforward to implement and understand"
msgstr "它简单明了，易于实现和理解"

#: src/programs-proofs/insertion-sort.md:5
#, fuzzy
msgid "It is an in-place algorithm, requiring no additional space to run"
msgstr "它是一种就地算法，不需要额外的空间来运行"

#: src/programs-proofs/insertion-sort.md:6
#, fuzzy
msgid "It is a stable sort"
msgstr "它是一种稳定的排序"

#: src/programs-proofs/insertion-sort.md:7
#, fuzzy
msgid "It is fast when the input is already almost sorted"
msgstr "当输入几乎已经排序时，它很快"

#: src/programs-proofs/insertion-sort.md:9
#, fuzzy
msgid ""
"In-place algorithms are particularly useful in Lean due to the way it "
"manages memory. In some cases, operations that would normally copy an array "
"can be optimized into mutation. This includes swapping elements in an array."
msgstr "就地算法在 Lean 中特别有用，因为它管理内存的方式。在某些情况下，通常会复制数组的操作可以优化为变异。这包括交换数组中的元素。"

#: src/programs-proofs/insertion-sort.md:13
#, fuzzy
msgid ""
"Most languages and run-time systems with automatic memory management, "
"including JavaScript, the JVM, and .NET, use tracing garbage collection. "
"When memory needs to be reclaimed, the system starts at a number of _roots_ "
"(such as the call stack and global values) and then determines which values "
"can be reached by recursively chasing pointers. Any values that can't be "
"reached are deallocated, freeing memory."
msgstr ""
"大多数语言和具有自动内存管理的运行时系统，包括 JavaScript、JVM 和 .NET，都使用跟踪垃圾回收。当需要回收内存时，系统从许多 "
"_根_（例如调用堆栈和全局值）开始，然后通过递归地追逐指针来确定可以到达哪些值。任何无法到达的值都会被释放，从而释放内存。"

#: src/programs-proofs/insertion-sort.md:17
#, fuzzy
msgid ""
"Reference counting is an alternative to tracing garbage collection that is "
"used by a number of languages, including Python, Swift, and Lean. In a "
"system with reference counting, each object in memory has a field that "
"tracks how many references there are to it. When a new reference is "
"established, the counter is incremented. When a reference ceases to exist, "
"the counter is decremented. When the counter reaches zero, the object is "
"immediately deallocated."
msgstr ""
"引用计数是追踪垃圾回收的替代方法，它被许多语言使用，包括 Python、Swift 和 "
"Lean。在引用计数系统中，内存中的每个对象都有一个字段来跟踪对它的引用数。当建立一个新引用时，计数器会增加。当一个引用不再存在时，计数器会减少。当计数器达到零时，对象会立即被释放。"

#: src/programs-proofs/insertion-sort.md:23
#, fuzzy
msgid ""
"Reference counting has one major disadvantage compared to a tracing garbage "
"collector: circular references can lead to memory leaks. If object \\\\( A "
"\\\\) references object \\\\( B \\\\) , and object \\\\( B \\\\) references "
"object \\\\( A \\\\), they will never be deallocated, even if nothing else "
"in the program references either \\\\( A \\\\) or \\\\( B \\\\). Circular "
"references result either from uncontrolled recursion or from mutable "
"references. Because Lean supports neither, it is impossible to construct "
"circular references."
msgstr ""
"与追踪垃圾回收器相比，引用计数有一个主要的缺点：循环引用会导致内存泄漏。如果对象 \\\\( A \\\\) 引用对象 \\\\( B "
"\\\\)，而对象 \\\\( B \\\\) 引用对象 \\\\( A \\\\)，它们将永远不会被释放，即使程序中没有其他内容引用 \\\\( A "
"\\\\) 或 \\\\( B \\\\)。循环引用要么是由不受控制的递归引起的，要么是由可变引用引起的。由于 Lean "
"不支持这两者，因此不可能构造循环引用。"

#: src/programs-proofs/insertion-sort.md:28
#, fuzzy
msgid ""
"Reference counting means that the Lean runtime system's primitives for "
"allocating and deallocating data structures can check whether a reference "
"count is about to fall to zero, and re-use an existing object instead of "
"allocating a new one. This is particularly important when working with large"
" arrays."
msgstr ""
"引用计数意味着 Lean "
"运行时系统用于分配和释放数据结构的原语可以检查引用计数是否即将降至零，并重新使用现有对象而不是分配一个新对象。当使用大型数组时，这一点尤其重要。"

#: src/programs-proofs/insertion-sort.md:32
#, fuzzy
msgid ""
"An implementation of insertion sort for Lean arrays should satisfy the "
"following criteria:"
msgstr "针对 Lean 数组的插入排序实现应满足以下条件："

#: src/programs-proofs/insertion-sort.md:33
#, fuzzy
msgid "Lean should accept the function without a `partial` annotation"
msgstr "Lean 应接受没有 `partial` 注释的函数"

#: src/programs-proofs/insertion-sort.md:34
#, fuzzy
msgid ""
"If passed an array to which there are no other references, it should modify "
"the array in-place rather than allocating a new one"
msgstr "如果传递了一个没有其他引用的数组，它应就地修改数组，而不是分配一个新数组"

#: src/programs-proofs/insertion-sort.md:36
#, fuzzy
msgid ""
"The first criterion is easy to check: if Lean accepts the definition, then "
"it is satisfied. The second, however, requires a means of testing it. Lean "
"provides a built-in function called `dbgTraceIfShared` with the following "
"signature:"
msgstr ""
"第一个条件很容易检查：如果 Lean 接受该定义，则满足该条件。然而，第二个条件需要一种测试方法。Lean 提供了一个名为 "
"`dbgTraceIfShared` 的内置函数，其签名如下："

#: src/programs-proofs/insertion-sort.md:45
#, fuzzy
msgid ""
"It takes a string and a value as arguments, and prints a message that uses "
"the string to standard error if the value has more than one reference, "
"returning the value. This is not, strictly speaking, a pure function. "
"However, it is intended to be used only during development to check that a "
"function is in fact able to re-use memory rather than allocating and "
"copying."
msgstr ""
"它以一个字符串和一个值作为参数，如果该值有多个引用，则使用该字符串打印一条消息到标准错误，并返回该值。严格来说，这不是一个纯函数。但是，它仅在开发期间用于检查函数实际上能够重用内存而不是分配和复制。"

#: src/programs-proofs/insertion-sort.md:49
#, fuzzy
msgid ""
"When learning to use `dbgTraceIfShared`, it's important to know that `#eval`"
" will report that many more values are shared than in compiled code. This "
"can be confusing. It's important to build an executable with `lake` rather "
"than experimenting in an editor."
msgstr ""
"在学习使用 `dbgTraceIfShared` 时，重要的是要知道 `#eval` 会报告比已编译代码中共享的更多值。这可能会令人困惑。重要的是使用 "
"`lake` 构建可执行文件，而不是在编辑器中进行实验。"

#: src/programs-proofs/insertion-sort.md:53
#, fuzzy
msgid ""
"Insertion sort consists of two loops. The outer loop moves a pointer from "
"left to right across the array to be sorted. After each iteration, the "
"region of the array to the left of the pointer is sorted, while the region "
"to the right may not yet be sorted. The inner loop takes the element pointed"
" to by the pointer and moves it to the left until the appropriate location "
"has been found and the loop invariant has been restored. In other words, "
"each iteration inserts the next element of the array into the appropriate "
"location in the sorted region."
msgstr ""
"插入排序由两个循环组成。外循环将指针从左向右移动到要排序的数组中。每次迭代后，指针左边的数组区域都会被排序，而右边的区域可能尚未被排序。内循环获取指针指向的元素，并将其向左移动，直到找到合适的位置并恢复循环不变式。换句话说，每次迭代都会将数组的下一个元素插入到已排序区域的合适位置。"

#: src/programs-proofs/insertion-sort.md:59
#, fuzzy
msgid "The Inner Loop"
msgstr "内循环"

#: src/programs-proofs/insertion-sort.md:61
#, fuzzy
msgid ""
"The inner loop of insertion sort can be implemented as a tail-recursive "
"function that takes the array and the index of the element being inserted as"
" arguments. The element being inserted is repeatedly swapped with the "
"element to its left until either the element to the left is smaller or the "
"beginning of the array is reached. The inner loop is structurally recursive "
"on the `Nat` that is inside the `Fin` used to index into the array:"
msgstr ""
"插入排序的内循环可以实现为一个尾递归函数，该函数将数组和要插入的元素的索引作为参数。要插入的元素会与它左边的元素反复交换，直到左边的元素更小或到达数组的开头。内循环在用于对数组进行索引的"
" `Fin` 中的 `Nat` 上进行结构递归："

#: src/programs-proofs/insertion-sort.md:76
#, fuzzy
msgid ""
"If the index `i` is `0`, then the element being inserted into the sorted "
"region has reached the beginning of the region and is the smallest. If the "
"index is `i' + 1`, then the element at `i'` should be compared to the "
"element at `i`. Note that while `i` is a `Fin arr.size`, `i'` is just a "
"`Nat` because it results from the `val` field of `i`. It is thus necessary "
"to prove that `i' < arr.size` before `i'` can be used to index into `arr`."
msgstr ""
"如果索引 `i` 为 `0`，则插入到已排序区域的元素已到达该区域的开头，并且是最小的。如果索引为 `i' + 1`，则应将 `i'` 处的元素与 "
"`i` 处的元素进行比较。请注意，虽然 `i` 是 `Fin arr.size`，但 `i'` 只是一个 `Nat`，因为它是由 `i` 的 `val`"
" 字段产生的。因此，在使用 `i'` 对 `arr` 进行索引之前，有必要证明 `i' < arr.size`。"

#: src/programs-proofs/insertion-sort.md:81
#, fuzzy
msgid ""
"Omitting the `have`\\-expression with the proof that `i' < arr.size` reveals"
" the following goal:"
msgstr "省略带有证明 `i' < arr.size` 的 `have` 表达式，将显示以下目标："

#: src/programs-proofs/insertion-sort.md:93
#, fuzzy
msgid ""
"The hint `Nat.lt_of_succ_lt` is a theorem from Lean's standard library. Its "
"signature, found by `#check Nat.lt_of_succ_lt`, is"
msgstr ""
"提示 `Nat.lt_of_succ_lt` 是 Lean 标准库中的一个定理。它的签名，通过 `#check Nat.lt_of_succ_lt` "
"找到，是"

#: src/programs-proofs/insertion-sort.md:98
#, fuzzy
msgid ""
"In other words, it states that if `n + 1 < m`, then `n < m`. The `*` passed "
"to `simp` causes it to combine `Nat.lt_of_succ_lt` with the `isLt` field "
"from `i` to get the final proof."
msgstr ""
"换句话说，它指出如果 `n + 1 < m`，则 `n < m`。传递给 `simp` 的 `*` 导致它将 `Nat.lt_of_succ_lt` 与"
" `i` 中的 `isLt` 字段结合起来以获得最终证明。"

#: src/programs-proofs/insertion-sort.md:101
#, fuzzy
msgid ""
"Having established that `i'` can be used to look up the element to the left "
"of the element being inserted, the two elements are looked up and compared."
"  If the element to the left is less than or equal to the element being "
"inserted, then the loop is finished and the invariant has been restored. If "
"the element to the left is greater than the element being inserted, then the"
" elements are swapped and the inner loop begins again. `Array.swap` takes "
"both of its indices as `Fin`s, and the `by assumption` that establishes that"
" `i' < arr.size` makes use of the `have`. The index to be examined on the "
"next round through the inner loop is also `i'`, but `by assumption` is not "
"sufficient in this case. This is because the proof was written for the "
"original array `arr`, not the result of swapping two elements. The `simp` "
"tactic's database contains the fact that swapping two elements of an array "
"doesn't change its size, and the `[*]` argument instructs it to additionally"
" use the assumption introduced by `have`."
msgstr ""
"在确定 `i'` "
"可用于查找要插入元素左侧的元素后，查找并比较这两个元素。如果左侧元素小于或等于要插入的元素，则循环结束并且不变量已恢复。如果左侧元素大于要插入的元素，则交换元素并重新开始内部循环。`Array.swap`"
" 将其两个索引都作为 `Fin`，并且建立 `i' < arr.size` 的 `by assumption` 利用了 "
"`have`。在内部循环的下一轮中要检查的索引也是 `i'`，但在这种情况下 `by assumption` 并不足够。这是因为该证明是针对原始数组 "
"`arr` 编写的，而不是交换两个元素的结果。`simp` 战术的数据库包含这样一个事实：交换数组的两个元素不会改变其大小，并且 `[*]` "
"参数指示它另外使用 `have` 引入的假设。"

#: src/programs-proofs/insertion-sort.md:109
#, fuzzy
msgid "The Outer Loop"
msgstr "外层循环"

#: src/programs-proofs/insertion-sort.md:111
#, fuzzy
msgid ""
"The outer loop of insertion sort moves the pointer from left to right, "
"invoking `insertSorted` at each iteration to insert the element at the "
"pointer into the correct position in the array. The basic form of the loop "
"resembles the implementation of `Array.map`:"
msgstr ""
"插入排序的外层循环将指针从左向右移动，在每次迭代中调用 `insertSorted` 将指针处的元素插入到数组中的正确位置。循环的基本形式类似于 "
"`Array.map` 的实现："

#: src/programs-proofs/insertion-sort.md:120
#, fuzzy
msgid ""
"The resulting error is also the same as the error that occurs without a "
"`termination_by` clause on `Array.map`, because there is no argument that "
"decreases at every recursive call:"
msgstr ""
"产生的错误也与在 `Array.map` 上没有 `termination_by` 子句时发生的错误相同，因为没有参数在每次递归调用时都会减少："

#: src/programs-proofs/insertion-sort.md:134
#, fuzzy
msgid ""
"Before constructing the termination proof, it can be convenient to test the "
"definition with a `partial` modifier to make sure that it returns the "
"expected answers:"
msgstr "在构建终止证明之前，可以使用 `partial` 修饰符测试定义以确保它返回预期的答案："

#: src/programs-proofs/insertion-sort.md:148
msgid ""
"```lean\n"
"#eval insertionSortLoop #[\"metamorphic\", \"igneous\", \"sedentary\"] 0\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:151
msgid ""
"```output info\n"
"#[\"igneous\", \"metamorphic\", \"sedentary\"]\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:155
#, fuzzy
msgid "Termination"
msgstr "终止"

#: src/programs-proofs/insertion-sort.md:157
#, fuzzy
msgid ""
"Once again, the function terminates because the difference between the index"
" and the size of the array being processed decreases on each recursive call."
" This time, however, Lean does not accept the `termination_by`:"
msgstr ""
"同样，该函数终止是因为正在处理的数组的索引和大小之间的差异在每次递归调用时都会减小。然而，这一次，Lean 不接受 `termination_by`："

#: src/programs-proofs/insertion-sort.md:179
#, fuzzy
msgid ""
"The problem is that Lean has no way to know that `insertSorted` returns an "
"array that's the same size as the one it is passed. In order to prove that "
"`insertionSortLoop` terminates, it is necessary to first prove that "
"`insertSorted` doesn't change the size of the array. Copying the unproved "
"termination condition from the error message to the function and \"proving\""
" it with `sorry` allows the function to be temporarily accepted:"
msgstr ""
"问题在于 Lean 无法知道 `insertSorted` 返回的数组与传递给它的数组大小相同。为了证明 `insertionSortLoop` "
"终止，有必要首先证明 `insertSorted` 不会改变数组的大小。将未经证实的终止条件从错误消息复制到函数中，并使用 `sorry` "
"“证明”它，可以暂时接受该函数："

#: src/programs-proofs/insertion-sort.md:196
#, fuzzy
msgid ""
"Because `insertSorted` is structurally recursive on the index of the element"
" being inserted, the proof should be by induction on the index. In the base "
"case, the array is returned unchanged, so its length certainly does not "
"change. For the inductive step, the induction hypothesis is that a recursive"
" call on the next smaller index will not change the length of the array. "
"There are two cases two consider: either the element has been fully inserted"
" into the sorted region and the array is returned unchanged, in which case "
"the length is also unchanged, or the element is swapped with the next one "
"before the recursive call. However, swapping two elements in an array "
"doesn't change the size of it, and the induction hypothesis states that the "
"recursive call with the next index returns an array that's the same size as "
"its argument. Thus, the size remains unchanged."
msgstr ""
"因为 `insertSorted` "
"在要插入的元素的索引上是结构递归的，所以证明应该是通过索引归纳进行的。在基本情况下，数组返回不变，因此其长度肯定不会改变。对于归纳步骤，归纳假设是下一个小索引上的递归调用不会改变数组的长度。有两种情况需要考虑：要么元素已完全插入到已排序区域中，并且数组返回不变，在这种情况下长度也不会改变，要么元素在递归调用之前与下一个元素交换。然而，在数组中交换两个元素不会改变它的大小，并且归纳假设指出具有下一个索引的递归调用返回的数组与其参数大小相同。因此，大小保持不变。"

#: src/programs-proofs/insertion-sort.md:203
#, fuzzy
msgid ""
"Translating this English-language theorem statement to Lean and proceeding "
"using the techniques from this chapter is enough to prove the base case and "
"make progress in the inductive step:"
msgstr "翻译此英语定理陈述为 Lean，并使用本章中的技术进行操作，足以证明基本情况并在归纳步骤中取得进展："

#: src/programs-proofs/insertion-sort.md:214
#, fuzzy
msgid ""
"The simplification using `insertSorted` in the inductive step revealed the "
"pattern match in `insertSorted`:"
msgstr "归纳步骤中使用 `insertSorted` 的简化揭示了 `insertSorted` 中的模式匹配："

#: src/programs-proofs/insertion-sort.md:241
#, fuzzy
msgid ""
"When faced with a goal that includes `if` or `match`, the `split` tactic "
"(not to be confused with the `split` function used in the definition of "
"merge sort) replaces the goal with one new goal for each path of control "
"flow:"
msgstr ""
"当面对包含 `if` 或 `match` 的目标时，`split` 策略（不要与归并排序定义中使用的 `split` "
"函数混淆）用一个新目标替换目标，用于控制流的每条路径："

#: src/programs-proofs/insertion-sort.md:253
#, fuzzy
msgid ""
"Additionally, each new goal has an assumption that indicates which branch "
"led to that goal, named `heq✝` in this case:"
msgstr "此外，每个新目标都有一个假设，表明哪个分支导致了该目标，在本例中命名为 `heq✝`："

#: src/programs-proofs/insertion-sort.md:302
#, fuzzy
msgid ""
"Rather than write proofs for both simple cases, adding `<;> try rfl` after "
"`split` causes the two straightforward cases to disappear immediately, "
"leaving only a single goal:"
msgstr "与其为这两个简单情况编写证明，不如在 `split` 后添加 `<;> try rfl`，这样这两个直接的情况会立即消失，只留下一个目标："

#: src/programs-proofs/insertion-sort.md:339
#, fuzzy
msgid ""
"Unfortunately, the induction hypothesis is not strong enough to prove this "
"goal. The induction hypothesis states that calling `insertSorted` on `arr` "
"leaves the size unchanged, but the proof goal is to show that the result of "
"the recursive call with the result of swapping leaves the size unchanged. "
"Successfully completing the proof requires an induction hypothesis that "
"works for _any_ array that is passed to `insertSorted` together with the "
"smaller index as an argument"
msgstr ""
"不幸的是，归纳假设不足以证明这个目标。归纳假设指出对 `arr` 调用 `insertSorted` "
"不会改变大小，但证明目标是要证明用交换结果进行递归调用的结果不会改变大小。成功完成证明需要一个归纳假设，该假设适用于传递给 `insertSorted`"
" 的任何数组以及作为参数的较小索引"

#: src/programs-proofs/insertion-sort.md:343
#, fuzzy
msgid ""
"It is possible to get a strong induction hypothesis by using the "
"`generalizing` option to the `induction` tactic. This option brings "
"additional assumptions from the context into the statement that's used to "
"generate the base case, the induction hypothesis, and the goal to be shown "
"in the inductive step. Generalizing over `arr` leads to a stronger "
"hypothesis:"
msgstr ""
"可以使用 `induction` 策略的 `generalizing` "
"选项来获得强归纳假设。此选项将上下文中的附加假设引入到用于生成基本情况、归纳假设和在归纳步骤中显示的目标的语句中。对 `arr` "
"进行泛化会导致更强的假设："

#: src/programs-proofs/insertion-sort.md:357
#, fuzzy
msgid ""
"In the resulting goal, `arr` is now part of a \"for all\" statement in the "
"inductive hypothesis:"
msgstr "在生成的证明目标中，`arr` 现在是归纳假设中“对所有”语句的一部分："

#: src/programs-proofs/insertion-sort.md:386
#, fuzzy
msgid ""
"However, this whole proof is beginning to get unmanageable. The next step "
"would be to introduce a variable standing for the length of the result of "
"swapping, show that it is equal to `arr.size`, and then show that this "
"variable is also equal to the length of the array that results from the "
"recursive call. These equality statement can then be chained together to "
"prove the goal. It's much easier, however, to carefully reformulate the "
"theorem statement such that the induction hypothesis is automatically strong"
" enough and the variables are already introduced. The reformulated statement"
" reads:"
msgstr ""
"然而，整个证明开始变得难以管理。下一步是引入一个变量表示交换结果的长度，证明它等于 "
"`arr.size`，然后证明这个变量也等于递归调用产生的数组的长度。然后可以将这些相等语句链接在一起来证明目标。然而，仔细重新表述定理陈述以使归纳假设自动足够强并且已经引入变量要容易得多。重新表述的陈述如下："

#: src/programs-proofs/insertion-sort.md:397
#, fuzzy
msgid ""
"This version of the theorem statement is easier to prove for a few reasons:"
msgstr "这个版本的定理陈述更容易证明，原因有以下几个："

#: src/programs-proofs/insertion-sort.md:398
#, fuzzy
msgid ""
"Rather than bundling up the index and the proof of its validity in a `Fin`, "
"the index comes before the array. This allows the induction hypothesis to "
"naturally generalize over the array and the proof that `i` is in bounds."
msgstr "与其将索引及其有效性证明捆绑在 `Fin` 中，不如将索引放在数组之前。这允许归纳假设自然地概括数组和证明 `i` 在范围内。"

#: src/programs-proofs/insertion-sort.md:400
#, fuzzy
msgid ""
"An abstract length `len` is introduced to stand for `array.size`. Proof "
"automation is often better at working with explicit statements of equality."
msgstr "引入一个抽象长度 `len` 来表示 `array.size`。证明自动化通常更擅长处理显式相等语句。"

#: src/programs-proofs/insertion-sort.md:403
#, fuzzy
msgid ""
"The resulting proof state shows the statement that will be used to generate "
"the induction hypothesis, as well as the base case and the goal of the "
"inductive step:"
msgstr "生成的证明状态显示了将用于生成归纳假设的语句，以及基本情况和归纳步骤的目标："

#: src/programs-proofs/insertion-sort.md:413
#, fuzzy
msgid ""
"Compare the statement with the goals that result from the `induction` "
"tactic:"
msgstr "将该语句与 `induction` 策略产生的目标进行比较："

#: src/programs-proofs/insertion-sort.md:422
#, fuzzy
msgid ""
"In the base case, each occurrence of `i` has been replaced by `0`. Using "
"`intro` to introduce each assumption and then simplifying using "
"`insertSorted` will prove the goal, because `insertSorted` at index `zero` "
"returns its argument unchanged:"
msgstr ""
"在基本情况下，每个 `i` 的出现都被替换为 `0`。使用 `intro` 引入每个假设，然后使用 `insertSorted` "
"简化将证明目标，因为在索引 `zero` 处的 `insertSorted` 返回其参数不变："

#: src/programs-proofs/insertion-sort.md:433
#, fuzzy
msgid ""
"In the inductive step, the induction hypothesis has exactly the right "
"strength. It will be useful for _any_ array, so long as that array has "
"length `len`:"
msgstr "归纳步骤中，归纳假设具有恰当的强度。它对_任何_数组都适用，只要该数组的长度为 `len`："

#: src/programs-proofs/insertion-sort.md:448
#, fuzzy
msgid "In the base case, `simp` reduces the goal to `arr.size = len`:"
msgstr "在基本情况下，`simp` 将目标简化为 `arr.size = len`："

#: src/programs-proofs/insertion-sort.md:470
#, fuzzy
msgid ""
"This can be proved using the assumption `hLen`. Adding the `*` parameter to "
"`simp` instructs it to additionally use assumptions, which solves the goal:"
msgstr "这可以使用假设 `hLen` 来证明。向 `simp` 添加 `*` 参数指示它另外使用假设，这解决了目标："

#: src/programs-proofs/insertion-sort.md:483
#, fuzzy
msgid ""
"In the inductive step, introducing assumptions and simplifying the goal "
"results once again in a goal that contains a pattern match:"
msgstr "在归纳步骤中，引入假设并简化目标再次导致包含模式匹配的目标："

#: src/programs-proofs/insertion-sort.md:524
#, fuzzy
msgid ""
"Using the `split` tactic results in one goal for each pattern. Once again, "
"the first two goals result from branches without recursive calls, so the "
"induction hypothesis is not necessary:"
msgstr "使用 `split` 策略会为每个模式生成一个目标。同样，前两个目标来自没有递归调用的分支，因此不需要归纳假设："

#: src/programs-proofs/insertion-sort.md:593
#, fuzzy
msgid ""
"Running `try assumption` in each goal that results from `split` eliminates "
"both of the non-recursive goals:"
msgstr "在 `split` 产生的每个目标中运行 `try assumption` 消除了两个非递归目标："

#: src/programs-proofs/insertion-sort.md:634
#, fuzzy
msgid ""
"The new formulation of the proof goal, in which a constant `len` is used for"
" the lengths of all the arrays involved in the recursive function, falls "
"nicely within the kinds of problems that `simp` can solve. This final proof "
"goal can be solved by `simp [*]`, because the assumptions that relate the "
"array's length to `len` are important:"
msgstr ""
"证明目标的新表述，其中常量 `len` 用于递归函数中涉及的所有数组的长度，恰好属于 `simp` 可以解决的问题类型。这个最终的证明目标可以通过 "
"`simp [*]` 来解决，因为将数组的长度与 `len` 联系起来的假设很重要："

#: src/programs-proofs/insertion-sort.md:651
#, fuzzy
msgid ""
"Finally, because `simp [*]` can use assumptions, the `try assumption` line "
"can be replaced by `simp [*]`, shortening the proof:"
msgstr "最后，因为 `simp [*]` 可以使用假设，所以 `try assumption` 行可以用 `simp [*]` 替换，缩短证明："

#: src/programs-proofs/insertion-sort.md:666
#, fuzzy
msgid ""
"This proof can now be used to replace the `sorry` in `insertionSortLoop`. "
"Providing `arr.size` as the `len` argument to the theorem causes the final "
"conclusion to be `(insertSorted arr ⟨i, isLt⟩).size = arr.size`, so the "
"rewrite ends with a very manageable proof goal:"
msgstr ""
"现在可以使用这个证明来替换 `insertionSortLoop` 中的 `sorry`。将 `arr.size` 作为定理的 `len` "
"参数会导致最终结论为 `(insertSorted arr ⟨i, isLt⟩).size = "
"arr.size`，因此重写以一个非常易于管理的证明目标结束："

#: src/programs-proofs/insertion-sort.md:687
#, fuzzy
msgid ""
"The proof `Nat.sub_succ_lt_self` is part of Lean's standard library. It's "
"type is `∀ (a i : Nat), i < a → a - (i + 1) < a - i`, which is exactly "
"what's needed:"
msgstr ""
"`Nat.sub_succ_lt_self` 证明是 Lean 标准库的一部分。它的类型是 `∀ (a i : Nat), i < a → a - (i"
" + 1) < a - i`，这正是所需要的："

#: src/programs-proofs/insertion-sort.md:702
#, fuzzy
msgid "The Driver Function"
msgstr "驱动函数"

#: src/programs-proofs/insertion-sort.md:704
#, fuzzy
msgid ""
"Insertion sort itself calls `insertionSortLoop`, initializing the index that"
" demarcates the sorted region of the array from the unsorted region to `0`:"
msgstr "插入排序本身调用 `insertionSortLoop`，将数组中已排序区域与未排序区域的分界索引初始化为 `0`："

#: src/programs-proofs/insertion-sort.md:710
#, fuzzy
msgid "A few quick tests show the function is at least not blatantly wrong:"
msgstr "一些快速测试表明该函数至少不是明显错误的："

#: src/programs-proofs/insertion-sort.md:717
msgid ""
"```lean\n"
"#eval insertionSort #[ \"quartz\", \"marble\", \"granite\", \"hematite\"]\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:720
msgid ""
"```output info\n"
"#[\"granite\", \"hematite\", \"marble\", \"quartz\"]\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:724
#, fuzzy
msgid "Is This Really Insertion Sort?"
msgstr "这真的是插入排序吗？"

#: src/programs-proofs/insertion-sort.md:726
#, fuzzy
msgid ""
"Insertion sort is _defined_ to be an in-place sorting algorithm. What makes "
"it useful, despite its quadratic worst-case run time, is that it is a stable"
" sorting algorithm that doesn't allocate extra space and that handles "
"almost-sorted data efficiently. If each iteration of the inner loop "
"allocated a new array, then the algorithm wouldn't _really_ be insertion "
"sort."
msgstr ""
"插入排序被定义为就地排序算法。尽管它具有二次最坏情况运行时间，但它仍然有用，因为它是一种稳定的排序算法，不会分配额外的空间，并且可以有效处理几乎已排序的数据。如果内部循环的每次迭代都分配一个新数组，那么该算法就不会真正成为插入排序。"

#: src/programs-proofs/insertion-sort.md:730
#, fuzzy
msgid ""
"Lean's array operations, such as `Array.set` and `Array.swap`, check whether"
" the array in question has a reference count that is greater than one. If "
"so, then the array is visible to multiple parts of the code, which means "
"that it must be copied. Otherwise, Lean would no longer be a pure functional"
" language. However, when the reference count is exactly one, there are no "
"other potential observers of the value. In these cases, the array primitives"
" mutate the array in place. What other parts of the program don't know can't"
" hurt them."
msgstr ""
"Lean 的数组操作（例如 `Array.set` 和 `Array.swap`）检查所讨论的数组的引用计数是否大于 "
"1。如果是，则该数组对代码的多个部分可见，这意味着它必须被复制。否则，Lean 将不再是一种纯函数式语言。但是，当引用计数恰好为 1 "
"时，没有其他潜在的值观察者。在这些情况下，数组基元会就地改变数组。程序的其他部分不知道的不会伤害它们。"

#: src/programs-proofs/insertion-sort.md:737
#, fuzzy
msgid ""
"Lean's proof logic works at the level of pure functional programs, not the "
"underlying implementation. This means that the best way to discover whether "
"a program unnecessarily copies data is to test it. Adding calls to "
"`dbgTraceIfShared` at each point where mutation is desired causes the "
"provided message to be printed to `stderr` when the value in question has "
"more than one reference."
msgstr ""
"Lean 的证明逻辑在纯函数式程序的级别上工作，而不是底层实现。这意味着发现程序是否不必要地复制数据最好的方法是测试它。在需要变异的每个点添加对 "
"`dbgTraceIfShared` 的调用，当所讨论的值有多个引用时，会导致将提供的消息打印到 `stderr`。"

#: src/programs-proofs/insertion-sort.md:741
#, fuzzy
msgid ""
"Insertion sort has precisely one place that is at risk of copying rather "
"than mutating: the call to `Array.swap`. Replacing `arr.swap ⟨i', by "
"assumption⟩ i` with `((dbgTraceIfShared \"array to swap\" arr).swap ⟨i', by "
"assumption⟩ i)` causes the program to emit `shared RC array to swap` "
"whenever it is unable to mutate the array. However, this change to the "
"program changes the proofs as well, because now there's a call to an "
"additional function. Because `dbgTraceIfShared` returns its second argument "
"directly, adding it to the calls to `simp` is enough to fix the proofs."
msgstr ""
"插入排序有一个地方有复制而不是变异的风险：调用 `Array.swap`。将 `arr.swap ⟨i', by assumption⟩ i` 替换为 "
"`((dbgTraceIfShared \"array to swap\" arr).swap ⟨i', by assumption⟩ i)` "
"会导致程序在无法变异数组时发出 `shared RC array to swap`。但是，对程序的这一更改也会更改证明，因为现在调用了一个附加函数。由于"
" `dbgTraceIfShared` 直接返回其第二个参数，因此将其添加到对 `simp` 的调用中足以修复证明。"

#: src/programs-proofs/insertion-sort.md:746
#, fuzzy
msgid "The complete instrumented code for insertion sort is:"
msgstr "插入排序的完整检测代码为："

#: src/programs-proofs/insertion-sort.md:747
msgid ""
"```leantacnorfl\n"
"def insertSorted [Ord α] (arr : Array α) (i : Fin arr.size) : Array α :=\n"
"  match i with\n"
"  | ⟨0, _⟩ => arr\n"
"  | ⟨i' + 1, _⟩ =>\n"
"    have : i' < arr.size := by\n"
"      simp [Nat.lt_of_succ_lt, *]\n"
"    match Ord.compare arr[i'] arr[i] with\n"
"    | .lt | .eq => arr\n"
"    | .gt =>\n"
"      insertSorted\n"
"        ((dbgTraceIfShared \"array to swap\" arr).swap ⟨i', by assumption⟩ i)\n"
"        ⟨i', by simp [dbgTraceIfShared, *]⟩\n"
"\n"
"theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :\n"
"    (arr : Array α) → (isLt : i < arr.size) → (arr.size = len) →\n"
"    (insertSorted arr ⟨i, isLt⟩).size = len := by\n"
"  induction i with\n"
"  | zero =>\n"
"    intro arr isLt hLen\n"
"    simp [insertSorted, *]\n"
"  | succ i' ih =>\n"
"    intro arr isLt hLen\n"
"    simp [insertSorted, dbgTraceIfShared]\n"
"    split <;> simp [*]\n"
"\n"
"def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=\n"
"  if h : i < arr.size then\n"
"    have : (insertSorted arr ⟨i, h⟩).size - (i + 1) < arr.size - i := by\n"
"      rw [insert_sorted_size_eq arr.size i arr h rfl]\n"
"      simp [Nat.sub_succ_lt_self, *]\n"
"    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)\n"
"  else\n"
"    arr\n"
"termination_by insertionSortLoop arr i => arr.size - i\n"
"\n"
"def insertionSort [Ord α] (arr : Array α) : Array α :=\n"
"  insertionSortLoop arr 0\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:787
#, fuzzy
msgid ""
"A bit of cleverness is required to check whether the instrumentation "
"actually works. First off, the Lean compiler aggressively optimizes function"
" calls away when all their arguments are known at compile time. Simply "
"writing a program that applies `insertionSort` to a large array is not "
"sufficient, because the resulting compiled code may contain only the sorted "
"array as a constant. The easiest way to ensure that the compiler doesn't "
"optimize away the sorting routine is to read the array from `stdin`. "
"Secondly, the compiler performs dead code elimination. Adding extra `let`s "
"to the program won't necessarily result in more references in running code "
"if the `let`\\-bound variables are never used. To ensure that the extra "
"reference is not eliminated entirely, it's important to ensure that the "
"extra reference is somehow used."
msgstr ""
"要检查检测是否实际起作用，需要一点技巧。首先，当所有参数在编译时都已知时，Lean 编译器会积极地优化函数调用。仅仅编写一个将 "
"`insertionSort` 应用于大数组的程序是不够的，因为生成的编译代码可能只包含已排序的数组作为常量。确保编译器不会优化排序例程的最简单方法是从"
" `stdin` 读取数组。其次，编译器执行死代码消除。如果从未使用 `let` 绑定的变量，则向程序中添加额外的 `let` "
"并不一定会导致运行代码中更多的引用。为了确保不会完全消除额外的引用，重要的是确保以某种方式使用了额外的引用。"

#: src/programs-proofs/insertion-sort.md:795
#, fuzzy
msgid ""
"The first step in testing the instrumentation is to write `getLines`, which "
"reads an array of lines from standard input:"
msgstr "测试检测的第一步是编写 `getLines`，它从标准输入读取一行数组："

#: src/programs-proofs/insertion-sort.md:807
#, fuzzy
msgid ""
"`IO.FS.Stream.getLine` returns a complete line of text, including the "
"trailing newline. It returns `\"\"` when the end-of-file marker has been "
"reached."
msgstr "`IO.FS.Stream.getLine` 返回一行完整的文本，包括结尾的新行。当到达文件结尾标记时，它返回 `\"\"`。"

#: src/programs-proofs/insertion-sort.md:810
#, fuzzy
msgid ""
"Next, two separate `main` routines are needed. Both read the array to be "
"sorted from standard input, ensuring that the calls to `insertionSort` won't"
" be replaced by their return values at compile time. Both then print to the "
"console, ensuring that the calls to `insertionSort` won't be optimized away "
"entirely. One of them prints only the sorted array, while the other prints "
"both the sorted array and the original array. The second function should "
"trigger a warning that `Array.swap` had to allocate a new array:"
msgstr ""
"接下来，需要两个单独的 `main` 例程。两者都从标准输入读取要排序的数组，确保在编译时不会用它们的返回值替换对 `insertionSort` "
"的调用。然后两者都打印到控制台，确保对 `insertionSort` "
"的调用不会被完全优化掉。其中一个只打印排序后的数组，而另一个同时打印排序后的数组和原始数组。第二个函数应该触发一个警告，即 `Array.swap` "
"必须分配一个新数组："

#: src/programs-proofs/insertion-sort.md:815
msgid ""
"```lean\n"
"def mainUnique : IO Unit := do\n"
"  let lines ← getLines\n"
"  for line in insertionSort lines do\n"
"    IO.println line\n"
"\n"
"def mainShared : IO Unit := do\n"
"  let lines ← getLines\n"
"  IO.println \"--- Sorted lines: ---\"\n"
"  for line in insertionSort lines do\n"
"    IO.println line\n"
"\n"
"  IO.println \"\"\n"
"  IO.println \"--- Original data: ---\"\n"
"  for line in lines do\n"
"    IO.println line\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:833
#, fuzzy
msgid ""
"The actual `main` simply selects one of the two main actions based on the "
"provided command-line arguments:"
msgstr "实际的 `main` 只需根据提供的命令行参数选择两个主操作之一："

#: src/programs-proofs/insertion-sort.md:834
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 := do\n"
"  match args with\n"
"  | [\"--shared\"] => mainShared; pure 0\n"
"  | [\"--unique\"] => mainUnique; pure 0\n"
"  | _ =>\n"
"    IO.println \"Expected single argument, either \\\"--shared\\\" or \\\"--unique\\\"\"\n"
"    pure 1\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:844
#, fuzzy
msgid "Running it with no arguments produces the expected usage information:"
msgstr "在没有参数的情况下运行它会产生预期的用法信息："

#: src/programs-proofs/insertion-sort.md:845
msgid ""
"```\n"
"$ sort\n"
"Expected single argument, either \"--shared\" or \"--unique\"\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:850
#, fuzzy
msgid "The file `test-data` contains the following rocks:"
msgstr "`test-data` 文件包含以下岩石："

#: src/programs-proofs/insertion-sort.md:863
#, fuzzy
msgid ""
"Using the instrumented insertion sort on these rocks results them being "
"printed in alphabetical order:"
msgstr "对这些岩石使用经过检测的插入排序，结果按字母顺序打印出来："

#: src/programs-proofs/insertion-sort.md:877
#, fuzzy
msgid ""
"However, the version in which a reference is retained to the original array "
"results in a notification on `stderr` (namely, `shared RC array to swap`) "
"from the first call to `Array.swap`:"
msgstr ""
"然而，保留对原始数组的引用的版本导致对 `Array.swap` 的第一次调用在 `stderr` 上发出通知（即 `shared RC array "
"to swap`）："

#: src/programs-proofs/insertion-sort.md:903
#, fuzzy
msgid ""
"The fact that only a single `shared RC` notification appears means that the "
"array is copied only once. This is because the copy that results from the "
"call to `Array.swap` is itself unique, so no further copies need to be made."
" In an imperative language, subtle bugs can result from forgetting to "
"explicitly copy an array before passing it by reference. When running `sort "
"--shared`, the array is copied as needed to preserve the pure functional "
"meaning of Lean programs, but no more."
msgstr ""
"仅出现一个 `shared RC` 通知这一事实意味着数组仅被复制一次。这是因为由对 `Array.swap` "
"的调用产生的副本本身是唯一的，因此不需要进行进一步的复制。在命令式语言中，由于忘记在按引用传递数组之前显式复制数组，可能会导致细微的错误。在运行 "
"`sort --shared` 时，数组会根据需要被复制，以保留 Lean 程序的纯函数含义，但不会更多。"

#: src/programs-proofs/insertion-sort.md:909
#, fuzzy
msgid "Other Opportunities for Mutation"
msgstr "其他突变机会"

#: src/programs-proofs/insertion-sort.md:911
#, fuzzy
msgid ""
"The use of mutation instead of copying when references are unique is not "
"limited to array update operators. Lean also attempts to \"recycle\" "
"constructors whose reference counts are about to fall to zero, reusing them "
"instead of allocating new data. This means, for instance, that `List.map` "
"will mutate a linked list in place, at least in cases when nobody could "
"possibly notice. One of the most important steps in optimizing hot loops in "
"Lean code is making sure that the data being modified is not referred to "
"from multiple locations."
msgstr ""
"当引用是唯一的时，使用突变而不是复制并不局限于数组更新运算符。Lean "
"还尝试“回收”引用计数即将降至零的构造函数，重新使用它们而不是分配新数据。这意味着，例如，`List.map` "
"将就地突变一个链表，至少在没有人可能注意到的情况下。优化 Lean 代码中的热点循环的最重要步骤之一是确保正在修改的数据不会被多个位置引用。"

#: src/programs-proofs/insertion-sort.md:918
#, fuzzy
msgid ""
"Write a function that reverses arrays. Test that if the input array has a "
"reference count of one, then your function does not allocate a new array."
msgstr "编写一个反转数组的函数。测试如果输入数组的引用计数为一，则你的函数不会分配一个新数组。"

#: src/programs-proofs/insertion-sort.md:920
#, fuzzy
msgid ""
"Implement either merge sort or quicksort for arrays. Prove that your "
"implementation terminates, and test that it doesn't allocate more arrays "
"than expected. This is a challenging exercise!"
msgstr "为数组实现归并排序或快速排序。证明你的实现终止，并测试它不会分配比预期更多的数组。这是一个具有挑战性的练习！"
