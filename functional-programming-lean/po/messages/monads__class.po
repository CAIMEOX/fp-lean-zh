#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/monads/class.md:3
#, fuzzy
msgid ""
"Rather than having to import an operator like `ok` or `andThen` for each "
"type that is a monad, the Lean standard library contains a type class that "
"allow them to be overloaded, so that the same operators can be used for "
"_any_ monad. Monads have two operations, which are the equivalent of `ok` "
"and `andThen`:"
msgstr ""
"无需为每个单子类型导入像 `ok` 或 `andThen` 这样的运算符，Lean 标准库包含一个类型类，允许它们被重载，以便相同的运算符可用于 "
"_任何_ 单子。单子有两个操作，它们相当于 `ok` 和 `andThen`："

#: src/monads/class.md:10
#, fuzzy
msgid ""
"This definition is slightly simplified. The actual definition in the Lean "
"library is somewhat more involved, and will be presented later."
msgstr "这个定义略微简化了。Lean 库中的实际定义更复杂一些，稍后会介绍。"

#: src/monads/class.md:13
#, fuzzy
msgid ""
"The `Monad` instances for `Option` and `Except` can be created by adapting "
"the definitions of their respective `andThen` operations:"
msgstr "`Option` 和 `Except` 的 `Monad` 实例可以通过调整它们各自的 `andThen` 操作的定义来创建："

#: src/monads/class.md:30
#, fuzzy
msgid ""
"As an example, `firstThirdFifthSeventh` was defined separately for `Option "
"α` and `Except String α` return types. Now, it can be defined "
"polymorphically for _any_ monad. It does, however, require a lookup function"
" as an argument, because different monads might fail to find a result in "
"different ways. The infix version of `bind` is `>>=`, which plays the same "
"role as `~~>` in the examples."
msgstr ""
"例如，`firstThirdFifthSeventh` 针对 `Option α` 和 `Except String α` "
"返回类型分别定义。现在，它可以针对 _任何_ monad 多态定义。但是，它需要一个查找函数作为参数，因为不同的 monad "
"可能以不同的方式找不到结果。`bind` 的中缀版本是 `>>=`, 它在示例中扮演与 `~~>` 相同的角色。"

#: src/monads/class.md:43
#, fuzzy
msgid ""
"Given example lists of slow mammals and fast birds, this implementation of "
"`firstThirdFifthSeventh` can be used with `Option`:"
msgstr "给定慢哺乳动物和快鸟的示例列表，`firstThirdFifthSeventh` 的此实现可与 `Option` 一起使用："

#: src/monads/class.md:44
#, fuzzy
msgid ""
"```lean\n"
"def slowMammals : List String :=\n"
"  [\"Three-toed sloth\", \"Slow loris\"]\n"
"\n"
"def fastBirds : List String := [\n"
"  \"Peregrine falcon\",\n"
"  \"Saker falcon\",\n"
"  \"Golden eagle\",\n"
"  \"Gray-headed albatross\",\n"
"  \"Spur-winged goose\",\n"
"  \"Swift\",\n"
"  \"Anna's hummingbird\"\n"
"]\n"
"\n"
"#eval firstThirdFifthSeventh (fun xs i => xs[i]?) slowMammals\n"
"```"
msgstr ""
"```lean\n"
"def slowMammals : List String :=\n"
"  [\"Three-toed sloth\", \"Slow loris\"]\n"
"\n"
"def fastBirds : List String := [\n"
"  \"Peregrine falcon\",\n"
"  \"Saker falcon\",\n"
"  \"Golden eagle\",\n"
"  \"Gray-headed albatross\",\n"
"  \"Spur-winged goose\",\n"
"  \"Swift\",\n"
"  \"Anna's hummingbird\"\n"
"]\n"
"\n"
"#eval firstThirdFifthSeventh (fun xs i => xs[i]?) slowMammals\n"
"```"

#: src/monads/class.md:66
#, fuzzy
msgid ""
"```output info\n"
"some (\"Peregrine falcon\", \"Golden eagle\", \"Spur-winged goose\", \"Anna's hummingbird\")\n"
"```"
msgstr ""
"```output info\n"
"some (\"Peregrine falcon\", \"Golden eagle\", \"Spur-winged goose\", \"Anna's hummingbird\")\n"
"```"

#: src/monads/class.md:70
#, fuzzy
msgid ""
"After renaming `Except`'s lookup function `get` to something more specific, "
"the very same  implementation of `firstThirdFifthSeventh` can be used with "
"`Except` as well:"
msgstr ""
"在将 `Except` 的查找函数 `get` 重命名为更具体的内容后，`firstThirdFifthSeventh` 的相同实现也可以与 "
"`Except` 一起使用："

#: src/monads/class.md:71
#, fuzzy
msgid ""
"```lean\n"
"def getOrExcept (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => Except.error s!\"Index {i} not found (maximum is {xs.length - 1})\"\n"
"  | some x => Except.ok x\n"
"\n"
"#eval firstThirdFifthSeventh getOrExcept slowMammals\n"
"```"
msgstr ""
"```lean\n"
"def getOrExcept (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => Except.error s!\"Index {i} not found (maximum is {xs.length - 1})\"\n"
"  | some x => Except.ok x\n"
"\n"
"#eval firstThirdFifthSeventh getOrExcept slowMammals\n"
"```"

#: src/monads/class.md:79
msgid ""
"```output info\n"
"Except.error \"Index 2 not found (maximum is 1)\"\n"
"```"
msgstr ""
"```output info\n"
"Except.error \"Index 2 not found (maximum is 1)\"\n"
"```"

#: src/monads/class.md:85
msgid ""
"```output info\n"
"Except.ok (\"Peregrine falcon\", \"Golden eagle\", \"Spur-winged goose\", \"Anna's hummingbird\")\n"
"```"
msgstr ""
"```output info\n"
"Except.ok (\"Peregrine falcon\", \"Golden eagle\", \"Spur-winged goose\", \"Anna's hummingbird\")\n"
"```"

#: src/monads/class.md:88
msgid ""
"The fact that `m` must have a `Monad` instance means that the `>>=` and "
"`pure` operations are available."
msgstr "`m` 必须有 `Monad` 实例，这意味着可以使用 `>>=` 和 `pure` 操作。"

#: src/monads/class.md:91
msgid "General Monad Operations"
msgstr "通用 Monad 操作"

#: src/monads/class.md:93
msgid ""
"Because many different types are monads, functions that are polymorphic over"
" _any_ monad are very powerful. For example, the function `mapM` is a "
"version of `map` that uses a `Monad` to sequence and combine the results of "
"applying a function:"
msgstr ""
"由于许多不同类型都是 monad，因此在 _任何_ monad 上多态的函数非常强大。例如，函数 `mapM` 是 `map` 的一个版本，它使用 "
"`Monad` 对应用函数的结果进行排序和组合："

#: src/monads/class.md:103
msgid ""
"The return type of the function argument `f` determines which `Monad` "
"instance will be used. In other words, `mapM` can be used for functions that"
" produce logs, for functions that can fail, or for functions that use "
"mutable state. Because `f`'s type determines the available effects, they can"
" be tightly controlled by API designers."
msgstr ""
"函数参数 `f` 的返回类型决定了将使用哪个 `Monad` 实例。换句话说，`mapM` "
"可用于生成日志的函数、可能失败的函数或使用可变状态的函数。由于 `f` 的类型决定了可用的效果，因此 API 设计人员可以对其进行严格控制。"

#: src/monads/class.md:107
msgid ""
"As described in [this chapter's introduction](../monads.md#numbering-tree-"
"nodes), `State σ α` represents programs that make use of a mutable variable "
"of type `σ` and return a value of type `α`. These programs are actually "
"functions from a starting state to a pair of a value and a final state. The "
"`Monad` class requires that its parameter expect a single type argument—that"
" is, it should be a `Type → Type`. This means that the instance for `State` "
"should mention the state type `σ`, which becomes a parameter to the "
"instance:"
msgstr ""
"如 [本章简介](../monads.md#numbering-tree-nodes) 所述，`State σ α` 表示使用类型为 `σ` "
"的可变变量并返回类型为 `α` 的值的程序。这些程序实际上是从起始状态到值和最终状态对的函数。`Monad` 类要求其参数期望单个类型参数，即它应该是 "
"`Type → Type`。这意味着 `State` 的实例应提及状态类型 `σ`，它成为实例的参数："

#: src/monads/class.md:119
msgid ""
"This means that the type of the state cannot change between calls to `get` "
"and `set` that are sequenced using `bind`, which is a reasonable rule for "
"stateful computations. The operator `increment` increases a saved state by a"
" given amount, returning the old value:"
msgstr ""
"这意味着在使用 `bind` 对 `get` 和 `set` 进行排序时，状态的类型不能更改，这是有状态计算的合理规则。运算符 `increment` "
"将保存的状态增加给定量，并返回旧值："

#: src/monads/class.md:128
#, fuzzy
msgid ""
"Using `mapM` with `increment` results in a program that computes the sum of "
"the entries in a list. More specifically, the mutable variable contains the "
"sum so far, while the resulting list contains a running sum. In other words,"
" `mapM increment` has type `List Int → State Int (List Int)`, and expanding "
"the definition of `State` yields `List Int → Int → (Int × List Int)`. It "
"takes an initial sum as an argument, which should be `0`:"
msgstr ""
"使用 `mapM` 和 `increment` "
"会生成一个计算列表中条目和的程序。更具体地说，可变变量包含到目前为止的和，而结果列表包含一个运行和。换句话说，`mapM increment` 的类型为"
" `List Int → State Int (List Int)`，展开 `State` 的定义会得到 `List Int → Int → (Int "
"× List Int)`。它将初始和作为参数，该参数应为 `0`："

#: src/monads/class.md:139
#, fuzzy
msgid ""
"A [logging effect](../monads.md#logging) can be represented using `WithLog`."
" Just like `State`, its `Monad` instance is polymorphic with respect to the "
"type of the logged data:"
msgstr ""
"可以使用 `WithLog` 表示 [日志记录效果](../monads.md#logging)。就像 `State` 一样，它的 `Monad` "
"实例对于已记录数据的类型是多态的："

#: src/monads/class.md:149
#, fuzzy
msgid ""
"`saveIfEven` is a function that logs even numbers but returns its argument "
"unchanged:"
msgstr "`saveIfEven` 是一个记录偶数但返回其参数不变的函数："

#: src/monads/class.md:157
#, fuzzy
msgid ""
"Using this function with `mapM` results in a log containing even numbers "
"paired with an unchanged input list:"
msgstr "使用 `mapM` 和此函数会生成一个包含偶数和未更改输入列表的日志："

#: src/monads/class.md:167
#, fuzzy
msgid "The Identity Monad"
msgstr "Identity Monad"

#: src/monads/class.md:169
#, fuzzy
msgid ""
"Monads encode programs with effects, such as failure, exceptions, or "
"logging, into explicit representations as data and functions. Sometimes, "
"however, an API will be written to use a monad for flexibility, but the "
"API's client may not require any encoded effects. The _identity monad_ is a "
"monad that has no effects, and allows pure code to be used with monadic "
"APIs:"
msgstr ""
"Monad 将具有效果的程序（例如失败、异常或日志记录）编码为数据和函数的显式表示。然而，有时会编写 API 以使用 monad 来提高灵活性，但 "
"API 的客户端可能不需要任何编码效果。_identity monad_ 是一个没有效果的 monad，允许将纯代码与 monadic API "
"一起使用："

#: src/monads/class.md:179
#, fuzzy
msgid ""
"The type of `pure` should be `α → Id α`, but `Id α` reduces to just `α`. "
"Similarly, the type of `bind` should be `α → (α → Id β) → Id β`. Because "
"this reduces to `α → (α → β) → β`, the second argument can be applied to the"
" first to find the result."
msgstr ""
"`pure` 的类型应为 `α → Id α`，但 `Id α` 简化为 `α`。类似地，`bind` 的类型应为 `α → (α → Id β) → "
"Id β`。由于这简化为 `α → (α → β) → β`，因此可以将第二个参数应用于第一个参数以找到结果。"

#: src/monads/class.md:183
#, fuzzy
msgid ""
"With the identity monad, `mapM` becomes equivalent to `map`. To call it this"
" way, however, Lean requires a hint that the intended monad is `Id`:"
msgstr ""
"使用 identity monad，`mapM` 等同于 `map`。但是，要以这种方式调用它，Lean 需要一个提示，表明目标 monad 是 "
"`Id`："

#: src/monads/class.md:191
#, fuzzy
msgid "Omitting the hint results in an error:"
msgstr "省略提示会导致错误："

#: src/monads/class.md:199
#, fuzzy
msgid ""
"In this error, the application of one metavariable to another indicates that"
" Lean doesn't run the type-level computation backwards. The return type of "
"the function is expected to be the monad applied to some other type. "
"Similarly, using `mapM` with a function whose type doesn't provide any "
"specific hints about which monad is to be used results in an \"instance "
"problem stuck\" message:"
msgstr ""
"在此错误中，一个元变量应用于另一个元变量表明 Lean 不会反向运行类型级计算。函数的返回类型应为应用于其他类型的单子。类似地，使用 `mapM` "
"和其类型未提供要使用哪个单子的任何特定提示的函数会导致“实例问题卡住”消息："

#: src/monads/class.md:211
#, fuzzy
msgid "The Monad Contract"
msgstr "单子契约"

#: src/monads/class.md:212
#, fuzzy
msgid ""
"Just as every pair of instances of `BEq` and `Hashable` should ensure that "
"any two equal values have the same hash, there is a contract that each "
"instance of `Monad` should obey. First, `pure` should be a left identity of "
"`bind`. That is, `bind (pure v) f` should be the same as `f v`. Secondly, "
"`pure` should be a right identity of `bind`, so `bind v pure` is the same as"
" `v`. Finally, `bind` should be associative, so `bind (bind v f) g` is the "
"same as `bind v (fun x => bind (f x) g)`."
msgstr ""
"正如 `BEq` 和 `Hashable` 的每一对实例都应确保任何两个相等的值具有相同的哈希值，`Monad` "
"的每个实例都应遵守契约。首先，`pure` 应为 `bind` 的左单位。即，`bind (pure v) f` 应与 `f v` "
"相同。其次，`pure` 应为 `bind` 的右单位，因此 `bind v pure` 与 `v` 相同。最后，`bind` 应为结合的，因此 "
"`bind (bind v f) g` 与 `bind v (fun x => bind (f x) g)` 相同。"

#: src/monads/class.md:218
#, fuzzy
msgid ""
"This contract specifies the expected properties of programs with effects "
"more generally. Because `pure` has no effects, sequencing its effects with "
"`bind` shouldn't change the result. The associative property of `bind` "
"basically says that the sequencing bookkeeping itself doesn't matter, so "
"long as the order in which things are happening is preserved."
msgstr ""
"此契约指定了具有效果的程序的预期属性。由于 `pure` 没有效果，因此将其效果与 `bind` 顺序执行不应改变结果。`bind` "
"的结合属性基本上表示顺序记账本身无关紧要，只要保留事情发生的顺序即可。"

#: src/monads/class.md:224
#, fuzzy
msgid "Mapping on a Tree"
msgstr "映射树"

#: src/monads/class.md:226
#, fuzzy
msgid ""
"Define a function `BinTree.mapM`. By analogy to `mapM` for lists, this "
"function should apply a monadic function to each data entry in a tree, as a "
"preorder traversal. The type signature should be:"
msgstr ""
"定义函数 `BinTree.mapM`。通过类比列表的 `mapM`，此函数应将单子函数应用于树中的每个数据项，作为前序遍历。类型签名应为："

#: src/monads/class.md:234
#, fuzzy
msgid "The Option Monad Contract"
msgstr "选项单子契约"

#: src/monads/class.md:236
#, fuzzy
msgid ""
"First, write a convincing argument that the `Monad` instance for `Option` "
"satisfies the monad contract. Then, consider the following instance:"
msgstr "首先，写一个令人信服的论证，证明 `Option` 的 `Monad` 实例满足 monad 契约。然后，考虑以下实例："

#: src/monads/class.md:243
#, fuzzy
msgid ""
"Both methods have the correct type. Why does this instance violate the monad"
" contract?"
msgstr "这两个方法都有正确的类型。为什么这个实例违反了 monad 契约？"
