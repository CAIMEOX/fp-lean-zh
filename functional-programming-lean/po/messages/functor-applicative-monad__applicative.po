#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/functor-applicative-monad/applicative.md:3
#, fuzzy
msgid ""
"An _applicative functor_ is a functor that has two additional operations "
"available: `pure` and `seq`. `pure` is the same operator used in `Monad`, "
"because `Monad` in fact inherits from `Applicative`. `seq` is much like "
"`map`: it allows a function to be used in order to transform the contents of"
" a datatype. However, with `seq`, the function is itself contained in the "
"datatype: `f (α → β) → (Unit → f α) → f β`. Having the function under the "
"type `f` allows the `Applicative` instance to control how the function is "
"applied, while `Functor.map` unconditionally applies a function. The second "
"argument has a type that begins with `Unit →` to allow the definition of "
"`seq` to short-circuit in cases where the function will never be applied."
msgstr ""
"应用函子是一种函子，它具有两个附加操作：`pure` 和 `seq`。`pure` 是 `Monad` 中使用的相同操作符，因为 `Monad` "
"实际上继承自 `Applicative`。`seq` 与 `map` 非常相似：它允许使用函数来转换数据类型的內容。但是，使用 `seq` "
"时，函数本身包含在数据类型中：`f (α → β) → (Unit → f α) → f β`。将函数置于类型 `f` 下允许 "
"`Applicative` 实例控制如何应用函数，而 `Functor.map` 无条件地应用函数。第二个参数的类型以 `Unit →` "
"开头，以便在函数永远不会被应用的情况下允许 `seq` 的定义短路。"

#: src/functor-applicative-monad/applicative.md:10
#, fuzzy
msgid ""
"The value of this short-circuiting behavior can be seen in the instance of "
"`Applicative Option`:"
msgstr "这种短路行为的价值可以在 `Applicative Option` 的实例中看到："

#: src/functor-applicative-monad/applicative.md:19
#, fuzzy
msgid ""
"In this case, if there is no function for `seq` to apply, then there is no "
"need to compute its argument, so `x` is never called. The same consideration"
" informs the instance of `Applicative` for `Except`:"
msgstr ""
"在这种情况下，如果没有要应用的 `seq` 函数，则无需计算其参数，因此永远不会调用 `x`。相同的考虑适用于 `Except` 的 "
"`Applicative` 实例："

#: src/functor-applicative-monad/applicative.md:29
#, fuzzy
msgid ""
"This short-circuiting behavior depends only on the `Option` or `Except` "
"structures that _surround_ the function, rather than on the function itself."
msgstr "这种短路行为仅取决于包围函数的 `Option` 或 `Except` 结构，而不是函数本身。"

#: src/functor-applicative-monad/applicative.md:31
#, fuzzy
msgid ""
"Monads can be seen as a way of capturing the notion of sequentially "
"executing statements into a pure functional language. The result of one "
"statement can affect which further statements run. This can be seen in the "
"type of `bind`: `m α → (α → m β) → m β`. The first statement's resulting "
"value is an input into a function that computes the next statement to "
"execute. Successive uses of `bind` are like a sequence of statements in an "
"imperative programming language, and `bind` is powerful enough to implement "
"control structures like conditionals and loops."
msgstr ""
"Monad 可以看作是一种将顺序执行语句的概念捕获到纯函数语言中的方式。一个语句的结果会影响哪些进一步的语句运行。这可以在 `bind` "
"的类型中看到：`m α → (α → m β) → m β`。第一个语句的结果值是计算要执行的下一个语句的函数的输入。`bind` "
"的连续使用就像命令式编程语言中的语句序列，并且 `bind` 足够强大，可以实现条件和循环等控制结构。"

#: src/functor-applicative-monad/applicative.md:37
#, fuzzy
msgid ""
"Following this analogy, `Applicative` captures function application in a "
"language that has side effects. The arguments to a function in languages "
"like Kotlin or C# are evaluated from left to right. Side effects performed "
"by earlier arguments occur before those performed by later arguments. A "
"function is not powerful enough to implement custom short-circuiting "
"operators that depend on the specific _value_ of an argument, however."
msgstr ""
"类比而言，`Applicative` 捕获了具有副作用的语言中的函数应用。在 Kotlin 或 C# "
"等语言中，函数的参数从左到右求值。较早参数执行的副作用发生在较后参数执行的副作用之前。然而，函数不够强大，无法实现依赖于参数特定 _值_ "
"的自定义短路运算符。"

#: src/functor-applicative-monad/applicative.md:42
#, fuzzy
msgid ""
"Typically, `seq` is not invoked directly. Instead, the operator `<*>` is "
"used. This operator wraps its second argument in `fun () => ...`, "
"simplifying the call site. In other words, `E1 <*> E2` is syntactic sugar "
"for `Seq.seq E1 (fun () => E2)`."
msgstr ""
"通常，`seq` 不会直接调用。相反，使用运算符 `<*>`。此运算符将其第二个参数包装在 `fun () => ...` "
"中，简化了调用站点。换句话说，`E1 <*> E2` 是 `Seq.seq E1 (fun () => E2)` 的语法糖。"

#: src/functor-applicative-monad/applicative.md:48
#, fuzzy
msgid ""
"The key feature that allows `seq` to be used with multiple arguments is that"
" a multiple-argument Lean function is really a single-argument function that"
" returns another function that's waiting for the rest of the arguments. In "
"other words, if the first argument to `seq` is awaiting multiple arguments, "
"then the result of the `seq` will be awaiting the rest. For example, `some "
"Plus.plus` can have the type `Option (Nat → Nat → Nat)`. Providing one "
"argument, `some Plus.plus <*> some 4`, results in the type `Option (Nat → "
"Nat)`. This can itself be used with `seq`, so `some Plus.plus <*> some 4 <*>"
" some 7` has the type `Option Nat`."
msgstr ""
"允许 `seq` 用于多个参数的关键特性是，多参数 Lean 函数实际上是一个单参数函数，它返回另一个等待其余参数的函数。换句话说，如果 `seq` "
"的第一个参数正在等待多个参数，那么 `seq` 的结果将等待其余参数。例如，`some Plus.plus` 可以具有类型 `Option (Nat →"
" Nat → Nat)`。提供一个参数，`some Plus.plus <*> some 4`，得到类型 `Option (Nat → "
"Nat)`。这本身可以与 `seq` 一起使用，所以 `some Plus.plus <*> some 4 <*> some 7` 具有类型 "
"`Option Nat`。"

#: src/functor-applicative-monad/applicative.md:54
#, fuzzy
msgid ""
"Not every functor is applicative. `Pair` is like the built-in product type "
"`Prod`:"
msgstr "并非每个函子都是应用函子。`Pair` 类似于内置的乘积类型 `Prod`："

#: src/functor-applicative-monad/applicative.md:61
#, fuzzy
msgid ""
"Like `Except`, `Pair` has type `Type → Type → Type`. This means that `Pair "
"α` has type `Type → Type`, and a `Functor` instance is possible:"
msgstr ""
"与 `Except` 一样，`Pair` 具有类型 `Type → Type → Type`。这意味着 `Pair α` 具有类型 `Type → "
"Type`，并且 `Functor` 实例是可能的："

#: src/functor-applicative-monad/applicative.md:67
#, fuzzy
msgid "This instance obeys the `Functor` contract."
msgstr "此实例遵循 `Functor` 契约。"

#: src/functor-applicative-monad/applicative.md:69
#, fuzzy
msgid ""
"The two properties to check are that `id <$> Pair.mk x y = Pair.mk x y` and "
"that `f <$> g <$> Pair.mk x y = (f ∘ g) <$> Pair.mk x y`. The first property"
" can be checked by just stepping through the evaluation of the left side, "
"and noticing that it evaluates to the right side:"
msgstr ""
"要检查的两个属性是 `id <$> Pair.mk x y = Pair.mk x y` 和 `f <$> g <$> Pair.mk x y = (f"
" ∘ g) <$> Pair.mk x y`。第一个属性可以通过逐步执行左侧的求值来检查，并注意到它求值为右侧："

#: src/functor-applicative-monad/applicative.md:78
#, fuzzy
msgid ""
"The second can be checked by stepping through both sides, and noting that "
"they yield the same result:"
msgstr "第二个属性可以通过逐步执行双方来检查，并注意到它们产生相同的结果："

#: src/functor-applicative-monad/applicative.md:93
#, fuzzy
msgid ""
"Attempting to define an `Applicative` instance, however, does not work so "
"well. It will require a definition of `pure`:"
msgstr "然而，尝试定义一个 `Applicative` 实例并不能很好地工作。它需要一个 `pure` 的定义："

#: src/functor-applicative-monad/applicative.md:105
#, fuzzy
msgid ""
"There is a value with type `β` in scope (namely `x`), and the error message "
"from the underscore suggests that the next step is to use the constructor "
"`Pair.mk`:"
msgstr "作用域中有一个类型为 `β` 的值（即 `x`），下划线中的错误消息表明下一步是使用构造函数 `Pair.mk`："

#: src/functor-applicative-monad/applicative.md:116
#, fuzzy
msgid ""
"Unfortunately, there is no `α` available. Because `pure` would need to work "
"for _all possible types_ α to define an instance of `Applicative (Pair α)`, "
"this is impossible. After all, a caller could choose `α` to be `Empty`, "
"which has no values at all."
msgstr ""
"不幸的是，没有 `α` 可用。因为 `pure` 需要对所有可能的类型 α 起作用才能定义 `Applicative (Pair α)` "
"的实例，这是不可能的。毕竟，调用者可以选择 `α` 为 `Empty`，它没有任何值。"

#: src/functor-applicative-monad/applicative.md:120
#, fuzzy
msgid "A Non-Monadic Applicative"
msgstr "非单子 Applicative"

#: src/functor-applicative-monad/applicative.md:122
#, fuzzy
msgid ""
"When validating user input to a form, it's generally considered to be best "
"to provide many errors at once, rather than one error at a time. This allows"
" the user to have an overview of what is needed to please the computer, "
"rather than feeling badgered as they correct the errors field by field."
msgstr ""
"在验证表单的用户输入时，通常认为一次提供多个错误比一次提供一个错误更好。这使用户能够概览满足计算机需要的内容，而不是在逐个字段更正错误时感到烦恼。"

#: src/functor-applicative-monad/applicative.md:125
#, fuzzy
msgid ""
"Ideally, validating user input will be visible in the type of the function "
"that's doing the validating. It should return a datatype that is "
"specific—checking that a text box contains a number should return an actual "
"numeric type, for instance. A validation routine could throw an exception "
"when the input does not pass validation. Exceptions have a major drawback, "
"however: they terminate the program at the first error, making it impossible"
" to accumulate a list of errors."
msgstr ""
"理想情况下，验证用户输入将在执行验证的函数的类型中可见。它应该返回一个特定的数据类型——例如，检查文本框是否包含数字应该返回一个实际的数字类型。当输入未通过验证时，验证例程可能会抛出异常。然而，异常有一个主要的缺点：它们在第一个错误时终止程序，使得无法累积错误列表。"

#: src/functor-applicative-monad/applicative.md:130
#, fuzzy
msgid ""
"On the other hand, the common design pattern of accumulating a list of "
"errors and then failing when it is non-empty is also problematic. A long "
"nested sequences of `if` statements that validate each sub-section of the "
"input data is hard to maintain, and it's easy to lose track of an error "
"message or two. Ideally, validation can be performed using an API that "
"enables a new value to be returned yet automatically tracks and accumulates "
"error messages."
msgstr ""
"另一方面，积累一个错误列表，然后在列表非空时失败的常见设计模式也存在问题。一个验证输入数据每个子部分的嵌套 `if` 语句的序列难以维护，并且很容易丢失一两个错误消息。理想情况下，可以使用允许返回新值但自动跟踪和积累错误消息的 API 来执行验证。\n"
"\n"
"一个名为 `Validate` 的应用函子提供了一种实现这种风格的 API 的方法。与 `Except` 单子类似，`Validate` 允许构造一个新值，该值准确地表征了经过验证的数据。与 `Except` 不同，它允许积累多个错误，而不会忘记检查列表是否为空。\n"
"\n"
"用户输入\n"
"\n"
"以下结构作为用户输入的一个示例：\n"
"\n"
"要实现的业务逻辑如下：\n"
"\n"
"名称不能为空\n"
"出生年份必须为数字且非负\n"
"出生年份必须大于 1900 年，且小于或等于验证表单的年份\n"
"将这些表示为数据类型需要一个称为 _子类型_ 的新特性。有了这个工具，就可以编写一个使用应用函子来跟踪错误的验证框架，并且可以在框架中实现这些规则。\n"
"\n"
"子类型\n"
"\n"
"使用一个称为 `Subtype` 的附加 Lean 类型最容易表示这些条件：\n"
"\n"
"此结构有两个类型参数：一个隐式参数是数据 `α` 的类型，一个显式参数 `p` 是 `α` 上的谓词。_谓词_ 是其中包含变量的逻辑语句，该变量可以用值替换以产生实际语句，例如 [GetElem 的参数](../type-classes/indexing.md#overloading-indexing) 描述了索引在查找中处于界内意味着什么。在 `Subtype` 的情况下，谓词切分出 `α` 值的某些子集，谓词对这些值成立。该结构的两个字段分别是来自 `α` 的值和该值满足谓词 `p` 的证据。Lean 有用于 `Subtype` 的特殊语法。如果 `p` 的类型为 `α → Prop`，则类型 `Subtype p` 也可以写为 `{x : α // p x}`，甚至在可以自动推断类型时写为 `{x // p x}`。"

#: src/functor-applicative-monad/applicative.md:134
#, fuzzy
msgid ""
"An applicative functor called `Validate` provides one way to implement this "
"style of API. Like the `Except` monad, `Validate` allows a new value to be "
"constructed that characterizes the validated data accurately. Unlike "
"`Except`, it allows multiple errors to be accumulated, without a risk of "
"forgetting to check whether the list is empty."
msgstr "?"

#: src/functor-applicative-monad/applicative.md:138
#, fuzzy
msgid "User Input"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:139
#, fuzzy
msgid "As an example of user input, take the following structure:"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:145
#, fuzzy
msgid "The business logic to be implemented is the following:"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:146
#, fuzzy
msgid "The name may not be empty"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:147
#, fuzzy
msgid "The birth year must be numeric and non-negative"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:148
#, fuzzy
msgid ""
"The birth year must be greater than 1900, and less than or equal to the year"
" in which the form is validated"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:150
#, fuzzy
msgid ""
"Representing these as a datatype will require a new feature, called "
"_subtypes_. With this tool in hand, a validation framework can be written "
"that uses an applicative functor to track errors, and these rules can be "
"implemented in the framework."
msgstr "?"

#: src/functor-applicative-monad/applicative.md:153
#, fuzzy
msgid "Subtypes"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:154
#, fuzzy
msgid ""
"Representing these conditions is easiest with one additional Lean type, "
"called `Subtype`:"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:160
#, fuzzy
msgid ""
"This structure has two type parameters: an implicit parameter that is the "
"type of data `α`, and an explicit parameter `p` that is a predicate over "
"`α`. A _predicate_ is a logical statement with a variable in it that can be "
"replaced with a value to yield an actual statement, like the [parameter to "
"`GetElem`](../type-classes/indexing.md#overloading-indexing) that describes "
"what it means for an index to be in bounds for a lookup. In the case of "
"`Subtype`, the predicate slices out some subset of the values of `α` for "
"which the predicate holds. The structure's two fields are, respectively, a "
"value from `α` and evidence that the value satisfies the predicate `p`. Lean"
" has special syntax for `Subtype`. If `p` has type `α → Prop`, then the type"
" `Subtype p` can also be written `{x : α // p x}`, or even `{x // p x}` when"
" the type can be inferred automatically."
msgstr "?"

#: src/functor-applicative-monad/applicative.md:167
#, fuzzy
msgid ""
"[Representing positive numbers as inductive types](../type-classes/pos.md) "
"is clear and easy to program with. However, it has a key disadvantage. While"
" `Nat` and `Int` have the structure of ordinary inductive types from the "
"perspective of Lean programs, the compiler treats them specially and uses "
"fast arbitrary-precision number libraries to implement them. This is not the"
" case for additional user-defined types. However, a subtype of `Nat` that "
"restricts it to non-zero numbers allows the new type to use the efficient "
"representation while still ruling out zero at compile time:"
msgstr ""
"以归纳类型表示正数清晰易于编程。然而，它有一个关键缺点。从 Lean 程序的角度来看，`Nat` 和 `Int` "
"具有普通归纳类型的结构，但编译器将它们视为特殊类型，并使用快速任意精度数字库来实现它们。对于其他用户定义类型而言，情况并非如此。然而，`Nat` "
"的一个子类型将其限制为非零数字，允许新类型使用高效表示，同时在编译时仍排除零：最小的快速正数仍然是一。现在，它不再是归纳类型的构造器，而是用尖括号构造的结构的一个实例。第一个参数是底层的"
" `Nat`，第二个参数是证据，即所述 `Nat` 大于零：`OfNat` 实例与 `Pos` 的实例非常相似，除了它使用简短的策略证明来提供证据，即 "
"`n + 1 > 0`：`simp_arith` 策略是 `simp` "
"的一个版本，它考虑了额外的算术恒等式。子类型是一把双刃剑。它们允许对验证规则进行高效表示，但它们将维护这些规则的负担转移给了库的用户，他们必须证明他们没有违反重要的不变量。通常，最好在库内部使用它们，为用户提供一个"
" API，该 API 自动确保满足所有不变量，并且任何必要的证明都属于库的内部。"

#: src/functor-applicative-monad/applicative.md:172
msgid ""
"```lean\n"
"def FastPos : Type := {x : Nat // x > 0}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:176
#, fuzzy
msgid ""
"The smallest fast positive number is still one. Now, instead of being a "
"constructor of an inductive type, it's an instance of a structure that's "
"constructed with angle brackets. The first argument is the underlying `Nat`,"
" and the second argument is the evidence that said `Nat` is greater than "
"zero:"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:182
#, fuzzy
msgid ""
"The `OfNat` instance is very much like that for `Pos`, except it uses a "
"short tactic proof to provide evidence that `n + 1 > 0`:"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:187
#, fuzzy
msgid ""
"The `simp_arith` tactic is a version of `simp` that takes additional "
"arithmetic identities into account."
msgstr "?"

#: src/functor-applicative-monad/applicative.md:189
#, fuzzy
msgid ""
"Subtypes are a two-edged sword. They allow efficient representation of "
"validation rules, but they transfer the burden of maintaining these rules to"
" the users of the library, who have to _prove_ that they are not violating "
"important invariants. Generally, it's a good idea to use them internally to "
"a library, providing an API to users that automatically ensures that all "
"invariants are satisfied, with any necessary proofs being internal to the "
"library."
msgstr "?"

#: src/functor-applicative-monad/applicative.md:193
#, fuzzy
msgid ""
"Checking whether a value of type `α` is in the subtype `{x : α // p x}` "
"usually requires that the proposition `p x` be decidable. The [section on "
"equality and ordering classes](../type-classes/standard-classes.md#equality-"
"and-ordering) describes how decidable propositions can be used with `if`. "
"When `if` is used with a decidable proposition, a name can be provided. In "
"the `then` branch, the name is bound to evidence that the proposition is "
"true, and in the `else` branch, it is bound to evidence that the proposition"
" is false. This comes in handy when checking whether a given `Nat` is "
"positive:"
msgstr ""
"检查类型为 `α` 的值是否在子类型 `{x : α // p x}` 中通常需要命题 `p x` 可判定。[等式和排序类部分](../type-"
"classes/standard-classes.md#equality-and-ordering) 描述了如何将可判定命题与 `if` 一起使用。当 "
"`if` 与可判定命题一起使用时，可以提供一个名称。在 `then` 分支中，该名称绑定到命题为真的证据，而在 `else` "
"分支中，它绑定到命题为假的证据。这在检查给定的 `Nat` 是否为正数时非常方便："

#: src/functor-applicative-monad/applicative.md:204
#, fuzzy
msgid ""
"In the `then` branch, `h` is bound to evidence that `n > 0`, and this "
"evidence can be used as the second argument to `Subtype`'s constructor."
msgstr "在 `then` 分支中，`h` 绑定到 `n > 0` 的证据，并且此证据可以用作 `Subtype` 构造函数的第二个参数。"

#: src/functor-applicative-monad/applicative.md:207
#, fuzzy
msgid "Validated Input"
msgstr "已验证的输入"

#: src/functor-applicative-monad/applicative.md:209
#, fuzzy
msgid ""
"The validated user input is a structure that expresses the business logic "
"using multiple techniques:"
msgstr "已验证的用户输入是一个结构，它使用多种技术来表达业务逻辑："

#: src/functor-applicative-monad/applicative.md:210
#, fuzzy
msgid ""
"The structure type itself encodes the year in which it was checked for "
"validity, so that `CheckedInput 2019` is not the same type as `CheckedInput "
"2020`"
msgstr ""
"结构类型本身编码了检查其有效性的年份，因此 `CheckedInput 2019` 与 `CheckedInput 2020` 不是同一种类型"

#: src/functor-applicative-monad/applicative.md:211
#, fuzzy
msgid "The birth year is represented as a `Nat` rather than a `String`"
msgstr "出生年份表示为 `Nat` 而不是 `String`"

#: src/functor-applicative-monad/applicative.md:212
#, fuzzy
msgid ""
"Subtypes are used to constrain the allowed values in the name and birth year"
" fields"
msgstr "子类型用于限制名称和出生年份字段中的允许值"

#: src/functor-applicative-monad/applicative.md:213
msgid ""
"```lean\n"
"structure CheckedInput (thisYear : Nat) : Type where\n"
"  name : {n : String // n ≠ \"\"}\n"
"  birthYear : {y : Nat // y > 1900 ∧ y ≤ thisYear}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:219
#, fuzzy
msgid ""
"An input validator should take the current year and a `RawInput` as "
"arguments, returning either a checked input or at least one validation "
"failure. This is represented by the `Validate` type:"
msgstr "输入验证器应以当前年份和 `RawInput` 作为参数，返回已检查的输入或至少一个验证失败。这由 `Validate` 类型表示："

#: src/functor-applicative-monad/applicative.md:226
#, fuzzy
msgid ""
"It looks very much like `Except`. The only difference is that the `error` "
"constructor may contain more than one failure."
msgstr "它看起来非常像 `Except`。唯一的区别是 `error` 构造函数可能包含多个失败。"

#: src/functor-applicative-monad/applicative.md:229
#, fuzzy
msgid ""
"Validate is a functor. Mapping a function over it transforms any successful "
"value that might be present, just as in the `Functor` instance for `Except`:"
msgstr "Validate 是一个函子。对其进行函数映射会转换可能存在的任何成功值，就像 `Except` 的 `Functor` 实例一样："

#: src/functor-applicative-monad/applicative.md:238
#, fuzzy
msgid ""
"The `Applicative` instance for `Validate` has an important difference from "
"the instance for `Except`: while the instance for `Except` terminates at the"
" first error encountered, the instance for `Validate` is careful to "
"accumulate all errors from _both_ the function and the argument branches:"
msgstr ""
"`Validate` 的 `Applicative` 实例与 `Except` 的实例有一个重要的区别：`Except` 实例在遇到第一个错误时终止，而"
" `Validate` 实例会小心地累积来自函数和参数分支的所有错误："

#: src/functor-applicative-monad/applicative.md:251
#, fuzzy
msgid ""
"Using `.errors` together with the constructor for `NonEmptyList` is a bit "
"verbose. Helpers like `reportError` make code more readable. In this "
"application, error reports will consist of field names paired with messages:"
msgstr ""
"将 `.errors` 与 `NonEmptyList` 的构造函数一起使用有点冗长。像 `reportError` "
"这样的辅助函数使代码更具可读性。在此应用程序中，错误报告将由与消息配对的字段名称组成："

#: src/functor-applicative-monad/applicative.md:261
#, fuzzy
msgid ""
"The `Applicative` instance for `Validate` allows the checking procedures for"
" each field to be written independently and then composed. Checking a name "
"consists of ensuring that a string is non-empty, then returning evidence of "
"this fact in the form of a `Subtype`. This uses the evidence-binding version"
" of `if`:"
msgstr ""
"`Validate` 的 `Applicative` 实例允许独立编写每个字段的检查过程，然后进行组合。检查名称包括确保字符串非空，然后以 "
"`Subtype` 的形式返回此事实的证据。这使用 `if` 的证据绑定版本："

#: src/functor-applicative-monad/applicative.md:264
msgid ""
"```lean\n"
"def checkName (name : String) : Validate (Field × String) {n : String // n ≠ \"\"} :=\n"
"  if h : name = \"\" then\n"
"    reportError \"name\" \"Required\"\n"
"  else pure ⟨name, h⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:270
#, fuzzy
msgid ""
"In the `then` branch, `h` is bound to evidence that `name = \"\"`, while it "
"is bound to evidence that `¬name = \"\"` in the `else` branch."
msgstr "在 `then` 分支中，`h` 绑定到 `name = \"\"` 的证据，而在 `else` 分支中，它绑定到 `¬name = \"\"` 的证据。"

#: src/functor-applicative-monad/applicative.md:272
#, fuzzy
msgid ""
"It's certainly the case that some validation errors make other checks "
"impossible. For example, it makes no sense to check whether the birth year "
"field is greater than 1900 if a confused user wrote the word `\"syzygy\"` "
"instead of a number. Checking the allowed range of the number is only "
"meaningful after ensuring that the field in fact contains a number. This can"
" be expressed using the function `andThen`:"
msgstr ""
"当然，某些验证错误会使其他检查变得不可能。例如，如果一个困惑的用户写了单词 `\"syzygy\"` 而不是数字，那么检查出生年份字段是否大于 1900"
" 就没有意义了。只有在确保字段实际上包含数字后，检查数字的允许范围才有意义。这可以使用 `andThen` 函数来表示："

#: src/functor-applicative-monad/applicative.md:282
#, fuzzy
msgid ""
"While this function's type signature makes it suitable to be used as `bind` "
"in a `Monad` instance, there are good reasons not to do so. They are "
"described [in the section that describes the `Applicative` "
"contract](applicative-contract.md#additional-stipulations)."
msgstr ""
"虽然此函数的类型签名使其适合用作 `Monad` 实例中的 `bind`，但有充分的理由不这样做。它们在 [描述 `Applicative` "
"契约的部分](applicative-contract.md#additional-stipulations) 中进行了描述。"

#: src/functor-applicative-monad/applicative.md:285
#, fuzzy
msgid ""
"To check that the birth year is a number, a built-in function called "
"`String.toNat? : String → Option Nat` is useful. It's most user-friendly to "
"eliminate leading and trailing whitespace first using `String.trim`:"
msgstr ""
"为了检查出生年份是否为数字，内置函数 `String.toNat? : String → Option Nat` 非常有用。最用户友好的做法是首先使用 "
"`String.trim` 去除前导和尾随空格："

#: src/functor-applicative-monad/applicative.md:287
msgid ""
"```lean\n"
"def checkYearIsNat (year : String) : Validate (Field × String) Nat :=\n"
"  match year.trim.toNat? with\n"
"  | none => reportError \"birth year\" \"Must be digits\"\n"
"  | some n => pure n\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:293
#, fuzzy
msgid ""
"To check that the provided year is in the expected range, nested uses of the"
" evidence-providing form of `if` are in order:"
msgstr "为了检查提供的年份是否在预期范围内，需要嵌套使用提供证据形式的 `if`："

#: src/functor-applicative-monad/applicative.md:294
msgid ""
"```leantac\n"
"def checkBirthYear (thisYear year : Nat) : Validate (Field × String) {y : Nat // y > 1900 ∧ y ≤ thisYear} :=\n"
"  if h : year > 1900 then\n"
"    if h' : year ≤ thisYear then\n"
"      pure ⟨year, by simp [*]⟩\n"
"    else reportError \"birth year\" s!\"Must be no later than {thisYear}\"\n"
"  else reportError \"birth year\" \"Must be after 1900\"\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:303
#, fuzzy
msgid "Finally, these three components can be combined using `seq`:"
msgstr "最后，这三个组件可以使用 `seq` 组合："

#: src/functor-applicative-monad/applicative.md:312
#, fuzzy
msgid ""
"Testing `checkInput` shows that it can indeed return multiple pieces of "
"feedback:"
msgstr "测试 `checkInput` 表明它确实可以返回多条反馈："

#: src/functor-applicative-monad/applicative.md:313
msgid ""
"```lean\n"
"#eval checkInput 2023 {name := \"David\", birthYear := \"1984\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:316
msgid ""
"```output info\n"
"Validate.ok { name := \"David\", birthYear := 1984 }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:319
msgid ""
"```lean\n"
"#eval checkInput 2023 {name := \"\", birthYear := \"2045\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:322
msgid ""
"```output info\n"
"Validate.errors { head := (\"name\", \"Required\"), tail := [(\"birth year\", \"Must be no later than 2023\")] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:325
msgid ""
"```lean\n"
"#eval checkInput 2023 {name := \"David\", birthYear := \"syzygy\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:328
msgid ""
"```output info\n"
"Validate.errors { head := (\"birth year\", \"Must be digits\"), tail := [] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:333
#, fuzzy
msgid ""
"Form validation with `checkInput` illustrates a key advantage of "
"`Applicative` over `Monad`. Because `>>=` provides enough power to modify "
"the rest of the program's execution based on the value from the first step, "
"it _must_ receive a value from the first step to pass on. If no value is "
"received (e.g. because an error has occurred), then `>>=` cannot execute the"
" rest of the program. `Validate` demonstrates why it can be useful to run "
"the rest of the program anyway: in cases where the earlier data isn't "
"needed, running the rest of the program can yield useful information (in "
"this case, more validation errors). `Applicative`'s `<*>` may run both of "
"its arguments before recombining the results. Similarly, `>>=` forces "
"sequential execution. Each step must complete before the next may run. This "
"is generally useful, but it makes it impossible to have parallel execution "
"of different threads that naturally emerges from the program's actual data "
"dependencies. A more powerful abstraction like `Monad` increases the "
"flexibility that's available to the API consumer, but it decreases the "
"flexibility that is available to the API implementor."
msgstr ""
"使用 `checkInput` 进行表单验证说明了 `Applicative` 相对于 `Monad` 的一个关键优势。由于 `>>=` "
"提供了足够的权力来根据第一步的值修改程序其余部分的执行，因此它_必须_从第一步接收一个值才能传递。如果没有收到值（例如，因为发生了错误），则 `>>=`"
" 无法执行程序的其余部分。`Validate` "
"展示了为什么无论如何运行程序的其余部分都可能很有用：在不需要早期数据的情况下，运行程序的其余部分可以产生有用的信息（在本例中，更多验证错误）。`Applicative`"
" 的 `<*>` 可以在重新组合结果之前运行其两个参数。类似地，`>>=` "
"强制顺序执行。每个步骤都必须完成，然后才能运行下一个步骤。这通常很有用，但它使得无法并行执行程序的实际数据依赖性自然产生的不同线程。像 `Monad` "
"这样更强大的抽象增加了 API 消费者可用的灵活性，但它降低了 API 实现者可用的灵活性。"
