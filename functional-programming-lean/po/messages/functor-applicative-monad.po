#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/functor-applicative-monad.md:3
#, fuzzy
msgid ""
"`Functor` and `Monad` both describe operations for types that are still "
"waiting for a type argument. One way to understand them is that `Functor` "
"describes containers in which the contained data can be transformed, and "
"`Monad` describes an encoding of programs with side effects. This "
"understanding is incomplete, however. After all, `Option` has instances for "
"both `Functor` and `Monad`, and simultaneously represents an optional value "
"_and_ a computation that might fail to return a value."
msgstr ""
"函子（Functor）和单子（Monad）都描述了等待类型参数的类型操作。一种理解方式是，函子描述了其中包含的数据可以被转换的容器，而单子描述了具有副作用的程序的编码。然而，这种理解是不完整的。毕竟，Option"
" 同时具有函子和单子的实例，并且同时表示一个可选值和一个可能无法返回值的计算。"

#: src/functor-applicative-monad.md:8
#, fuzzy
msgid ""
"From the perspective of data structures, `Option` is a bit like a nullable "
"type or like a list that can contain at most one entry. From the perspective"
" of control structures, `Option` represents a computation that might "
"terminate early without a result. Typically, programs that use the `Functor`"
" instance are easiest to think of as using `Option` as a data structure, "
"while programs that use the `Monad` instance are easiest to think of as "
"using `Option` to allow early failure, but learning to use both of these "
"perspectives fluently is an important part of becoming proficient at "
"functional programming."
msgstr ""
"从数据结构的角度来看，Option 有点像一个可为空的类型或最多可以包含一个条目的列表。从控制结构的角度来看，Option "
"表示一个可能在没有结果的情况下提前终止的计算。通常，使用函子实例的程序最容易被认为是将 Option "
"用作数据结构，而使用单子实例的程序最容易被认为是使用 Option 来允许早期失败，但学习流畅地使用这两种视角是精通函数式编程的重要组成部分。"

#: src/functor-applicative-monad.md:12
#, fuzzy
msgid ""
"There is a deeper relationship between functors and monads. It turns out "
"that _every monad is a functor_. Another way to say this is that the monad "
"abstraction is more powerful than the functor abstraction, because not every"
" functor is a monad. Furthermore, there is an additional intermediate "
"abstraction, called _applicative functors_, that has enough power to write "
"many interesting programs and yet permits libraries that cannot use the "
"`Monad` interface. The type class `Applicative` provides the overloadable "
"operations of applicative functors. Every monad is an applicative functor, "
"and every applicative functor is a functor, but the converses do not hold."
msgstr ""
"函子和单子之间存在更深层次的关系。事实证明，每个单子都是一个函子。另一种说法是，单子抽象比函子抽象更强大，因为并非每个函子都是单子。此外，还有一个称为应用函子的附加中间抽象，它有足够的能力编写许多有趣的程序，但允许使用无法使用单子接口的库。类型类"
" Applicative 提供了应用函子的可重载操作。每个单子都是一个应用函子，每个应用函子都是一个函子，但逆否命题不成立。"
