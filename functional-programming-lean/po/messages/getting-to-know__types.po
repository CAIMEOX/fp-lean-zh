#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/getting-to-know/types.md:3
#, fuzzy
msgid ""
"Types classify programs based on the values that they can compute. Types "
"serve a number of roles in a program:"
msgstr "类型根据程序可以计算的值对程序进行分类。类型在程序中扮演着多种角色："

#: src/getting-to-know/types.md:6
#, fuzzy
msgid ""
"They allow the compiler to make decisions about the in-memory representation"
" of a value."
msgstr "它们允许编译器对值的内存表示做出决策。"

#: src/getting-to-know/types.md:9
#, fuzzy
msgid ""
"They help programmers to communicate their intent to others, serving as a "
"lightweight specification for the inputs and outputs of a function that the "
"compiler can ensure the program adheres to."
msgstr "它们帮助程序员向他人传达他们的意图，作为编译器可以确保程序遵守的函数输入和输出的轻量级规范。"

#: src/getting-to-know/types.md:13
#, fuzzy
msgid ""
"They prevent various potential mistakes, such as adding a number to a "
"string, and thus reduce the number of tests that are necessary for a "
"program."
msgstr "它们防止各种潜在错误，例如将数字添加到字符串中，从而减少了程序所需的测试数量。"

#: src/getting-to-know/types.md:17
#, fuzzy
msgid ""
"They help the Lean compiler automate the production of auxiliary code that "
"can save boilerplate."
msgstr "它们帮助 Lean 编译器自动生成辅助代码，可以节省样板代码。"

#: src/getting-to-know/types.md:19
#, fuzzy
msgid ""
"Lean's type system is unusually expressive. Types can encode strong "
"specifications like \"this sorting function returns a permutation of its "
"input\" and flexible specifications like \"this function has different "
"return types, depending on the value of its argument\". The type system can "
"even be used as a full-blown logic for proving mathematical theorems. This "
"cutting-edge expressive power doesn't obviate the need for simpler types, "
"however, and understanding these simpler types is a prerequisite for using "
"the more advanced features."
msgstr ""
"Lean "
"的类型系统具有非同寻常的表现力。类型可以编码强规范，例如“此排序函数返回其输入的排列”，以及灵活的规范，例如“此函数具有不同的返回类型，具体取决于其参数的值”。类型系统甚至可以用作证明数学定理的完整逻辑。然而，这种尖端的表现力并不能消除对更简单类型的需求，理解这些更简单的类型是使用更高级功能的先决条件。"

#: src/getting-to-know/types.md:24
#, fuzzy
msgid ""
"Every program in Lean must have a type. In particular, every expression must"
" have a type before it can be evaluated. In the examples so far, Lean has "
"been able to discover a type on its own, but it is sometimes necessary to "
"provide one. This is done using the colon operator:"
msgstr ""
"Lean 中的每个程序都必须有一个类型。特别是，每个表达式在求值之前都必须具有类型。在迄今为止的示例中，Lean "
"已经能够自行发现类型，但有时需要提供一个类型。这是使用冒号运算符完成的："

#: src/getting-to-know/types.md:34
#, fuzzy
msgid ""
"Here, `Nat` is the type of _natural numbers_, which are arbitrary-precision "
"unsigned integers. In Lean, `Nat` is the default type for non-negative "
"integer literals. This default type is not always the best choice. In C, "
"unsigned integers underflow to the largest representable numbers when "
"subtraction would otherwise yield a result less than zero. `Nat`, however, "
"can represent arbitrarily-large unsigned numbers, so there is no largest "
"number to underflow to. Thus, subtraction on `Nat` returns `0` when the "
"answer would have otherwise been negative. For instance,"
msgstr ""
"在此，`Nat` 是 _自然数_ 的类型，它们是任意精度的无符号整数。在 Lean 中，`Nat` "
"是非负整数字面量的默认类型。此默认类型并不总是最佳选择。在 C 中，当减法运算结果小于零时，无符号整数会下溢到最大的可表示数字。然而，`Nat` "
"可以表示任意大的无符号数字，因此没有最大的数字可以下溢到。因此，当答案原本为负数时，`Nat` 上的减法运算返回 `0`。例如，"

#: src/getting-to-know/types.md:46
#, fuzzy
msgid ""
"evaluates to `0` rather than `-1`. To use a type that can represent the "
"negative integers, provide it directly:"
msgstr "求值为 `0` 而不是 `-1`。若要使用可以表示负整数的类型，请直接提供它："

#: src/getting-to-know/types.md:54
#, fuzzy
msgid "With this type, the result is `-1`, as expected."
msgstr "使用此类型，结果为 `-1`，符合预期。"

#: src/getting-to-know/types.md:56
#, fuzzy
msgid ""
"To check the type of an expression without evaluating it, use `#check` "
"instead of `#eval`. For instance:"
msgstr "若要检查表达式的类型而不求值，请使用 `#check` 而不是 `#eval`。例如："

#: src/getting-to-know/types.md:63
#, fuzzy
msgid "reports `1 - 2 : Int` without actually performing the subtraction."
msgstr "报告 `1 - 2 : Int` 而不会实际执行减法运算。"

#: src/getting-to-know/types.md:65
#, fuzzy
msgid ""
"When a program can't be given a type, an error is returned from both "
"`#check` and `#eval`. For instance:"
msgstr "当无法为程序指定类型时，`#check` 和 `#eval` 都会返回错误。例如："

#: src/getting-to-know/types.md:68
#, fuzzy
msgid ""
"```lean\n"
"#check String.append \"hello\" [\" \", \"world\"]\n"
"```"
msgstr ""
"```lean\n"
"#check String.append \"hello\" [\" \", \"world\"]\n"
"```"

#: src/getting-to-know/types.md:72
#: src/getting-to-know/functions-and-definitions.md:26
#: src/programs-proofs/fin.md:48 src/programs-proofs/fin.md:56
#, fuzzy
msgid "outputs"
msgstr "输出"

#: src/getting-to-know/types.md:74
#, fuzzy
msgid ""
"```output error\n"
"application type mismatch\n"
"  String.append \"hello\" [\" \", \"world\"]\n"
"argument\n"
"  [\" \", \"world\"]\n"
"has type\n"
"  List String : Type\n"
"but is expected to have type\n"
"  String : Type\n"
"```"
msgstr ""
"```output error\n"
"应用程序类型不匹配\n"
"  String.append \"hello\" [\" \", \"world\"]\n"
"参数\n"
"  [\" \", \"world\"]\n"
"类型为\n"
"  List String : Type\n"
"但预期类型为\n"
"  String : Type\n"
"```"

#: src/getting-to-know/types.md:85
#, fuzzy
msgid ""
"because the second argument to `String.append` is expected to be a string, "
"but a list of strings was provided instead."
msgstr "因为 `String.append` 的第二个参数应为字符串，但提供的是字符串列表。"
