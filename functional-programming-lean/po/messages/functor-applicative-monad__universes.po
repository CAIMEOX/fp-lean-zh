#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/functor-applicative-monad/universes.md:3
#, fuzzy
msgid ""
"In the interests of simplicity, this book has thus far papered over an "
"important feature of Lean: _universes_. A universe is a type that classifies"
" other types. Two of them are familiar: `Type` and `Prop`. `Type` classifies"
" ordinary types, such as `Nat`, `String`, `Int → String × Char`, and `IO "
"Unit`. `Prop` classifies propositions that may be true or false, such as "
"`\"nisse\" = \"elf\"` or `3 > 2`. The type of `Prop` is `Type`:"
msgstr ""
"为了简单起见，本书迄今为止一直掩盖了 Lean 的一个重要特性：_universe_。universe "
"是对其他类型进行分类的类型。其中两个很熟悉：`Type` 和 `Prop`。`Type` 对普通类型进行分类，例如 "
"`Nat`、`String`、`Int → String × Char` 和 `IO Unit`。`Prop` 对可能为真或假的命题进行分类，例如 "
"`\"nisse\" = \"elf\"` 或 `3 > 2`。`Prop` 的类型是 `Type`："

#: src/functor-applicative-monad/universes.md:16
#, fuzzy
msgid ""
"For technical reasons, more universes than these two are needed. In "
"particular, `Type` cannot itself be a `Type`. This would allow a logical "
"paradox to be constructed and undermine Lean's usefulness as a theorem "
"prover."
msgstr ""
"出于技术原因，需要比这两个更多的 universe。特别是，`Type` 本身不能是 `Type`。这将允许构建一个逻辑悖论，并破坏 Lean "
"作为定理证明器的效用。"

#: src/functor-applicative-monad/universes.md:20
#, fuzzy
msgid ""
"The formal argument for this is known as _Girard's Paradox_. It related to a"
" better-known paradox known as _Russell's Paradox_, which was used to show "
"that early versions of set theory were inconsistent. In these set theories, "
"a set can be defined by a property. For example, one might have the set of "
"all red things, the set of all fruit, the set of all natural numbers, or "
"even the set of all sets. Given a set, one can ask whether a given element "
"is contained in it. For instance, a bluebird is not contained in the set of "
"all red things, but the set of all red things is contained in the set of all"
" sets. Indeed, the set of all sets even contains itself."
msgstr ""
"吉拉德悖论是这一形式化论证的名称。它与更著名的罗素悖论相关，后者被用来证明集合论的早期版本是不一致的。在这些集合论中，集合可以通过属性来定义。例如，我们可以有所有红色事物的集合、所有水果的集合、所有自然数的集合，甚至所有集合的集合。给定一个集合，我们可以询问给定的元素是否包含在其中。例如，一只蓝鸟不包含在所有红色事物的集合中，但所有红色事物的集合包含在所有集合的集合中。事实上，所有集合的集合甚至包含它自己。"

#: src/functor-applicative-monad/universes.md:28
#, fuzzy
msgid ""
"What about the set of all sets that do not contain themselves? It contains "
"the set of all red things, as the set of all red things is not itself red. "
"It does not contain the set of all sets, because the set of all sets "
"contains itself. But does it contain itself? If it does contain itself, then"
" it cannot contain itself. But if it does not, then it must."
msgstr ""
"那么所有不包含自己的集合的集合呢？它包含所有红色事物的集合，因为所有红色事物的集合本身不是红色的。它不包含所有集合的集合，因为所有集合的集合包含它自己。但它是否包含它自己？如果它包含它自己，那么它不能包含它自己。但如果它不包含它自己，那么它必须包含它自己。"

#: src/functor-applicative-monad/universes.md:35
#, fuzzy
msgid ""
"This is a contradiction, which demonstrates that something was wrong with "
"the initial assumptions. In particular, allowing sets to be constructed by "
"providing an arbitrary property is too powerful. Later versions of set "
"theory restrict the formation of sets to remove the paradox."
msgstr "这是一个矛盾，表明最初的假设出了问题。特别是，允许通过提供任意属性来构造集合过于强大。集合论的后续版本限制了集合的形成以消除这个悖论。"

#: src/functor-applicative-monad/universes.md:39
#, fuzzy
msgid ""
"A related paradox can be constructed in versions of dependent type theory "
"that assign the type `Type` to `Type`. To ensure that Lean has consistent "
"logical foundations and can be used as a tool for mathematics, `Type` needs "
"to have some other type. This type is called `Type 1`:"
msgstr ""
"在将类型 `Type` 赋值给 `Type` 的依赖类型论版本中，可以构造一个相关的悖论。为了确保 Lean "
"具有自洽的逻辑基础，并且可以用作数学工具，`Type` 需要具有其他类型。此类型称为 `Type 1`："

#: src/functor-applicative-monad/universes.md:48
#, fuzzy
msgid ""
"Similarly, `Type 1` is a `Type 2`, `Type 2` is a `Type 3`, `Type 3` is a "
"`Type 4`, and so forth."
msgstr "类似地，`Type 1` 是 `Type 2`，`Type 2` 是 `Type 3`，`Type 3` 是 `Type 4`，依此类推。"

#: src/functor-applicative-monad/universes.md:52
#, fuzzy
msgid ""
"Function types occupy the smallest universe that can contain both the "
"argument type and the return type. This means that `Nat → Nat` is a `Type`, "
"`Type → Type` is a `Type 1`, and `Type 1 → Type 2` is a `Type 3`."
msgstr ""
"函数类型占据了最小的类型域，它可以同时包含参数类型和返回类型。这意味着 `Nat → Nat` 是 `Type`，`Type → Type` 是 "
"`Type 1`，`Type 1 → Type 2` 是 `Type 3`。"

#: src/functor-applicative-monad/universes.md:55
#, fuzzy
msgid ""
"There is one exception to this rule. If the return type of a function is a "
"`Prop`, then the whole function type is in `Prop`, even if the argument is "
"in a larger universe such as `Type` or even `Type 1`. In particular, this "
"means that predicates over values that have ordinary types are in `Prop`. "
"For example, the type `(n : Nat) → n = n + 0` represents a function from a "
"`Nat` to evidence that it is equal to itself plus zero. Even though `Nat` is"
" in `Type`, this function type is in `Prop` due to this rule. Similarly, "
"even though `Type` is in `Type 1`, the function type `Type → 2 + 2 = 4` is "
"still in `Prop`."
msgstr ""
"对于此规则有一个例外。如果函数的返回类型是 `Prop`，那么整个函数类型就在 `Prop` 中，即使参数在更大的类型域中，例如 `Type` 甚至 "
"`Type 1`。具体来说，这意味着对具有普通类型的值的谓词在 `Prop` 中。例如，类型 `(n : Nat) → n = n + 0` 表示从 "
"`Nat` 到证明它等于自身加零的证据的函数。即使 `Nat` 在 `Type` 中，此函数类型也由于此规则而在 `Prop` 中。类似地，即使 "
"`Type` 在 `Type 1` 中，函数类型 `Type → 2 + 2 = 4` 仍然在 `Prop` 中。"

#: src/functor-applicative-monad/universes.md:62
#, fuzzy
msgid "User Defined Types"
msgstr "用户定义类型"

#: src/functor-applicative-monad/universes.md:64
#, fuzzy
msgid ""
"Structures and inductive datatypes can be declared to inhabit particular "
"universes. Lean then checks whether each datatype avoids paradoxes by being "
"in a universe that's large enough to prevent it from containing its own "
"type. For instance, in the following declaration, `MyList` is declared to "
"reside in `Type`, and so is its type argument `α`:"
msgstr ""
"可以声明结构和归纳数据类型来占据特定的类型域。然后，Lean "
"会检查每个数据类型是否通过位于足够大的类型域中来避免悖论，以防止它包含自己的类型。例如，在以下声明中，`MyList` 被声明为驻留在 `Type` "
"中，其类型参数 `α` 也是如此："

#: src/functor-applicative-monad/universes.md:72
#, fuzzy
msgid ""
"`MyList` itself is a `Type → Type`. This means that it cannot be used to "
"contain actual types, because then its argument would be `Type`, which is a "
"`Type 1`:"
msgstr ""
"`MyList` 本身是 `Type → Type`。这意味着它不能用于包含实际类型，因为那时它的参数将是 `Type`，而 `Type` 是 "
"`Type 1`："

#: src/functor-applicative-monad/universes.md:89
#, fuzzy
msgid ""
"Updating `MyList` so that its argument is a `Type 1` results in a definition"
" rejected by Lean:"
msgstr "更新 `MyList` 以使其参数为 `Type 1` 会导致 Lean 拒绝的定义："

#: src/functor-applicative-monad/universes.md:103
#, fuzzy
msgid ""
"This error occurs because the argument to `cons` with type `α` is from a "
"larger universe than `MyList`. Placing `MyList` itself in `Type 1` solves "
"this issue, but at the cost of `MyList` now being itself inconvenient to use"
" in contexts that expect a `Type`."
msgstr ""
"此错误发生的原因是 `cons` 的参数类型 `α` 大于 `MyList` 的类型域。将 `MyList` 本身放在 `Type 1` "
"中可以解决此问题，但代价是 `MyList` 本身在需要 `Type` 的上下文中使用时会不方便。"

#: src/functor-applicative-monad/universes.md:106
#, fuzzy
msgid ""
"The specific rules that govern whether a datatype is allowed are somewhat "
"complicated. Generally speaking, it's easiest to start with the datatype in "
"the same universe as the largest of its arguments. Then, if Lean rejects the"
" definition, increase its level by one, which will usually go through."
msgstr ""
"控制数据类型是否允许的具体规则有些复杂。一般来说，最简单的方法是从数据类型与其最大参数相同的类型域开始。然后，如果 Lean "
"拒绝定义，则将其级别增加一，这通常会通过。"

#: src/functor-applicative-monad/universes.md:110
#, fuzzy
msgid "Universe Polymorphism"
msgstr "类型域多态"

#: src/functor-applicative-monad/universes.md:112
#, fuzzy
msgid ""
"Defining a datatype in a specific universe can lead to code duplication. "
"Placing `MyList` in `Type → Type` means that it can't be used for an actual "
"list of types. Placing it in `Type 1 → Type 1` means that it can't be used "
"for a list of lists of types. Rather than copy-pasting the datatype to "
"create versions in `Type`, `Type 1`, `Type 2`, and so on, a feature called "
"_universe polymorphism_ can be used to write a single definition that can be"
" instantiated in any of these universes."
msgstr ""
"在特定类型域中定义数据类型会导致代码重复。将 `MyList` 放在 `Type → Type` 中意味着它不能用于实际的类型列表。将其放在 `Type"
" 1 → Type 1` 中意味着它不能用于类型列表的列表。与其复制粘贴数据类型以创建 `Type`、`Type 1`、`Type 2` "
"等版本，不如使用称为 _类型域多态_ 的特性来编写一个可以在任何这些类型域中实例化的单个定义。"

#: src/functor-applicative-monad/universes.md:117
#, fuzzy
msgid ""
"Ordinary polymorphic types use variables to stand for types in a definition."
" This allows Lean to fill in the variables differently, which enables these "
"definitions to be used with a variety of types. Similarly, universe "
"polymorphism allows variables to stand for universes in a definition, "
"enabling Lean to fill them in differently so that they can be used with a "
"variety of universes. Just as type arguments are conventionally named with "
"Greek letters, universe arguments are conventionally named `u`, `v`, and "
"`w`."
msgstr ""
"普通的多态类型使用变量来表示定义中的类型。这允许 Lean "
"以不同的方式填充变量，从而使这些定义可以与各种类型一起使用。类似地，类型域多态允许变量表示定义中的类型域，从而使 Lean "
"可以以不同的方式填充它们，以便它们可以与各种类型域一起使用。就像类型参数通常用希腊字母命名一样，类型域参数通常用 `u`、`v` 和 `w` 命名。"

#: src/functor-applicative-monad/universes.md:122
#, fuzzy
msgid ""
"This definition of `MyList` doesn't specify a particular universe level, but"
" instead uses a variable `u` to stand for any level. If the resulting "
"datatype is used with `Type`, then `u` is `0`, and if it's used with `Type "
"3`, then `u` is `3`:"
msgstr ""
"此 `MyList` 定义未指定特定宇宙级别，而是使用变量 `u` 表示任意级别。如果结果数据类型与 `Type` 一起使用，则 `u` 为 "
"`0`，如果与 `Type 3` 一起使用，则 `u` 为 `3`："

#: src/functor-applicative-monad/universes.md:130
#, fuzzy
msgid ""
"With this definition, the same definition of `MyList` can be used to contain"
" both actual natural numbers and the natural number type itself:"
msgstr "有了此定义，相同的 `MyList` 定义可用于同时包含实际自然数和自然数类型本身："

#: src/functor-applicative-monad/universes.md:138
#, fuzzy
msgid "It can even contain itself:"
msgstr "它甚至可以包含自身："

#: src/functor-applicative-monad/universes.md:144
#, fuzzy
msgid ""
"It would seem that this would make it possible to write a logical paradox. "
"After all, the whole point of the universe system is to rule out self-"
"referential types. Behind the scenes, however, each occurrence of `MyList` "
"is provided with a universe level argument. In essence, the universe-"
"polymorphic definition of `MyList` created a _copy_ of the datatype at each "
"level, and the level argument selects which copy is to be used. These level "
"arguments are written with a dot and curly braces, so `MyList.{0} : Type → "
"Type`, `MyList.{1} : Type 1 → Type 1`, and `MyList.{2} : Type 2 → Type 2`."
msgstr ""
"这似乎可以写出逻辑悖论。毕竟，宇宙系统的主要目的是排除自引用类型。然而，在幕后，每次出现 `MyList` "
"都会提供一个宇宙级别参数。本质上，`MyList` 的宇宙多态定义在每个级别创建了数据类型的 "
"_副本_，而级别参数选择要使用的副本。这些级别参数用点和大括号编写，因此 `MyList.{0} : Type → Type`、`MyList.{1} "
": Type 1 → Type 1` 和 `MyList.{2} : Type 2 → Type 2`。"

#: src/functor-applicative-monad/universes.md:150
#, fuzzy
msgid "Writing the levels explicitly, the prior example becomes:"
msgstr "明确编写级别后，前面的示例变为："

#: src/functor-applicative-monad/universes.md:162
#, fuzzy
msgid ""
"When a universe-polymorphic definition takes multiple types as arguments, "
"it's a good idea to give each argument its own level variable for maximum "
"flexibility. For example, a version of `Sum` with a single level argument "
"can be written as follows:"
msgstr ""
"当宇宙多态定义将多个类型作为参数时，最好为每个参数提供自己的级别变量以实现最大的灵活性。例如，可以将具有单个级别参数的 `Sum` 版本写为："

#: src/functor-applicative-monad/universes.md:169
#, fuzzy
msgid "This definition can be used at multiple levels:"
msgstr "此定义可在多个级别使用："

#: src/functor-applicative-monad/universes.md:170
msgid ""
"```lean\n"
"def stringOrNat : Sum String Nat := .inl \"hello\"\n"
"\n"
"def typeOrType : Sum Type Type := .inr Nat\n"
"```"
msgstr ""

#: src/functor-applicative-monad/universes.md:175
#, fuzzy
msgid "However, it requires that both arguments be in the same universe:"
msgstr "但是，它要求两个参数都在同一宇宙中："

#: src/functor-applicative-monad/universes.md:190
#, fuzzy
msgid ""
"This datatype can be made more flexible by using different variables for the"
" two type arguments' universe levels, and then declaring that the resulting "
"datatype is in the largest of the two:"
msgstr "可以通过对两个类型参数的宇宙级别使用不同的变量，然后声明结果数据类型位于两者中较大的一个中，来使此数据类型更灵活："

#: src/functor-applicative-monad/universes.md:196
#, fuzzy
msgid "This allows `Sum` to be used with arguments from different universes:"
msgstr "`Sum` 可用于不同宇宙中的参数："

#: src/functor-applicative-monad/universes.md:201
#, fuzzy
msgid ""
"In positions where Lean expects a universe level, any of the following are "
"allowed:"
msgstr "在 Lean 期望宇宙级别的位置，允许以下任何内容："

#: src/functor-applicative-monad/universes.md:202
#, fuzzy
msgid "A concrete level, like `0` or `1`"
msgstr "具体级别，如 `0` 或 `1`"

#: src/functor-applicative-monad/universes.md:203
#, fuzzy
msgid "A variable that stands for a level, such as `u` or `v`"
msgstr "表示级别的变量，如 `u` 或 `v`"

#: src/functor-applicative-monad/universes.md:204
#, fuzzy
msgid "The maximum of two levels, written as `max` applied to the levels"
msgstr "两个级别的最大值，写为应用于级别的 `max`"

#: src/functor-applicative-monad/universes.md:205
#, fuzzy
msgid "A level increase, written with `+ 1`"
msgstr "级别增加，用 `+ 1` 编写"

#: src/functor-applicative-monad/universes.md:207
#, fuzzy
msgid "Writing Universe-Polymorphic Definitions"
msgstr "编写宇宙多态定义"

#: src/functor-applicative-monad/universes.md:209
#, fuzzy
msgid ""
"Until now, every datatype defined in this book has been in `Type`, the "
"smallest universe of data. When presenting polymorphic datatypes from the "
"Lean standard library, such as `List` and `Sum`, this book created non-"
"universe-polymorphic versions of them. The real versions use universe "
"polymorphism to enable code re-use between type-level and non-type-level "
"programs."
msgstr ""
"到目前为止，本书中定义的每个数据类型都在 `Type` 中，这是最小的数据宇宙。在从 Lean 标准库中展示多态数据类型（如 `List` 和 "
"`Sum`）时，本书创建了它们的非宇宙多态版本。真实版本使用宇宙多态性，以便在类型级别和非类型级别程序之间重新使用代码。"

#: src/functor-applicative-monad/universes.md:213
#, fuzzy
msgid ""
"There are a few general guidelines to follow when writing universe-"
"polymorphic types. First off, independent type arguments should have "
"different universe variables, which enables the polymorphic definition to be"
" used with a wider variety of arguments, increasing the potential for code "
"reuse. Secondly, the whole type is itself typically either in the maximum of"
" all the universe variables, or one greater than this maximum. Try the "
"smaller of the two first. Finally, it's a good idea to put the new type in "
"as small of a universe as possible, which allows it to be used more flexibly"
" in other contexts. Non-polymorphic types, such as `Nat` and `String`, can "
"be placed directly in `Type 0`."
msgstr ""
"编写宇宙多态类型时，有一些通用的准则需要遵循。首先，独立类型参数应该有不同的宇宙变量，这使得多态定义可以与更广泛的参数一起使用，从而增加了代码重用的可能性。其次，整个类型本身通常要么是所有宇宙变量的最大值，要么比这个最大值大"
" 1。先尝试较小的一个。最后，最好将新类型放在尽可能小的宇宙中，这样可以在其他上下文中更灵活地使用它。非多态类型（如 `Nat` 和 "
"`String`）可以直接放在 `Type 0` 中。"

#: src/functor-applicative-monad/universes.md:220
#, fuzzy
msgid "`Prop` and Polymorphism"
msgstr "`Prop` 和多态性"

#: src/functor-applicative-monad/universes.md:222
#, fuzzy
msgid ""
"Just as `Type`, `Type 1`, and so on describe types that classify programs "
"and data, `Prop` classifies logical propositions. A type in `Prop` describes"
" what counts as convincing evidence for the truth of a statement. "
"Propositions are like ordinary types in many ways: they can be declared "
"inductively, they can have constructors, and functions can take propositions"
" as arguments. However, unlike datatypes, it typically doesn't matter "
"_which_ evidence is provided for the truth of a statement, only _that_ "
"evidence is provided. On the other hand, it is very important that a program"
" not only return a `Nat`, but that it's the _correct_ `Nat`."
msgstr ""
"就像 `Type`、`Type 1` 等描述对程序和数据进行分类的类型一样，`Prop` 对逻辑命题进行分类。`Prop` "
"中的类型描述了什么算作对某个陈述的真实性的令人信服的证据。命题在很多方面都像普通类型：它们可以被归纳声明，它们可以有构造函数，函数可以将命题作为参数。然而，与数据类型不同，通常并不重要为陈述的真实性提供了"
" _哪_ 个证据，只提供了 _那个_ 证据。另一方面，非常重要的是，程序不仅要返回一个 `Nat`，而且它是 _正确的_ `Nat`。"

#: src/functor-applicative-monad/universes.md:228
#, fuzzy
msgid ""
"`Prop` is at the bottom of the universe hierarchy, and the type of `Prop` is"
" `Type`. This means that `Prop` is a suitable argument to provide to `List`,"
" for the same reason that `Nat` is. Lists of propositions have type `List "
"Prop`:"
msgstr ""
"`Prop` 位于类型等级的底部，而 `Prop` 的类型是 `Type`。这意味着 `Prop` 是一个合适的参数来提供给 `List`，原因与 "
"`Nat` 相同。命题列表的类型为 `List Prop`："

#: src/functor-applicative-monad/universes.md:231
msgid ""
"```lean\n"
"def someTruePropositions : List Prop := [\n"
"  1 + 1 = 2,\n"
"  \"Hello, \" ++ \"world!\" = \"Hello, world!\"\n"
"]\n"
"```"
msgstr ""

#: src/functor-applicative-monad/universes.md:237
#, fuzzy
msgid ""
"Filling out the universe argument explicitly demonstrates that `Prop` is a "
"`Type`:"
msgstr "显式填写类型等级参数表明 `Prop` 是一个 `Type`："

#: src/functor-applicative-monad/universes.md:238
msgid ""
"```lean\n"
"def someTruePropositions : List.{0} Prop := [\n"
"  1 + 1 = 2,\n"
"  \"Hello, \" ++ \"world!\" = \"Hello, world!\"\n"
"]\n"
"```"
msgstr ""

#: src/functor-applicative-monad/universes.md:245
#, fuzzy
msgid ""
"Behind the scenes, `Prop` and `Type` are united into a single hierarchy "
"called `Sort`. `Prop` is the same as `Sort 0`, `Type 0` is `Sort 1`, `Type "
"1` is `Sort 2`, and so forth. In fact, `Type u` is the same as `Sort (u+1)`."
" When writing programs with Lean, this is typically not relevant, but it may"
" occur in error messages from time to time, and it explains the name of the "
"`CoeSort` class. Additionally, having `Prop` as `Sort 0` allows one more "
"universe operator to become useful. The universe level `imax u v` is `0` "
"when `v` is `0`, or the larger of `u` or `v` otherwise. Together with "
"`Sort`, this allows the special rule for functions that return `Prop`s to be"
" used when writing code that should be as portable as possible between "
"`Prop` and `Type` universes."
msgstr ""
"在幕后，`Prop` 和 `Type` 被统一到一个称为 `Sort` 的单一等级中。`Prop` 等同于 `Sort 0`，`Type 0` 是 "
"`Sort 1`，`Type 1` 是 `Sort 2`，以此类推。事实上，`Type u` 等同于 `Sort (u+1)`。在使用 Lean "
"编写程序时，这通常无关紧要，但它可能会偶尔出现在错误消息中，并且它解释了 `CoeSort` 类的名称。此外，将 `Prop` 作为 `Sort 0` "
"允许另一个类型等级运算符变得有用。当 `v` 为 `0` 时，类型等级 `imax u v` 为 `0`，否则为 `u` 或 `v` 中较大的那个。结合"
" `Sort`，这允许在编写尽可能在 `Prop` 和 `Type` 类型等级之间移植的代码时使用返回 `Prop` 的函数的特殊规则。"

#: src/functor-applicative-monad/universes.md:253
#, fuzzy
msgid "Polymorphism in Practice"
msgstr "实践中的多态性"

#: src/functor-applicative-monad/universes.md:255
#, fuzzy
msgid ""
"In the remainder of the book, definitions of polymorphic datatypes, "
"structures, and classes will use universe polymorphism in order to be "
"consistent with the Lean standard library. This will enable the complete "
"presentation of the `Functor`, `Applicative`, and `Monad` classes to be "
"completely consistent with their actual definitions."
msgstr ""
"在本书的其余部分中，多态数据类型、结构和类的定义将使用类型等级多态性，以便与 Lean 标准库保持一致。这将使 "
"`Functor`、`Applicative` 和 `Monad` 类的完整表示与它们的实际定义完全一致。"
