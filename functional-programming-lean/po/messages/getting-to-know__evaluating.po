#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/getting-to-know/evaluating.md:3
#, fuzzy
msgid ""
"The most important thing to understand as a programmer learning Lean is how "
"evaluation works. Evaluation is the process of finding the value of an "
"expression, just as one does in arithmetic. For instance, the value of 15 - "
"6 is 9 and the value of 2 × (3 + 1) is 8. To find the value of the latter "
"expression, 3 + 1 is first replaced by 4, yielding 2 × 4, which itself can "
"be reduced to 8. Sometimes, mathematical expressions contain variables: the "
"value of _x_ + 1 cannot be computed until we know what the value of _x_ is. "
"In Lean, programs are first and foremost expressions, and the primary way to"
" think about computation is as evaluating expressions to find their values."
msgstr ""
"作为学习 Lean 的程序员，最重要的是理解求值的工作原理。求值是查找表达式值的过程，就像在算术中所做的那样。例如，15 - 6 的值为 9，2 × "
"(3 + 1) 的值为 8。要查找后一个表达式的值，首先将 3 + 1 替换为 4，得到 2 × 4，它本身可以简化为 "
"8。有时，数学表达式包含变量：在知道 _x_ 的值之前，无法计算 _x_ + 1 的值。在 Lean "
"中，程序首先是表达式，思考计算的主要方式是将表达式求值以查找其值。"

#: src/getting-to-know/evaluating.md:11
#, fuzzy
msgid ""
"Most programming languages are _imperative_, where a program consists of a "
"series of statements that should be carried out in order to find the "
"program's result. Programs have access to mutable memory, so the value "
"referred to by a variable can change over time. In addition to mutable "
"state, programs may have other side effects, such as deleting files, making "
"outgoing network connections, throwing or catching exceptions, and reading "
"data from a database. \"Side effects\" is essentially a catch-all term for "
"describing things that may happen in a program that don't follow the model "
"of evaluating mathematical expressions."
msgstr ""
"大多数编程语言都是 "
"_命令式的_，其中程序由一系列语句组成，这些语句应按顺序执行以找到程序的结果。程序可以访问可变内存，因此变量引用的值可以随时间而改变。除了可变状态之外，程序还可能产生其他副作用，例如删除文件、建立传出网络连接、抛出或捕获异常以及从数据库读取数据。“副作用”本质上是一个总称，用于描述程序中可能发生的事情，这些事情不遵循求值数学表达式的模型。"

#: src/getting-to-know/evaluating.md:21
#, fuzzy
msgid ""
"In Lean, however, programs work the same way as mathematical expressions. "
"Once given a value, variables cannot be reassigned. Evaluating an expression"
" cannot have side effects. If two expressions have the same value, then "
"replacing one with the other will not cause the program to compute a "
"different result. This does not mean that Lean cannot be used to write "
"`Hello, world!` to the console, but performing I/O is not a core part of the"
" experience of using Lean in the same way. Thus, this chapter focuses on how"
" to evaluate expressions interactively with Lean, while the next chapter "
"describes how to write, compile, and run the `Hello, world!` program."
msgstr ""
"然而，在 Lean "
"中，程序的工作方式与数学表达式相同。一旦赋予一个值，变量就不能重新赋值。求值表达式不会产生副作用。如果两个表达式具有相同的值，那么用一个表达式替换另一个表达式不会导致程序计算出不同的结果。这并不意味着"
" Lean 不能用于向控制台写入 `Hello, world!`，但执行 I/O 并不是以相同方式使用 Lean 的核心部分。因此，本章重点介绍如何使用"
" Lean 交互式地求值表达式，而下一章将介绍如何编写、编译和运行 `Hello, world!` 程序。"

#: src/getting-to-know/evaluating.md:31
#, fuzzy
msgid ""
"To ask Lean to evaluate an expression, write `#eval` before it in your "
"editor, which will then report the result back. Typically, the result is "
"found by putting the cursor or mouse pointer over `#eval`. For instance,"
msgstr ""
"要让 Lean 求值一个表达式，请在编辑器中在其前面写 `#eval`，然后它将报告结果。通常，通过将光标或鼠标指针放在 `#eval` "
"上来找到结果。例如，"

#: src/getting-to-know/evaluating.md:39
#, fuzzy
msgid "yields the value `3`."
msgstr "产生值 `3`。"

#: src/getting-to-know/evaluating.md:41
#, fuzzy
msgid ""
"Lean obeys the ordinary rules of precedence and associativity for arithmetic"
" operators. That is,"
msgstr "Lean 遵循算术运算符的普通优先级和结合性规则。也就是说，"

#: src/getting-to-know/evaluating.md:47
#, fuzzy
msgid "yields the value `11` rather than `15`."
msgstr "会产生值 `11` 而不是 `15`。"

#: src/getting-to-know/evaluating.md:51
#, fuzzy
msgid ""
"While both ordinary mathematical notation and the majority of programming "
"languages use parentheses (e.g. `f(x)`) to apply a function to its "
"arguments, Lean simply writes the function next to its arguments (e.g. `f "
"x`). Function application is one of the most common operations, so it pays "
"to keep it concise. Rather than writing"
msgstr ""
"虽然普通的数学符号和大多数编程语言都使用括号（例如 `f(x)`）将函数应用于其参数，但 Lean 只是将函数写在其参数旁边（例如 `f "
"x`）。函数应用是最常见的操作之一，因此保持简洁很重要。与其编写"

#: src/getting-to-know/evaluating.md:56
#, fuzzy
msgid ""
"```lean\n"
"#eval String.append(\"Hello, \", \"Lean!\")\n"
"```"
msgstr ""
"```lean\n"
"#eval String.append(\"Hello, \", \"Lean!\")\n"
"```"

#: src/getting-to-know/evaluating.md:59
#, fuzzy
msgid "to compute `\"Hello, Lean!\"`, one would instead write"
msgstr "来计算 `\"Hello, Lean!\"`，不如编写"

#: src/getting-to-know/evaluating.md:61
#, fuzzy
msgid ""
"```Lean\n"
"#eval String.append \"Hello, \" \"Lean!\"\n"
"```"
msgstr ""
"```Lean\n"
"#eval String.append \"Hello, \" \"Lean!\"\n"
"```"

#: src/getting-to-know/evaluating.md:64
#, fuzzy
msgid ""
"where the function's two arguments are simply written next to it with "
"spaces."
msgstr "其中函数的两个参数只是用空格写在旁边。"

#: src/getting-to-know/evaluating.md:67
#, fuzzy
msgid ""
"Just as the order-of-operations rules for arithmetic demand parentheses in "
"the expression `(1 + 2) * 5`, parentheses are also necessary when a "
"function's argument is to be computed via another function call. For "
"instance, parentheses are required in"
msgstr ""
"就像算术的运算顺序规则要求在表达式 `(1 + 2) * 5` 中使用括号一样，当函数的参数要通过另一个函数调用来计算时，括号也是必需的。例如，在"

#: src/getting-to-know/evaluating.md:71
#, fuzzy
msgid ""
"```Lean\n"
"#eval String.append \"great \" (String.append \"oak \" \"tree\")\n"
"```"
msgstr ""
"```Lean\n"
"#eval String.append \"great \" (String.append \"oak \" \"tree\")\n"
"```"

#: src/getting-to-know/evaluating.md:74
#, fuzzy
msgid ""
"because otherwise the second `String.append` would be interpreted as an "
"argument to the first, rather than as a function being passed `\"oak \"` and"
" `\"tree\"` as arguments. The value of the inner `String.append` call must "
"be found first, after which it can be appended to `\"great \"`, yielding the"
" final value `\"great oak tree\"`."
msgstr ""
"中需要括号，因为否则第二个 `String.append` 将被解释为第一个参数，而不是作为将 `\"oak \"` 和 `\"tree\"` "
"作为参数传递的函数。必须先找到内部 `String.append` 调用的值，然后才能将其附加到 `\"great \"`，从而产生最终值 "
"`\"great oak tree\"`。"

#: src/getting-to-know/evaluating.md:80
#, fuzzy
msgid ""
"Imperative languages often have two kinds of conditional: a conditional "
"_statement_ that determines which instructions to carry out based on a "
"Boolean value, and a conditional _expression_ that determines which of two "
"expressions to evaluate based on a Boolean value. For instance, in C and "
"C++, the conditional statement is written using `if` and `else`, while the "
"conditional expression is written with a ternary operator `?` and `:`. In "
"Python, the conditional statement begins with `if`, while the conditional "
"expression puts `if` in the middle. Because Lean is an expression-oriented "
"functional language, there are no conditional statements, only conditional "
"expressions. They are written using `if`, `then`, and `else`. For instance,"
msgstr ""
"命令式语言通常有两种条件：根据布尔值确定要执行哪些指令的条件 _语句_，以及根据布尔值确定要计算两个表达式中哪一个的条件 _表达式_。例如，在 C 和 "
"C++ 中，条件语句使用 `if` 和 `else` 编写，而条件表达式使用三元运算符 `?` 和 `:` 编写。在 Python 中，条件语句以 "
"`if` 开头，而条件表达式将 `if` 放在中间。由于 Lean 是一种面向表达式的函数式语言，因此没有条件语句，只有条件表达式。它们使用 "
"`if`、`then` 和 `else` 编写。例如，"

#: src/getting-to-know/evaluating.md:92
#, fuzzy
msgid ""
"```Lean\n"
"String.append \"it is \" (if 1 > 2 then \"yes\" else \"no\")\n"
"```"
msgstr ""
"```lean\n"
"String.append \"它就是 \" (如果 1 > 2 那么 \"是\" 否则 \"否\")\n"
"```"

#: src/getting-to-know/evaluating.md:95
#: src/dependent-types/indexed-families.md:197
#: src/dependent-types/typed-queries.md:582
#, fuzzy
msgid "evaluates to"
msgstr "求值为"

#: src/getting-to-know/evaluating.md:96
#, fuzzy
msgid ""
"```Lean\n"
"String.append \"it is \" (if false then \"yes\" else \"no\")\n"
"```"
msgstr ""
"```lean\n"
"String.append \"它就是 \" (如果 false 那么 \"是\" 否则 \"否\")\n"
"```"

#: src/getting-to-know/evaluating.md:99
#, fuzzy
msgid "which evaluates to"
msgstr "求值为"

#: src/getting-to-know/evaluating.md:100
#, fuzzy
msgid ""
"```lean\n"
"String.append \"it is \" \"no\"\n"
"```"
msgstr ""
"```lean\n"
"String.append \"它就是 \" \"否\"\n"
"```"

#: src/getting-to-know/evaluating.md:103
#, fuzzy
msgid "which finally evaluates to `\"it is no\"`."
msgstr "最终求值为 `\"它就是否\"`。"

#: src/getting-to-know/evaluating.md:105
#, fuzzy
msgid ""
"For the sake of brevity, a series of evaluation steps like this will "
"sometimes be written with arrows between them:"
msgstr "为了简洁，有时会用箭头表示一系列求值步骤："

#: src/getting-to-know/evaluating.md:106
#, fuzzy
msgid ""
"```lean\n"
"String.append \"it is \" (if 1 > 2 then \"yes\" else \"no\")\n"
"===>\n"
"String.append \"it is \" (if false then \"yes\" else \"no\")\n"
"===>\n"
"String.append \"it is \" \"no\"\n"
"===>\n"
"\"it is no\"\n"
"```"
msgstr ""
"```lean\n"
"String.append \"它就是 \" (如果 1 > 2 那么 \"是\" 否则 \"否\")\n"
"===>\n"
"String.append \"它就是 \" (如果 false 那么 \"是\" 否则 \"否\")\n"
"===>\n"
"String.append \"它就是 \" \"否\"\n"
"===>\n"
"\"它就是否\"\n"
"```"

#: src/getting-to-know/evaluating.md:116
#: src/getting-to-know/functions-and-definitions.md:112
#: src/getting-to-know/polymorphism.md:466 src/props-proofs-indexing.md:254
#: src/type-classes/standard-classes.md:350 src/type-classes/coercion.md:402
#, fuzzy
msgid "Messages You May Meet"
msgstr "可能遇到的信息"

#: src/getting-to-know/evaluating.md:118
#, fuzzy
msgid ""
"Asking Lean to evaluate a function application that is missing an argument "
"will lead to an error message. In particular, the example"
msgstr "要求 Lean 求值缺少参数的函数应用将导致错误信息。特别是，示例"

#: src/getting-to-know/evaluating.md:120
#, fuzzy
msgid ""
"```lean\n"
"#eval String.append \"it is \"\n"
"```"
msgstr ""
"```lean\n"
"#eval String.append \"它就是 \"\n"
"```"

#: src/getting-to-know/evaluating.md:123
#, fuzzy
msgid "yields a quite long error message:"
msgstr "会产生一个很长的错误信息："

#: src/getting-to-know/evaluating.md:124
#, fuzzy
msgid ""
"```output error\n"
"expression\n"
"  String.append \"it is \"\n"
"has type\n"
"  String → String\n"
"but instance\n"
"  Lean.MetaEval (String → String)\n"
"failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.MetaEval` class\n"
"```"
msgstr ""
"```output error\n"
"表达式\n"
"  String.append \"它就是 \"\n"
"类型为\n"
"  String → String\n"
"但实例\n"
"  Lean.MetaEval (String → String)\n"
"合成失败，此实例指示 Lean 如何显示结果值，回想一下任何实现 `Repr` 类的类型也实现了 `Lean.MetaEval` 类\n"
"```"

#: src/getting-to-know/evaluating.md:134
#, fuzzy
msgid ""
"This message occurs because Lean functions that are applied to only some of "
"their arguments return new functions that are waiting for the rest of the "
"arguments. Lean cannot display functions to users, and thus returns an error"
" when asked to do so."
msgstr ""
"出现此信息是因为仅应用于部分参数的 Lean 函数会返回等待其余参数的新函数。Lean 无法向用户显示函数，因此在被要求这样做时会返回错误。"

#: src/getting-to-know/evaluating.md:138
#: src/getting-to-know/functions-and-definitions.md:87
#: src/getting-to-know/structures.md:318
#: src/getting-to-know/polymorphism.md:522 src/props-proofs-indexing.md:287
#: src/type-classes/pos.md:303 src/type-classes/polymorphism.md:127
#: src/type-classes/out-params.md:180 src/type-classes/standard-classes.md:365
#: src/monads/class.md:222 src/monads/arithmetic.md:646 src/monads/do.md:157
#: src/functor-applicative-monad/alternative.md:241
#: src/functor-applicative-monad/complete.md:152
#: src/monad-transformers/reader-io.md:381
#: src/monad-transformers/transformers.md:496
#: src/monad-transformers/order.md:135 src/monad-transformers/do.md:649
#: src/dependent-types/indexed-families.md:262
#: src/dependent-types/universe-pattern.md:325
#: src/dependent-types/typed-queries.md:738
#: src/dependent-types/pitfalls.md:470 src/tactics-induction-proofs.md:418
#: src/programs-proofs/tail-recursion.md:202
#: src/programs-proofs/arrays-termination.md:330
#: src/programs-proofs/inequalities.md:784
#: src/programs-proofs/insertion-sort.md:916
#, fuzzy
msgid "Exercises"
msgstr "练习"

#: src/getting-to-know/evaluating.md:140
#, fuzzy
msgid ""
"What are the values of the following expressions? Work them out by hand, "
"then enter them into Lean to check your work."
msgstr "以下表达式的值是什么？手动计算，然后输入 Lean 以检查你的工作。"

#: src/getting-to-know/evaluating.md:143
#, fuzzy
msgid "`42 + 19`"
msgstr "`42 + 19`"

#: src/getting-to-know/evaluating.md:144
#, fuzzy
msgid "`String.append \"A\" (String.append \"B\" \"C\")`"
msgstr "`String.append \"A\" (String.append \"B\" \"C\")`"

#: src/getting-to-know/evaluating.md:145
#, fuzzy
msgid "`String.append (String.append \"A\" \"B\") \"C\"`"
msgstr "`String.append (String.append \"A\" \"B\") \"C\"`"

#: src/getting-to-know/evaluating.md:146
#, fuzzy
msgid "`if 3 == 3 then 5 else 7`"
msgstr "如果 3 == 3 则返回 5 否则返回 7"

#: src/getting-to-know/evaluating.md:147
#, fuzzy
msgid "`if 3 == 4 then \"equal\" else \"not equal\"`"
msgstr "如果 3 == 4 则返回 \"相等\" 否则返回 \"不相等\""
