#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/hello-world/step-by-step.md:3
#, fuzzy
msgid ""
"A `do` block can be executed one line at a time. Start with the program from"
" the prior section:"
msgstr "`do` 块可以逐行执行。从上一节的程序开始："

#: src/hello-world/step-by-step.md:5
#, fuzzy
msgid ""
"```lean\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/step-by-step.md:14
#, fuzzy
msgid "Standard IO"
msgstr "标准 IO"

#: src/hello-world/step-by-step.md:16
#, fuzzy
msgid "The first line is `  let stdin ← IO.getStdin`, while the remainder is:"
msgstr "第一行是 `  let stdin ← IO.getStdin`，其余部分是："

#: src/hello-world/step-by-step.md:17
#, fuzzy
msgid ""
"```lean\n"
"  let stdout ← IO.getStdout\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"  let stdout ← IO.getStdout\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/step-by-step.md:24
#, fuzzy
msgid ""
"To execute a `let` statement that uses a `←`, start by evaluating the "
"expression to the right of the arrow (in this case, `IO.getStdIn`). Because "
"this expression is just a variable, its value is looked up. The resulting "
"value is a built-in primitive `IO` action. The next step is to execute this "
"`IO` action, resulting in a value that represents the standard input stream,"
" which has type `IO.FS.Stream`. Standard input is then associated with the "
"name to the left of the arrow (here `stdin`) for the remainder of the `do` "
"block."
msgstr ""
"要执行使用 `←` 的 `let` 语句，首先求值箭头右侧的表达式（在本例中为 "
"`IO.getStdIn`）。因为这个表达式只是一个变量，所以查找它的值。结果值是一个内置的原始 `IO` 操作。下一步是执行此 `IO` "
"操作，结果是一个表示标准输入流的值，其类型为 `IO.FS.Stream`。然后将标准输入与箭头左侧的名称（此处为 `stdin`）关联，以用于 "
"`do` 块的其余部分。"

#: src/hello-world/step-by-step.md:30
#, fuzzy
msgid ""
"Executing the second line, `  let stdout ← IO.getStdout`, proceeds "
"similarly. First, the expression `IO.getStdout` is evaluated, yielding an "
"`IO` action that will return the standard output. Next, this action is "
"executed, actually returning the standard output. Finally, this value is "
"associated with the name `stdout` for the remainder of the `do` block."
msgstr ""
"执行第二行 `let stdout ← IO.getStdout` 的过程类似。首先，求值表达式 `IO.getStdout`，得到一个 `IO` "
"动作，该动作将返回标准输出。接下来，执行此动作，实际返回标准输出。最后，将此值与 `do` 块的其余部分关联起来，并命名为 `stdout`。"

#: src/hello-world/step-by-step.md:35
#, fuzzy
msgid "Asking a Question"
msgstr "提问"

#: src/hello-world/step-by-step.md:37
#, fuzzy
msgid ""
"Now that `stdin` and `stdout` have been found, the remainder of the block "
"consists of a question and an answer:"
msgstr "现在已经找到了 `stdin` 和 `stdout`，该块的其余部分包括一个问题和一个答案："

#: src/hello-world/step-by-step.md:38
#, fuzzy
msgid ""
"```lean\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/step-by-step.md:45
#, fuzzy
msgid ""
"The first statement in the block, `  stdout.putStrLn \"How would you like to"
" be addressed?\"`, consists of an expression. To execute an expression, it "
"is first evaluated. In this case, `IO.FS.Stream.putStrLn` has type "
"`IO.FS.Stream → String → IO Unit`. This means that it is a function that "
"accepts a stream and a string, returning an `IO` action. The expression uses"
" [accessor notation](../getting-to-know/structures.md#behind-the-scenes) for"
" a function call. This function is applied to two arguments: the standard "
"output stream and a string. The value of the expression is an `IO` action "
"that will write the string and a newline character to the output stream. "
"Having found this value, the next step is to execute it, which causes the "
"string and newline to actually be written to `stdout`. Statements that "
"consist only of expressions do not introduce any new variables."
msgstr ""
"该块中的第一个语句 `stdout.putStrLn \"How would you like to be addressed?\"` "
"由一个表达式组成。要执行一个表达式，首先要对其求值。在这种情况下，`IO.FS.Stream.putStrLn` 的类型为 `IO.FS.Stream "
"→ String → IO Unit`。这意味着它是一个接受流和字符串并返回 `IO` 动作的函数。该表达式使用 "
"[访问器表示法](../getting-to-know/structures.md#behind-the-scenes) "
"进行函数调用。此函数应用于两个参数：标准输出流和字符串。表达式的值为一个 `IO` "
"动作，该动作将字符串和换行符写入输出流。找到此值后，下一步是执行它，这会导致字符串和换行符实际写入 "
"`stdout`。仅由表达式组成的语句不会引入任何新变量。"

#: src/hello-world/step-by-step.md:55
#, fuzzy
msgid ""
"The next statement in the block is `  let input ← stdin.getLine`. "
"`IO.FS.Stream.getLine` has type `IO.FS.Stream → IO String`, which means that"
" it is a function from a stream to an `IO` action that will return a string."
" Once again, this is an example of accessor notation. This `IO` action is "
"executed, and the program waits until the user has typed a complete line of "
"input. Assume the user writes \"`David`\". The resulting line "
"(`\"David\\n\"`) is associated with `input`, where the escape sequence `\\n`"
" denotes the newline character."
msgstr ""
"下一条语句是 `let input ← stdin.getLine`。`IO.FS.Stream.getLine` 的类型是 `IO.FS.Stream"
" → IO String`，这意味着它是一个从流到 `IO` 操作的函数，该操作将返回一个字符串。同样，这也是访问器表示法的示例。此 `IO` "
"操作被执行，程序等待用户键入一行完整的输入。假设用户输入了“`David`”。结果行（“`David\\n`”）与 `input` 关联，其中转义序列 "
"`\\n` 表示换行符。"

#: src/hello-world/step-by-step.md:62
#, fuzzy
msgid ""
"```lean\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"let name := input.dropRightWhile Char.isWhitespace\n"
"stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/step-by-step.md:67
#, fuzzy
msgid ""
"The next line, `  let name := input.dropRightWhile Char.isWhitespace`, is a "
"`let` statement. Unlike the other `let` statements in this program, it uses "
"`:=` instead of `←`. This means that the expression will be evaluated, but "
"the resulting value need not be an `IO` action and will not be executed. In "
"this case, `String.dropRightWhile` takes a string and a predicate over "
"characters and returns a new string from which all the characters at the end"
" of the string that satisfy the predicate have been removed. For example,"
msgstr ""
"下一行 `let name := input.dropRightWhile Char.isWhitespace` 是一个 `let` "
"语句。与本程序中的其他 `let` 语句不同，它使用 `:=` 而不是 `←`。这意味着将计算表达式，但结果值不必是 `IO` "
"操作，并且不会执行。在这种情况下，`String.dropRightWhile` "
"接受一个字符串和一个字符谓词，并返回一个新字符串，其中字符串末尾满足谓词的所有字符都被删除。例如，"

#: src/hello-world/step-by-step.md:72
#, fuzzy
msgid ""
"```lean\n"
"#eval \"Hello!!!\".dropRightWhile (· == '!')\n"
"```"
msgstr ""
"```lean\n"
"#eval \"Hello!!!\".dropRightWhile (· == '!')\n"
"```"

#: src/hello-world/step-by-step.md:75 src/hello-world/step-by-step.md:83
#: src/type-classes/out-params.md:165
#, fuzzy
msgid "yields"
msgstr "产生"

#: src/hello-world/step-by-step.md:76 src/hello-world/step-by-step.md:84
#, fuzzy
msgid ""
"```output info\n"
"\"Hello\"\n"
"```"
msgstr ""
"```output info\n"
"\"Hello\"\n"
"```"

#: src/hello-world/step-by-step.md:80
#, fuzzy
msgid ""
"```lean\n"
"#eval \"Hello...   \".dropRightWhile (fun c => not (c.isAlphanum))\n"
"```"
msgstr ""
"```lean\n"
"#eval \"Hello...   \".dropRightWhile (fun c => not (c.isAlphanum))\n"
"```"

#: src/hello-world/step-by-step.md:87
#, fuzzy
msgid ""
"in which all non-alphanumeric characters have been removed from the right "
"side of the string. In the current line of the program, whitespace "
"characters (including the newline) are removed from the right side of the "
"input string, resulting in `\"David\"`, which is associated with `name` for "
"the remainder of the block."
msgstr ""
"其中所有非字母数字字符已从字符串的右侧删除。在程序的当前行中，空格字符（包括换行符）从输入字符串的右侧删除，得到 “`David`”，它在块的剩余部分与"
" `name` 关联。"

#: src/hello-world/step-by-step.md:91
#, fuzzy
msgid "Greeting the User"
msgstr "向用户问好"

#: src/hello-world/step-by-step.md:93
#, fuzzy
msgid ""
"All that remains to be executed in the `do` block is a single statement:"
msgstr "`do` 块中剩余要执行的只有一条语句："

#: src/hello-world/step-by-step.md:94
#, fuzzy
msgid ""
"```lean\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/step-by-step.md:97
#, fuzzy
msgid ""
"The string argument to `putStrLn` is constructed via string interpolation, "
"yielding the string `\"Hello, David!\"`. Because this statement is an "
"expression, it is evaluated to yield an `IO` action that will print this "
"string with a newline to standard output. Once the expression has been "
"evaluated, the resulting `IO` action is executed, resulting in the greeting."
msgstr ""
"传递给 `putStrLn` 的字符串参数通过字符串插值构建，生成字符串 `\"Hello, "
"David!\"`。由于此语句是一个表达式，因此它被求值以生成一个 `IO` "
"动作，该动作将使用换行符将此字符串打印到标准输出。表达式求值后，将执行生成的 `IO` 动作，从而生成问候语。"

#: src/hello-world/step-by-step.md:101
#, fuzzy
msgid "`IO` Actions as Values"
msgstr "`IO` 动作作为值"

#: src/hello-world/step-by-step.md:103
#, fuzzy
msgid ""
"In the above description, it can be difficult to see why the distinction "
"between evaluating expressions and executing `IO` actions is necessary. "
"After all, each action is executed immediately after it is produced. Why not"
" simply carry out the effects during evaluation, as is done in other "
"languages?"
msgstr ""
"在上述描述中，可能很难看出为什么需要区分求值表达式和执行 `IO` "
"动作。毕竟，每个动作在生成后都会立即执行。为什么不干脆在求值期间执行效果，就像在其他语言中所做的那样呢？"

#: src/hello-world/step-by-step.md:107
#, fuzzy
msgid ""
"The answer is twofold. First off, separating evaluation from execution means"
" that programs must be explicit about which functions can have side effects."
" Because the parts of the program that do not have effects are much more "
"amenable to mathematical reasoning, whether in the heads of programmers or "
"using Lean's facilities for formal proof, this separation can make it easier"
" to avoid bugs. Secondly, not all `IO` actions need be executed at the time "
"that they come into existence. The ability to mention an action without "
"carrying it out allows ordinary functions to be used as control structures."
msgstr ""
"答案有两个。首先，将求值与执行分开意味着程序必须明确说明哪些函数可以产生副作用。由于没有副作用的程序部分更适合数学推理，无论是在程序员的头脑中还是使用 "
"Lean 的形式化证明工具，这种分离可以更容易地避免错误。其次，并非所有 `IO` "
"动作都需要在它们产生时执行。在不执行动作的情况下提及动作的能力允许将普通函数用作控制结构。"

#: src/hello-world/step-by-step.md:113
#, fuzzy
msgid ""
"For instance, the function `twice` takes an `IO` action as its argument, "
"returning a new action that will execute the first one twice."
msgstr "例如，函数 `twice` 将 `IO` 动作作为其参数，返回一个新的动作，该动作将第一个动作执行两次。"

#: src/hello-world/step-by-step.md:119
#, fuzzy
msgid "For instance, executing"
msgstr "例如，执行"

#: src/hello-world/step-by-step.md:120
#, fuzzy
msgid ""
"```lean\n"
"twice (IO.println \"shy\")\n"
"```"
msgstr ""
"```lean\n"
"twice (IO.println \"shy\")\n"
"```"

#: src/hello-world/step-by-step.md:123
#: src/type-classes/standard-classes.md:266 src/monads/io.md:22
#: src/monads/io.md:34
#, fuzzy
msgid "results in"
msgstr "会打印"

#: src/hello-world/step-by-step.md:128
#, fuzzy
msgid ""
"being printed. This can be generalized to a version that runs the underlying"
" action any number of times:"
msgstr "。这可以推广到一个版本，它可以运行底层操作任意次："

#: src/hello-world/step-by-step.md:137
#, fuzzy
msgid ""
"In the base case for `Nat.zero`, the result is `pure ()`. The function "
"`pure` creates an `IO` action that has no side effects, but returns `pure`'s"
" argument, which in this case is the constructor for `Unit`. As an action "
"that does nothing and returns nothing interesting, `pure ()` is at the same "
"time utterly boring and very useful. In the recursive step, a `do` block is "
"used to create an action that first executes `action` and then executes the "
"result of the recursive call. Executing `nTimes (IO.println \"Hello\") 3` "
"causes the following output:"
msgstr ""
"在 `Nat.zero` 的基本情况下，结果是 `pure ()`。函数 `pure` 创建一个没有副作用的 `IO` 操作，但返回 `pure` "
"的参数，在本例中是 `Unit` 的构造函数。作为不执行任何操作且不返回任何有趣内容的操作，`pure ()` "
"既非常无聊又非常有用。在递归步骤中，`do` 块用于创建一个操作，该操作首先执行 `action`，然后执行递归调用的结果。执行 `nTimes "
"(IO.println \"Hello\") 3` 会导致以下输出："

#: src/hello-world/step-by-step.md:148
#, fuzzy
msgid ""
"In addition to using functions as control structures, the fact that `IO` "
"actions are first-class values means that they can be saved in data "
"structures for later execution. For instance, the function `countdown` takes"
" a `Nat` and returns a list of unexecuted `IO` actions, one for each `Nat`:"
msgstr ""
"除了将函数用作控制结构之外，`IO` 操作是一等值的事实意味着它们可以保存在数据结构中以供以后执行。例如，函数 `countdown` 接受一个 "
"`Nat` 并返回一个未执行的 `IO` 操作列表，每个 `Nat` 一个："

#: src/hello-world/step-by-step.md:150
#, fuzzy
msgid ""
"```lean\n"
"def countdown : Nat → List (IO Unit)\n"
"  | 0 => [IO.println \"Blast off!\"]\n"
"  | n + 1 => IO.println s!\"{n + 1}\" :: countdown n\n"
"```"
msgstr ""
"```lean\n"
"def countdown : Nat → List (IO Unit)\n"
"  | 0 => [IO.println \"Blast off!\"]\n"
"  | n + 1 => IO.println s!\"{n + 1}\" :: countdown n\n"
"```"

#: src/hello-world/step-by-step.md:155
#, fuzzy
msgid ""
"This function has no side effects, and does not print anything. For example,"
" it can be applied to an argument, and the length of the resulting list of "
"actions can be checked:"
msgstr "此函数没有副作用，并且不打印任何内容。例如，它可以应用于一个参数，并且可以检查结果操作列表的长度："

#: src/hello-world/step-by-step.md:160
#, fuzzy
msgid ""
"This list contains six elements (one for each number, plus a `\"Blast "
"off!\"` action for zero):"
msgstr "此列表包含六个元素（每个数字一个，外加一个零的 `\"Blast off!\"` 操作）："

#: src/hello-world/step-by-step.md:168
#, fuzzy
msgid ""
"The function `runActions` takes a list of actions and constructs a single "
"action that runs them all in order:"
msgstr "函数 `runActions` 接受一个操作列表，并构造一个按顺序运行所有操作的单个操作："

#: src/hello-world/step-by-step.md:176
#, fuzzy
msgid ""
"Its structure is essentially the same as that of `nTimes`, except instead of"
" having one action that is executed for each `Nat.succ`, the action under "
"each `List.cons` is to be executed. Similarly, `runActions` does not itself "
"run the actions. It creates a new action that will run them, and that action"
" must be placed in a position where it will be executed as a part of `main`:"
msgstr ""
"其结构本质上与 `nTimes` 相同，只是没有一个对每个 `Nat.succ` 执行的动作，而是在每个 `List.cons` "
"下的动作将被执行。类似地，`runActions` 本身不会运行这些动作。它创建一个将运行这些动作的新动作，并且该动作必须放置在将作为 `main` "
"的一部分执行的位置："

#: src/hello-world/step-by-step.md:182
#, fuzzy
msgid "Running this program results in the following output:"
msgstr "运行此程序会产生以下输出："

#: src/hello-world/step-by-step.md:192
#, fuzzy
msgid ""
"What happens when this program is run? The first step is to evaluate `main`."
" That occurs as follows:"
msgstr "当运行此程序时会发生什么？第一步是评估 `main`。它发生如下："

#: src/hello-world/step-by-step.md:194
#, fuzzy
msgid ""
"```lean\n"
"main\n"
"===>\n"
"runActions from5\n"
"===>\n"
"runActions (countdown 5)\n"
"===>\n"
"runActions\n"
"  [IO.println \"5\",\n"
"   IO.println \"4\",\n"
"   IO.println \"3\",\n"
"   IO.println \"2\",\n"
"   IO.println \"1\",\n"
"   IO.println \"Blast off!\"]\n"
"===>\n"
"do IO.println \"5\"\n"
"   IO.println \"4\"\n"
"   IO.println \"3\"\n"
"   IO.println \"2\"\n"
"   IO.println \"1\"\n"
"   IO.println \"Blast off!\"\n"
"   pure ()\n"
"```"
msgstr ""
"```lean\n"
"main\n"
"===>\n"
"runActions from5\n"
"===>\n"
"runActions (countdown 5)\n"
"===>\n"
"runActions\n"
"  [IO.println \"5\",\n"
"   IO.println \"4\",\n"
"   IO.println \"3\",\n"
"   IO.println \"2\",\n"
"   IO.println \"1\",\n"
"   IO.println \"Blast off!\"]\n"
"===>\n"
"do IO.println \"5\"\n"
"   IO.println \"4\"\n"
"   IO.println \"3\"\n"
"   IO.println \"2\"\n"
"   IO.println \"1\"\n"
"   IO.println \"Blast off!\"\n"
"   pure ()\n"
"```"

#: src/hello-world/step-by-step.md:217
#, fuzzy
msgid ""
"The resulting `IO` action is a `do` block. Each step of the `do` block is "
"then executed, one at a time, yielding the expected output. The final step, "
"`pure ()`, does not have any effects, and it is only present because the "
"definition of `runActions` needs a base case."
msgstr ""
"结果的 `IO` 动作是一个 `do` 块。然后逐个执行 `do` 块的每个步骤，产生预期的输出。最后一步 `pure ()` "
"没有产生任何效果，它只存在是因为 `runActions` 的定义需要一个基本情况。"

#: src/hello-world/step-by-step.md:221 src/hello-world/cat.md:226
#: src/programs-proofs/tail-recursion-proofs.md:464
#: src/programs-proofs/fin.md:41 src/programs-proofs/special-types.md:51
#, fuzzy
msgid "Exercise"
msgstr "练习"

#: src/hello-world/step-by-step.md:223
#, fuzzy
msgid ""
"Step through the execution of the following program on a piece of paper:"
msgstr "在纸上逐步执行以下程序："

#: src/hello-world/step-by-step.md:224
#, fuzzy
msgid ""
"```lean\n"
"def main : IO Unit := do\n"
"  let englishGreeting := IO.println \"Hello!\"\n"
"  IO.println \"Bonjour!\"\n"
"  englishGreeting\n"
"```"
msgstr ""
"```lean\n"
"def main : IO Unit := do\n"
"  let englishGreeting := IO.println \"Hello!\"\n"
"  IO.println \"Bonjour!\"\n"
"  englishGreeting\n"
"```"

#: src/hello-world/step-by-step.md:230
#, fuzzy
msgid ""
"While stepping through the program's execution, identify when an expression "
"is being evaluated and when an `IO` action is being executed. When executing"
" an `IO` action results in a side effect, write it down. After doing this, "
"run the program with Lean and double-check that your predictions about the "
"side effects were correct."
msgstr ""
"在逐步执行程序时，识别何时正在评估表达式以及何时正在执行 `IO` 动作。当执行 `IO` 动作导致副作用时，将其写下来。执行此操作后，使用 Lean "
"运行程序，并仔细检查你对副作用的预测是否正确。"
