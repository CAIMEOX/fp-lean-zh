#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/type-classes/standard-classes.md:3
#, fuzzy
msgid ""
"This section presents a variety of operators and functions that can be "
"overloaded using type classes in Lean. Each operator or function corresponds"
" to a method of a type class. Unlike C++, infix operators in Lean are "
"defined as abbreviations for named functions; this means that overloading "
"them for new types is not done using the operator itself, but rather using "
"the underlying name (such as `HAdd.hAdd`)."
msgstr ""
"本节介绍了可以在 Lean 中使用类型类重载的各种运算符和函数。每个运算符或函数都对应于类型类的某个方法。与 C++ 不同，Lean "
"中的前缀运算符被定义为命名函数的缩写；这意味着为新类型重载它们不是使用运算符本身，而是使用底层名称（例如 `HAdd.hAdd`）。"

#: src/type-classes/standard-classes.md:7
#, fuzzy
msgid "Arithmetic"
msgstr "算术"

#: src/type-classes/standard-classes.md:9
#, fuzzy
msgid ""
"Most arithmetic operators are available in a heterogeneous form, where the "
"arguments may have different type and an output parameter decides the type "
"of the resulting expression. For each heterogeneous operator, there is a "
"corresponding homogeneous version that can found by removing the letter `h`,"
" so that `HAdd.hAdd` becomes `Add.add`. The following arithmetic operators "
"are overloaded:"
msgstr ""
"大多数算术运算符都以异构形式提供，其中参数可以有不同的类型，输出参数决定结果表达式的类型。对于每个异构运算符，都有一个相应的同构版本，可以通过删除字母 "
"`h` 来找到，因此 `HAdd.hAdd` 变为 `Add.add`。重载了以下算术运算符："

#: src/type-classes/standard-classes.md:13
#: src/type-classes/standard-classes.md:31
#: src/type-classes/standard-classes.md:98 src/monad-transformers/do.md:424
#: src/programs-proofs/arrays-termination.md:19
#, fuzzy
msgid "Expression"
msgstr "表达式"

#: src/type-classes/standard-classes.md:13
#: src/type-classes/standard-classes.md:31
#: src/type-classes/standard-classes.md:98
#: src/programs-proofs/arrays-termination.md:19
#, fuzzy
msgid "Desugaring"
msgstr "去糖"

#: src/type-classes/standard-classes.md:13
#: src/type-classes/standard-classes.md:31
#: src/type-classes/standard-classes.md:98
#: src/programs-proofs/arrays-termination.md:19
#, fuzzy
msgid "Class Name"
msgstr "类名"

#: src/type-classes/standard-classes.md:15
#, fuzzy
msgid "`x + y`"
msgstr "`x + y`"

#: src/type-classes/standard-classes.md:15
#, fuzzy
msgid "`HAdd.hAdd x y`"
msgstr "`HAdd.hAdd x y`"

#: src/type-classes/standard-classes.md:15
#, fuzzy
msgid "`HAdd`"
msgstr "`HAdd`"

#: src/type-classes/standard-classes.md:16
#, fuzzy
msgid "`x - y`"
msgstr "`x - y`"

#: src/type-classes/standard-classes.md:16
#, fuzzy
msgid "`HSub.hSub x y`"
msgstr "`HSub.hSub x y`"

#: src/type-classes/standard-classes.md:16
#, fuzzy
msgid "`HSub`"
msgstr "`HSub`"

#: src/type-classes/standard-classes.md:17
#, fuzzy
msgid "`x * y`"
msgstr "`x * y`"

#: src/type-classes/standard-classes.md:17
#, fuzzy
msgid "`HMul.hMul x y`"
msgstr "`HMul.hMul x y`"

#: src/type-classes/standard-classes.md:17
#, fuzzy
msgid "`HMul`"
msgstr "`HMul`"

#: src/type-classes/standard-classes.md:18
#, fuzzy
msgid "`x / y`"
msgstr "`x / y`"

#: src/type-classes/standard-classes.md:18
#, fuzzy
msgid "`HDiv.hDiv x y`"
msgstr "`HDiv.hDiv x y`"

#: src/type-classes/standard-classes.md:18
#, fuzzy
msgid "`HDiv`"
msgstr "`HDiv`"

#: src/type-classes/standard-classes.md:19
#, fuzzy
msgid "`x % y`"
msgstr "`x % y`"

#: src/type-classes/standard-classes.md:19
#, fuzzy
msgid "`HMod.hMod x y`"
msgstr "`HMod.hMod x y`"

#: src/type-classes/standard-classes.md:19
#, fuzzy
msgid "`HMod`"
msgstr "`HMod`"

#: src/type-classes/standard-classes.md:20
#, fuzzy
msgid "`x ^ y`"
msgstr "`x ^ y`"

#: src/type-classes/standard-classes.md:20
#, fuzzy
msgid "`HPow.hPow x y`"
msgstr "`HPow.hPow x y`"

#: src/type-classes/standard-classes.md:20
#, fuzzy
msgid "`HPow`"
msgstr "`HPow`"

#: src/type-classes/standard-classes.md:21
#, fuzzy
msgid "`(- x)`"
msgstr "`(- x)`"

#: src/type-classes/standard-classes.md:21
#, fuzzy
msgid "`Neg.neg x`"
msgstr "`Neg.neg x`"

#: src/type-classes/standard-classes.md:21
#, fuzzy
msgid "`Neg`"
msgstr "`Neg`"

#: src/type-classes/standard-classes.md:24
#, fuzzy
msgid "Bitwise Operators"
msgstr "位运算符"

#: src/type-classes/standard-classes.md:26
#, fuzzy
msgid ""
"Lean contains a number of standard bitwise operators that are overloaded "
"using type classes. There are instances for fixed-width types such as "
"`UInt8`, `UInt16`, `UInt32`, `UInt64`, and `USize`. The latter is the size "
"of words on the current platform, typically 32 or 64 bits. The following "
"bitwise operators are overloaded:"
msgstr ""
"Lean 包含许多使用类型类重载的标准位运算符。有针对固定宽度类型（如 `UInt8`、`UInt16`、`UInt32`、`UInt64` 和 "
"`USize`）的实例。后者是当前平台上字的大小，通常为 32 或 64 位。重载了以下位运算符："

#: src/type-classes/standard-classes.md:33
#, fuzzy
msgid "`x &&& y`"
msgstr "`x &&& y`"

#: src/type-classes/standard-classes.md:33
#, fuzzy
msgid "`HAnd.hAnd x y`"
msgstr "`HAnd.hAnd x y`"

#: src/type-classes/standard-classes.md:33
#, fuzzy
msgid "`HAnd`"
msgstr "`HAnd`"

#: src/type-classes/standard-classes.md:34
#, fuzzy
msgid "x \\|\\|\\| y "
msgstr "x \\|\\|\\| y "

#: src/type-classes/standard-classes.md:34
#, fuzzy
msgid "`HOr.hOr x y`"
msgstr "`HOr.hOr x y`"

#: src/type-classes/standard-classes.md:34
#, fuzzy
msgid "`HOr`"
msgstr "`HOr`"

#: src/type-classes/standard-classes.md:35
#, fuzzy
msgid "`x ^^^ y`"
msgstr "`x ^^^ y`"

#: src/type-classes/standard-classes.md:35
#, fuzzy
msgid "`HXor.hXor x y`"
msgstr "`HXor.hXor x y`"

#: src/type-classes/standard-classes.md:35
#, fuzzy
msgid "`HXor`"
msgstr "`HXor`"

#: src/type-classes/standard-classes.md:36
#, fuzzy
msgid "`~~~ x`"
msgstr "`~~~ x`"

#: src/type-classes/standard-classes.md:36
#, fuzzy
msgid "`Complement.complement x`"
msgstr "`Complement.complement x`"

#: src/type-classes/standard-classes.md:36
#, fuzzy
msgid "`Complement`"
msgstr "`Complement`"

#: src/type-classes/standard-classes.md:37
#, fuzzy
msgid "`x >>> y`"
msgstr "`x >>> y`"

#: src/type-classes/standard-classes.md:37
#, fuzzy
msgid "`HShiftRight.hShiftRight x y`"
msgstr "`HShiftRight.hShiftRight x y`"

#: src/type-classes/standard-classes.md:37
#, fuzzy
msgid "`HShiftRight`"
msgstr "`HShiftRight`"

#: src/type-classes/standard-classes.md:38
#, fuzzy
msgid "`x <<< y`"
msgstr "`x <<< y`"

#: src/type-classes/standard-classes.md:38
#, fuzzy
msgid "`HShiftLeft.hShiftLeft x y`"
msgstr "`HShiftLeft.hShiftLeft x y`"

#: src/type-classes/standard-classes.md:38
#, fuzzy
msgid "`HShiftLeft`"
msgstr "`HShiftLeft`"

#: src/type-classes/standard-classes.md:40
#, fuzzy
msgid ""
"Because the names `And` and `Or` are already taken as the names of logical "
"connectives, the homogeneous versions of `HAnd` and `HOr` are called `AndOp`"
" and `OrOp` rather than `And` and `Or`."
msgstr ""
"由于 `And` 和 `Or` 已被用作逻辑连接符的名称，因此 `HAnd` 和 `HOr` 的同构版本被称为 `AndOp` 和 `OrOp`，而不是"
" `And` 和 `Or`。"

#: src/type-classes/standard-classes.md:42
#, fuzzy
msgid "Equality and Ordering"
msgstr "相等性和排序"

#: src/type-classes/standard-classes.md:44
#, fuzzy
msgid ""
"Testing equality of two values typically uses the `BEq` class, which is "
"short for \"Boolean equality\". Due to Lean's use as a theorem prover, there"
" are really two kinds of equality operators in Lean:"
msgstr ""
"测试两个值的相等性通常使用 `BEq` 类，它是“布尔相等性”的缩写。由于 Lean 用作定理证明器，因此 Lean 中实际上有两种相等性运算符："

#: src/type-classes/standard-classes.md:46
#, fuzzy
msgid ""
"_Boolean equality_ is the same kind of equality that is found in other "
"programming languages. It is a function that takes two values and returns a "
"`Bool`. Boolean equality is written with two equals signs, just as in Python"
" and C#. Because Lean is a pure functional language, there's no separate "
"notions of reference vs value equality—pointers cannot be observed directly."
msgstr ""
"_布尔相等性_与其他编程语言中发现的相等性类型相同。它是一个函数，它接受两个值并返回一个 `Bool`。布尔相等性用两个等号编写，就像在 Python "
"和 C# 中一样。由于 Lean 是一种纯函数式语言，因此没有引用相等与值相等的单独概念——指针不能直接观察到。"

#: src/type-classes/standard-classes.md:47
#, fuzzy
msgid ""
"_Propositional equality_ is the mathematical statement that two things are "
"equal. Propositional equality is not a function; rather, it is a "
"mathematical statement that admits proof. It is written with a single equals"
" sign. A statement of propositional equality is like a type that classifies "
"evidence of this equality."
msgstr ""
"_命题相等性_是两个事物相等的数学陈述。命题相等性不是一个函数；相反，它是一个承认证明的数学陈述。它用一个等号编写。命题相等性的陈述就像一个类型，它对这种相等性的证据进行分类。"

#: src/type-classes/standard-classes.md:49
#, fuzzy
msgid ""
"Both notions of equality are important, and used for different purposes. "
"Boolean equality is useful in programs, when a decision needs to be made "
"about whether two values are equal. For example, `\"Octopus\" ==  "
"\"Cuttlefish\"` evaluates to `false`, and `\"Octopodes\" ==  \"Octo\".append"
" \"podes\"` evaluates to `true`. Some values, such as functions, cannot be "
"checked for equality. For example, `(fun (x : Nat) => 1 + x) == (Nat.succ "
"·)` yields the error:"
msgstr ""
"这两种相等性的概念都很重要，并且用于不同的目的。布尔相等性在程序中很有用，当需要决定两个值是否相等时。例如，`\"Octopus\" ==  "
"\"Cuttlefish\"` 求值为 `false`，而 `\"Octopodes\" ==  \"Octo\".append \"podes\"` "
"求值为 `true`。某些值（例如函数）无法检查相等性。例如，`fun (x : Nat) => 1 + x) == (Nat.succ ·)` "
"会产生错误："

#: src/type-classes/standard-classes.md:58
#, fuzzy
msgid ""
"As this message indicates, `==` is overloaded using a type class. The "
"expression `x == y` is actually shorthand for `BEq.beq x y`."
msgstr "如该消息所示，`==` 使用类型类进行重载。表达式 `x == y` 实际上是 `BEq.beq x y` 的简写。"

#: src/type-classes/standard-classes.md:61
#, fuzzy
msgid ""
"Propositional equality is a mathematical statement rather than an invocation"
" of a program. Because propositions are like types that describe evidence "
"for some statement, propositional equality has more in common with types "
"like `String` and `Nat → List Int` than it does with Boolean equality. This "
"means that it can't automatically be checked. However, the equality of any "
"two expressions can be stated in Lean, so long as they have the same type. "
"The statement `(fun (x : Nat) => 1 + x) = (Nat.succ ·)` is a perfectly "
"reasonable statement. From the perspective of mathematics, two functions are"
" equal if they map equal inputs to equal outputs, so this statement is even "
"true, though it requires a two-line proof to convince Lean of this fact."
msgstr ""
"命题等价是一个数学陈述，而不是程序调用。由于命题类似于描述某个陈述证据的类型，因此命题等价与 `String` 和 `Nat → List Int` "
"等类型有更多共同点，而不是与布尔等价。这意味着它无法自动检查。但是，只要两个表达式的类型相同，就可以在 Lean 中陈述它们的等价性。陈述 `(fun "
"(x : Nat) => 1 + x) = (Nat.succ ·)` "
"是一个完全合理的陈述。从数学角度来看，如果两个函数将相等的输入映射到相等的输出，则这两个函数相等，因此该陈述甚至为真，尽管需要两行证明才能使 Lean "
"信服这一事实。"

#: src/type-classes/standard-classes.md:68
#, fuzzy
msgid ""
"Generally speaking, when using Lean as a programming language, it's easiest "
"to stick to Boolean functions rather than propositions. However, as the "
"names `true` and `false` for `Bool`'s constructors suggest, this difference "
"is sometimes blurred. Some propositions are _decidable_, which means that "
"they can be checked just like a Boolean function. The function that checks "
"whether the proposition is true or false is called a _decision procedure_, "
"and it returns _evidence_ of the truth or falsity of the proposition. Some "
"examples of decidable propositions include equality and inequality of "
"natural numbers, equality of strings, and \"ands\" and \"ors\" of "
"propositions that are themselves decidable."
msgstr ""
"一般来说，在将 Lean 用作编程语言时，最简单的方法是坚持使用布尔函数，而不是命题。但是，正如 `Bool` 构造函数的名称 `true` 和 "
"`false` 所示，这种差异有时会变得模糊。一些命题是 _可判定的_，这意味着它们可以像布尔函数一样被检查。检查命题真假的功能称为 "
"_判定程序_，它返回命题真假性的 _证据_。可判定的命题的一些示例包括自然数的相等性和不等性、字符串的相等性以及本身可判定的命题的“与”和“或”。"

#: src/type-classes/standard-classes.md:74
#, fuzzy
msgid ""
"In Lean, `if` works with decidable propositions. For example, `2 < 4` is a "
"proposition:"
msgstr "在 Lean 中，`if` 适用于可判定命题。例如，`2 < 4` 是一个命题："

#: src/type-classes/standard-classes.md:82
#, fuzzy
msgid ""
"Nonetheless, it is perfectly acceptable to write it as the condition in an "
"`if`. For example, `if 2 < 4 then 1 else 2` has type `Nat` and evaluates to "
"`1`."
msgstr ""
"尽管如此，将其作为 `if` 中的条件来编写是完全可以接受的。例如，`if 2 < 4 then 1 else 2` 的类型为 `Nat`，并求值为 "
"`1`。"

#: src/type-classes/standard-classes.md:86
#, fuzzy
msgid ""
"Not all propositions are decidable. If they were, then computers would be "
"able to prove any true proposition just by running the decision procedure, "
"and mathematicians would be out of a job. More specifically, decidable "
"propositions have an instance of the `Decidable` type class which has a "
"method that is the decision procedure. Trying to use a proposition that "
"isn't decidable as if it were a `Bool` results in a failure to find the "
"`Decidable` instance. For example, `if (fun (x : Nat) => 1 + x) = (Nat.succ "
"·) then \"yes\" else \"no\"` results in:"
msgstr ""
"并非所有命题都是可判定的。如果它们是可判定的，那么计算机将能够通过运行判定过程来证明任何真命题，而数学家将失业。更具体地说，可判定命题具有 "
"`Decidable` 类型类的实例，该实例具有作为判定过程的方法。尝试将不可判定的命题用作 `Bool` 会导致找不到 `Decidable` "
"实例。例如，`if (fun (x : Nat) => 1 + x) = (Nat.succ ·) then \"yes\" else \"no\"` "
"会导致："

#: src/type-classes/standard-classes.md:96
#, fuzzy
msgid ""
"The following propositions, that are usually decidable, are overloaded with "
"type classes:"
msgstr "以下命题通常是可判定的，它们与类型类重载："

#: src/type-classes/standard-classes.md:100
#: src/programs-proofs/arrays-termination.md:21
#, fuzzy
msgid "`x < y`"
msgstr "`x < y`"

#: src/type-classes/standard-classes.md:100
#: src/programs-proofs/arrays-termination.md:21
#, fuzzy
msgid "`LT.lt x y`"
msgstr "`LT.lt x y`"

#: src/type-classes/standard-classes.md:100
#: src/type-classes/standard-classes.md:102
#: src/programs-proofs/arrays-termination.md:21
#: src/programs-proofs/arrays-termination.md:23
#, fuzzy
msgid "`LT`"
msgstr "`LT`"

#: src/type-classes/standard-classes.md:101
#: src/programs-proofs/arrays-termination.md:22
#, fuzzy
msgid "`x ≤ y`"
msgstr "`x ≤ y`"

#: src/type-classes/standard-classes.md:101
#: src/programs-proofs/arrays-termination.md:22
#, fuzzy
msgid "`LE.le x y`"
msgstr "`LE.le x y`"

#: src/type-classes/standard-classes.md:101
#: src/type-classes/standard-classes.md:103
#: src/programs-proofs/arrays-termination.md:22
#: src/programs-proofs/arrays-termination.md:24
#, fuzzy
msgid "`LE`"
msgstr "`LE`"

#: src/type-classes/standard-classes.md:102
#: src/programs-proofs/arrays-termination.md:23
#, fuzzy
msgid "`x > y`"
msgstr "`x > y`"

#: src/type-classes/standard-classes.md:102
#: src/programs-proofs/arrays-termination.md:23
#, fuzzy
msgid "`LT.lt y x`"
msgstr "`LT.lt y x`"

#: src/type-classes/standard-classes.md:103
#: src/programs-proofs/arrays-termination.md:24
#, fuzzy
msgid "`x ≥ y`"
msgstr "`x ≥ y`"

#: src/type-classes/standard-classes.md:103
#: src/programs-proofs/arrays-termination.md:24
#, fuzzy
msgid "`LE.le y x`"
msgstr "`LE.le y x`"

#: src/type-classes/standard-classes.md:105
#, fuzzy
msgid ""
"Because defining new propositions hasn't yet been demonstrated, it may be "
"difficult to define new instances of `LT` and `LE`."
msgstr "由于尚未演示定义新命题，因此可能难以定义 `LT` 和 `LE` 的新实例。"

#: src/type-classes/standard-classes.md:107
#, fuzzy
msgid ""
"Additionally, comparing values using `<`, `==`, and `>` can be inefficient. "
"Checking first whether one value is less than another, and then whether they"
" are equal, can require two traversals over large data structures. To solve "
"this problem, Java and C# have standard `compareTo` and `CompareTo` methods "
"(respectively) that can be overridden by a class in order to implement all "
"three operations at the same time. These methods return a negative integer "
"if the receiver is less than the argument, zero if they are equal, and a "
"positive integer if the receiver is greater than the argument. Rather than "
"overload the meaning of integers, Lean has a built-in inductive type that "
"describes these three possibilities:"
msgstr ""
"此外，使用 `<`、`==` 和 `>` "
"比较值可能是低效的。首先检查一个值是否小于另一个值，然后检查它们是否相等，可能需要遍历大型数据结构两次。为了解决这个问题，Java 和 C# "
"分别具有标准的 `compareTo` 和 `CompareTo` "
"方法，可以由类重写以同时实现所有三个操作。如果接收者小于参数，则这些方法返回负整数；如果它们相等，则返回零；如果接收者大于参数，则返回正整数。Lean "
"并没有重载整数的含义，而是内置了一个归纳类型来描述这三种可能性："

#: src/type-classes/standard-classes.md:118
#, fuzzy
msgid ""
"The `Ord` type class can be overloaded to produce these comparisons. For "
"`Pos`, an implementation can be:"
msgstr "`Ord` 类型类可以被重载以产生这些比较。对于 `Pos`，实现可以是："

#: src/type-classes/standard-classes.md:130
#, fuzzy
msgid ""
"In situations where `compareTo` would be the right approach in Java, use "
"`Ord.compare` in Lean."
msgstr "在 Java 中 `compareTo` 是正确方法的情况下，在 Lean 中使用 `Ord.compare`。"

#: src/type-classes/standard-classes.md:132
#, fuzzy
msgid "Hashing"
msgstr "哈希"

#: src/type-classes/standard-classes.md:134
#, fuzzy
msgid ""
"Java and C# have `hashCode` and `GetHashCode` methods, respectively, that "
"compute a hash of a value for use in data structures such as hash tables. "
"The Lean equivalent is a type class called `Hashable`:"
msgstr ""
"Java 和 C# 分别具有 `hashCode` 和 `GetHashCode` "
"方法，它们计算值的哈希，以便在诸如哈希表之类的数据结构中使用。Lean 等效项是一个称为 `Hashable` 的类型类："

#: src/type-classes/standard-classes.md:140
#, fuzzy
msgid ""
"If two values are considered equal according to a `BEq` instance for their "
"type, then they should have the same hashes. In other words, if `x == y` "
"then `hash x == hash y`. If `x ≠ y`, then `hash x` won't necessarily differ "
"from `hash y` (after all, there are infinitely more `Nat` values than there "
"are `UInt64` values), but data structures built on hashing will have better "
"performance if unequal values are likely to have unequal hashes. This is the"
" same expectation as in Java and C#."
msgstr ""
"如果根据类型的 `BEq` 实例将两个值视为相等，则它们应具有相同的哈希值。换句话说，如果 `x == y`，则 `hash x == hash "
"y`。如果 `x ≠ y`，则 `hash x` 不一定与 `hash y` 不同（毕竟，`Nat` 值比 `UInt64` "
"值多得多），但是如果不相等的值可能具有不相等的哈希值，则基于哈希构建的数据结构将具有更好的性能。这与 Java 和 C# 中的期望相同。"

#: src/type-classes/standard-classes.md:145
#, fuzzy
msgid ""
"The standard library contains a function `mixHash` with type `UInt64 → "
"UInt64 → UInt64` that can be used to combine hashes for different fields for"
" a constructor. A reasonable hash function for an inductive datatype can be "
"written by assigning a unique number to each constructor, and then mixing "
"that number with the hashes of each field. For example, a `Hashable` "
"instance for `Pos` can be written:"
msgstr ""
"标准库包含一个类型为 `UInt64 → UInt64 → UInt64` 的函数 "
"`mixHash`，该函数可用于组合构造函数的不同字段的哈希值。可以通过为每个构造函数分配一个唯一数字，然后将该数字与每个字段的哈希值混合来编写归纳数据类型的合理哈希函数。例如，可以编写"
" `Pos` 的 `Hashable` 实例："

#: src/type-classes/standard-classes.md:156
#, fuzzy
msgid ""
"`Hashable` instances for polymorphic types can use recursive instance "
"search. Hashing a `NonEmptyList α` is only possible when `α` can be hashed:"
msgstr ""
"多态类型的 `Hashable` 实例可以使用递归实例搜索。仅当 `α` 可以被哈希时，才能对 `NonEmptyList α` 进行哈希："

#: src/type-classes/standard-classes.md:162
#, fuzzy
msgid ""
"Binary trees use both recursion and recursive instance search in the "
"implementations of `BEq` and `Hashable`:"
msgstr "二叉树在 `BEq` 和 `Hashable` 的实现中同时使用递归和递归实例搜索："

#: src/type-classes/standard-classes.md:190
#, fuzzy
msgid "Deriving Standard Classes"
msgstr "派生标准类"

#: src/type-classes/standard-classes.md:192
#, fuzzy
msgid ""
"Instance of classes like `BEq` and `Hashable` are often quite tedious to "
"implement by hand. Lean includes a feature called _instance deriving_ that "
"allows the compiler to automatically construct well-behaved instances of "
"many type classes. In fact, the `deriving Repr` phrase in the definition of "
"`Point` in the [section on structures](../getting-to-know/structures.md) is "
"an example of instance deriving."
msgstr ""
"`BEq` 和 `Hashable` 等类的实例通常很难手动实现。Lean 包含一个称为 _实例派生_ "
"的特性，允许编译器自动构建许多类型类的行为良好的实例。事实上，[结构部分](../getting-to-know/structures.md) 中 "
"`Point` 定义中的 `deriving Repr` 短语就是实例派生的一个例子。"

#: src/type-classes/standard-classes.md:196
#, fuzzy
msgid ""
"Instances can be derived in two ways. The first can be used when defining a "
"structure or inductive type. In this case, add `deriving` to the end of the "
"type declaration followed by the names of the classes for which instances "
"should be derived. For a type that is already defined, a standalone "
"`deriving` command can be used. Write `deriving instance C1, C2, ... for T` "
"to derive instances of `C1, C2, ...` for the type `T` after the fact."
msgstr ""
"实例可以通过两种方式派生。第一种可以在定义结构或归纳类型时使用。在这种情况下，在类型声明的末尾添加 "
"`deriving`，后跟应该派生实例的类的名称。对于已经定义的类型，可以使用独立的 `deriving` 命令。在 `T` 类型之后编写 "
"`deriving instance C1, C2, ... for T` 以派生 `C1, C2, ...` 的实例。"

#: src/type-classes/standard-classes.md:202
#, fuzzy
msgid ""
"`BEq` and `Hashable` instances can be derived for `Pos` and `NonEmptyList` "
"using a very small amount of code:"
msgstr "可以使用极少量的代码为 `Pos` 和 `NonEmptyList` 派生 `BEq` 和 `Hashable` 实例："

#: src/type-classes/standard-classes.md:208
#, fuzzy
msgid "Instances can be derived for at least the following classes:"
msgstr "至少可以为以下类派生实例："

#: src/type-classes/standard-classes.md:209
#, fuzzy
msgid "`Inhabited`"
msgstr "`Inhabited`"

#: src/type-classes/standard-classes.md:210
#, fuzzy
msgid "`BEq`"
msgstr "`BEq`"

#: src/type-classes/standard-classes.md:211
#, fuzzy
msgid "`Repr`"
msgstr "`Repr`"

#: src/type-classes/standard-classes.md:212
#, fuzzy
msgid "`Hashable`"
msgstr "`Hashable`"

#: src/type-classes/standard-classes.md:213
#, fuzzy
msgid "`Ord`"
msgstr "`Ord`"

#: src/type-classes/standard-classes.md:215
#, fuzzy
msgid ""
"In some cases, however, the derived `Ord` instance may not produce precisely"
" the ordering desired in an application. When this is the case, it's fine to"
" write an `Ord` instance by hand. The collection of classes for which "
"instances can be derived can be extended by advanced users of Lean."
msgstr ""
"然而，在某些情况下，派生的 `Ord` 实例可能无法产生应用程序中所需的精确排序。在这种情况下，手动编写 `Ord` 实例是可以的。高级 Lean "
"用户可以扩展可以派生实例的类的集合。"

#: src/type-classes/standard-classes.md:219
#, fuzzy
msgid ""
"Aside from the clear advantages in programmer productivity and code "
"readability, deriving instances also makes code easier to maintain, because "
"the instances are updated as the definitions of types evolve. Changesets "
"involving updates to datatypes are easier to read without line after line of"
" formulaic modifications to equality tests and hash computation."
msgstr ""
"除了在程序员生产力和代码可读性方面的明显优势之外，派生实例还使代码更容易维护，因为实例会随着类型定义的演变而更新。涉及数据类型更新的变更集更容易阅读，而无需对相等性测试和哈希计算进行逐行公式化修改。"

#: src/type-classes/standard-classes.md:222
#, fuzzy
msgid "Appending"
msgstr "追加"

#: src/type-classes/standard-classes.md:224
#, fuzzy
msgid ""
"Many datatypes have some sort of append operator. In Lean, appending two "
"values is overloaded with the type class `HAppend`, which is a heterogeneous"
" operation like that used for arithmetic operations:"
msgstr ""
"许多数据类型都有某种追加运算符。在 Lean 中，追加两个值使用类型类 `HAppend` 进行重载，这是一个异构操作，类似于用于算术操作的操作："

#: src/type-classes/standard-classes.md:230
#, fuzzy
msgid ""
"The syntax `xs ++ ys` desugars to `HAppend.hAppend xs ys`. For homogeneous "
"cases, it's enough to implement an instance of `Append`, which follows the "
"usual pattern:"
msgstr ""
"`xs ++ ys` 语法糖化为 `HAppend.hAppend xs ys`。对于同构情况，只需实现 `Append` "
"的一个实例，它遵循通常的模式："

#: src/type-classes/standard-classes.md:238
#, fuzzy
msgid "After defining the above instance,"
msgstr "定义上述实例后，"

#: src/type-classes/standard-classes.md:242
#, fuzzy
msgid "has the following output:"
msgstr "具有以下输出："

#: src/type-classes/standard-classes.md:243
#, fuzzy
msgid ""
"```output info\n"
"{ head := \"Banded Garden Spider\",\n"
"tail := [\"Long-legged Sac Spider\",\n"
"         \"Wolf Spider\",\n"
"         \"Hobo Spider\",\n"
"         \"Cat-faced Spider\",\n"
"         \"Banded Garden Spider\",\n"
"         \"Long-legged Sac Spider\",\n"
"         \"Wolf Spider\",\n"
"         \"Hobo Spider\",\n"
"         \"Cat-faced Spider\"] }\n"
"```"
msgstr ""
"```output info\n"
"{ head := \"Banded Garden Spider\",\n"
"tail := [\"Long-legged Sac Spider\",\n"
"         \"Wolf Spider\",\n"
"         \"Hobo Spider\",\n"
"         \"Cat-faced Spider\",\n"
"         \"Banded Garden Spider\",\n"
"         \"Long-legged Sac Spider\",\n"
"         \"Wolf Spider\",\n"
"         \"Hobo Spider\",\n"
"         \"Cat-faced Spider\"] }\n"
"```"

#: src/type-classes/standard-classes.md:256
#, fuzzy
msgid ""
"Similarly, a definition of `HAppend` allows non-empty lists to be appended "
"to ordinary lists:"
msgstr "类似地，`HAppend` 的定义允许将非空列表追加到普通列表："

#: src/type-classes/standard-classes.md:262
#, fuzzy
msgid "With this instance available,"
msgstr "使用此实例，"

#: src/type-classes/standard-classes.md:263
#, fuzzy
msgid ""
"```lean\n"
"#eval idahoSpiders ++ [\"Trapdoor Spider\"]\n"
"```"
msgstr ""
"```lean\n"
"#eval idahoSpiders ++ [\"Trapdoor Spider\"]\n"
"```"

#: src/type-classes/standard-classes.md:267
#, fuzzy
msgid ""
"```output info\n"
"{ head := \"Banded Garden Spider\",\n"
"  tail := [\"Long-legged Sac Spider\", \"Wolf Spider\", \"Hobo Spider\", \"Cat-faced Spider\", \"Trapdoor Spider\"] }\n"
"```"
msgstr ""
"```output info\n"
"{ head := \"Banded Garden Spider\",\n"
"  tail := [\"Long-legged Sac Spider\", \"Wolf Spider\", \"Hobo Spider\", \"Cat-faced Spider\", \"Trapdoor Spider\"] }\n"
"```"

#: src/type-classes/standard-classes.md:272 src/type-classes/summary.md:40
#, fuzzy
msgid "Functors"
msgstr "函子"

#: src/type-classes/standard-classes.md:274
#, fuzzy
msgid ""
"A polymorphic type is a _functor_ if it has an overload for a function named"
" `map` that transforms every element contained in it by a function. While "
"most languages use this terminology, C#'s equivalent to `map` is called "
"`System.Linq.Enumerable.Select`. For example, mapping a function over a list"
" constructs a new list in which each entry from the starting list has been "
"replaced by the result of the function on that entry. Mapping a function `f`"
" over an `Option` leaves `none` untouched, and replaces `some x` with `some "
"(f x)`."
msgstr ""
"如果多态类型具有名为 `map` 的函数的重载，该函数通过函数转换其中包含的每个元素，则该多态类型是一个 _函子_。虽然大多数语言都使用此术语，但 C#"
" 中等效于 `map` 的函数称为 "
"`System.Linq.Enumerable.Select`。例如，将函数映射到列表上会构造一个新列表，其中起始列表中的每个条目都已替换为该条目上函数的结果。将函数"
" `f` 映射到 `Option` 上会保留 `none` 不变，并将 `some x` 替换为 `some (f x)`。"

#: src/type-classes/standard-classes.md:279
#, fuzzy
msgid ""
"Here are some examples of functors and how their `Functor` instances "
"overload `map`:"
msgstr "以下是函子的示例，以及它们的 `Functor` 实例如何重载 `map`："

#: src/type-classes/standard-classes.md:280
#, fuzzy
msgid "`Functor.map (· + 5) [1, 2, 3]` evaluates to `[6, 7, 8]`"
msgstr "`Functor.map (· + 5) [1, 2, 3]` 计算结果为 `[6, 7, 8]`"

#: src/type-classes/standard-classes.md:281
#, fuzzy
msgid ""
"`Functor.map toString (some (List.cons 5 List.nil))` evaluates to `some "
"\"[5]\"`"
msgstr "`Functor.map toString (some (List.cons 5 List.nil))` 计算结果为 `some \"[5]\"`"

#: src/type-classes/standard-classes.md:282
#, fuzzy
msgid ""
"`Functor.map List.reverse [[1, 2, 3], [4, 5, 6]]` evaluates to `[[3, 2, 1], "
"[6, 5, 4]]`"
msgstr ""
"`Functor.map List.reverse [[1, 2, 3], [4, 5, 6]]` 计算结果为 `[[3, 2, 1], [6, 5, "
"4]]`"

#: src/type-classes/standard-classes.md:284
#, fuzzy
msgid ""
"Because `Functor.map` is a bit of a long name for this common operation, "
"Lean also provides an infix operator for mapping a function, namely `<$>`. "
"The prior examples can be rewritten as follows:"
msgstr ""
"由于 `Functor.map` 对于此常见操作而言名称有点长，因此 Lean 还提供了一个用于映射函数的中缀运算符，即 "
"`<$>`。前面的示例可以重写如下："

#: src/type-classes/standard-classes.md:286
#, fuzzy
msgid "`(· + 5) <$> [1, 2, 3]` evaluates to `[6, 7, 8]`"
msgstr "`(· + 5) <$> [1, 2, 3]` 计算结果为 `[6, 7, 8]`"

#: src/type-classes/standard-classes.md:287
#, fuzzy
msgid "`toString <$> (some (List.cons 5 List.nil))` evaluates to `some \"[5]\"`"
msgstr "`toString <$> (some (List.cons 5 List.nil))` 计算结果为 `some \"[5]\"`"

#: src/type-classes/standard-classes.md:288
#, fuzzy
msgid ""
"`List.reverse <$> [[1, 2, 3], [4, 5, 6]]` evaluates to `[[3, 2, 1], [6, 5, "
"4]]`"
msgstr ""
"`List.reverse <$> [[1, 2, 3], [4, 5, 6]]` 计算结果为 `[[3, 2, 1], [6, 5, 4]]`"

#: src/type-classes/standard-classes.md:290
#, fuzzy
msgid ""
"An instance of `Functor` for `NonEmptyList` requires specifying the `map` "
"function."
msgstr "`NonEmptyList` 的 `Functor` 实例需要指定 `map` 函数。"

#: src/type-classes/standard-classes.md:295
#, fuzzy
msgid ""
"Here, `map` uses the `Functor` instance for `List` to map the function over "
"the tail. This instance is defined for `NonEmptyList` rather than for "
"`NonEmptyList α` because the argument type `α` plays no role in resolving "
"the type class. A `NonEmptyList` can have a function mapped over it _no "
"matter what the type of entries is_. If `α` were a parameter to the class, "
"then it would be possible to make versions of `Functor` that only worked for"
" `NonEmptyList Nat`, but part of being a functor is that `map` works for any"
" entry type."
msgstr ""
"此处，`map` 使用 `List` 的 `Functor` 实例将函数映射到尾部。此实例针对 `NonEmptyList` 定义，而不是针对 "
"`NonEmptyList α` 定义，因为参数类型 `α` 在解析类型类时不起作用。`NonEmptyList` "
"可以映射一个函数，_无论条目类型是什么_。如果 `α` 是类的参数，那么可以制作仅适用于 `NonEmptyList Nat` 的 `Functor` "
"版本，但成为函子的部分原因是 `map` 适用于任何条目类型。"

#: src/type-classes/standard-classes.md:300
#, fuzzy
msgid "Here is an instance of `Functor` for `PPoint`:"
msgstr "以下是 `PPoint` 的 `Functor` 实例："

#: src/type-classes/standard-classes.md:305
#, fuzzy
msgid "In this case, `f` has been applied to both `x` and `y`."
msgstr "在这种情况下，`f` 已应用于 `x` 和 `y`。"

#: src/type-classes/standard-classes.md:307
#, fuzzy
msgid ""
"Even when the type contained in a functor is itself a functor, mapping a "
"function only goes down one layer. That is, when using `map` on a "
"`NonEmptyList (PPoint Nat)`, the function being mapped should take `PPoint "
"Nat` as its argument rather than `Nat`."
msgstr ""
"即使函子中包含的类型本身也是函子，映射函数也只向下移动一层。也就是说，在 `NonEmptyList (PPoint Nat)` 上使用 `map` "
"时，要映射的函数应以 `PPoint Nat` 作为其参数，而不是 `Nat`。"

#: src/type-classes/standard-classes.md:310
#, fuzzy
msgid ""
"The definition of the `Functor` class uses one more language feature that "
"has not yet been discussed: default method definitions. Normally, a class "
"will specify some minimal set of overloadable operations that make sense "
"together, and then use polymorphic functions with instance implicit "
"arguments that build on the overloaded operations to provide a larger "
"library of features. For example, the function `concat` can concatenate any "
"non-empty list whose entries are appendable:"
msgstr ""
"`Functor` "
"类的定义使用了另一项尚未讨论的语言特性：默认方法定义。通常，一个类会指定一些有意义的最小可重载操作集，然后使用具有实例隐式参数的多态函数，基于这些可重载操作构建一个更大的特性库。例如，函数"
" `concat` 可以连接任何非空列表，其条目可追加："

#: src/type-classes/standard-classes.md:320
#, fuzzy
msgid ""
"However, for some classes, there are operations that can be more efficiently"
" implemented with knowledge of the internals of a datatype."
msgstr "然而，对于某些类，有一些操作可以通过了解数据类型的内部结构更有效地实现。"

#: src/type-classes/standard-classes.md:322
#, fuzzy
msgid ""
"In these cases, a default method definition can be provided. A default "
"method definition provides a default implementation of a method in terms of "
"the other methods. However, instance implementors may choose to override "
"this default with something more efficient. Default method definitions "
"contain `:=` in a `class` definition."
msgstr ""
"在这些情况下，可以提供默认方法定义。默认方法定义提供了方法的默认实现，该实现基于其他方法。但是，实例实现者可以选择用更有效的方法覆盖此默认值。默认方法定义在"
" `class` 定义中包含 `:=`。"

#: src/type-classes/standard-classes.md:327
#, fuzzy
msgid ""
"In the case of `Functor`, some types have a more efficient way of "
"implementing `map` when the function being mapped ignores its argument. "
"Functions that ignore their arguments are called _constant functions_ "
"because they always return the same value. Here is the definition of "
"`Functor`, in which `mapConst` has a default implementation:"
msgstr ""
"对于 `Functor`，当被映射的函数忽略其参数时，某些类型具有更有效的方法来实现 `map`。忽略其参数的函数称为 "
"_常量函数_，因为它们始终返回相同的值。以下是 `Functor` 的定义，其中 `mapConst` 具有默认实现："

#: src/type-classes/standard-classes.md:338
#, fuzzy
msgid ""
"Just as a `Hashable` instance that doesn't respect `BEq` is buggy, a "
"`Functor` instance that moves around the data as it maps the function is "
"also buggy. For example, a buggy `Functor` instance for `List` might throw "
"away its argument and always return the empty list, or it might reverse the "
"list. A bad instance for `PPoint` might place `f x` in both the `x` and the "
"`y` fields. Specifically, `Functor` instances should follow two rules:"
msgstr ""
"就像不遵守 `BEq` 的 `Hashable` 实例有缺陷一样，在映射函数时移动数据的 `Functor` 实例也有缺陷。例如，`List` "
"的一个有缺陷的 `Functor` 实例可能会丢弃其参数并始终返回空列表，或者它可能会反转列表。`PPoint` 的一个错误实例可能会将 `f x` "
"放在 `x` 和 `y` 字段中。具体来说，`Functor` 实例应遵循两条规则："

#: src/type-classes/standard-classes.md:342
#, fuzzy
msgid "Mapping the identity function should result in the original argument."
msgstr "映射恒等函数应产生原始参数。"

#: src/type-classes/standard-classes.md:343
#, fuzzy
msgid ""
"Mapping two composed functions should have the same effect as composing "
"their mapping."
msgstr "映射两个复合函数应与复合它们的映射具有相同的效果。"

#: src/type-classes/standard-classes.md:345
#, fuzzy
msgid ""
"More formally, the first rule says that `id <$> x` equals `x`. The second "
"rule says that `map (fun y => f (g y)) x` equals `map f (map g x)`. The "
"composition `fun y => f (g y)` can also be written `f ∘ g`. These rules "
"prevent implementations of `map` that move the data around or delete some of"
" it."
msgstr ""
"更正式地说，第一条规则指出 `id <$> x` 等于 `x`。第二条规则指出 `map (fun y => f (g y)) x` 等于 `map f"
" (map g x)`。复合 `fun y => f (g y)` 也可以写成 `f ∘ g`。这些规则阻止了移动数据或删除部分数据的 `map` "
"实现。"

#: src/type-classes/standard-classes.md:352
#, fuzzy
msgid ""
"Lean is not able to derive instances for all classes. For example, the code"
msgstr "Lean 无法为所有类派生实例。例如，代码"

#: src/type-classes/standard-classes.md:361
#, fuzzy
msgid ""
"Invoking `deriving instance` causes Lean to consult an internal table of "
"code generators for type class instances. If the code generator is found, "
"then it is invoked on the provided type to create the instance. This "
"message, however, means that no code generator was found for `ToString`."
msgstr ""
"调用 `deriving instance` 会导致 Lean "
"查找类型类实例的代码生成器内部表。如果找到代码生成器，则会调用它对提供的类型创建实例。然而，此消息表示未找到 `ToString` 的代码生成器。"

#: src/type-classes/standard-classes.md:367
#, fuzzy
msgid ""
"Write an instance of `HAppend (List α) (NonEmptyList α) (NonEmptyList α)` "
"and test it."
msgstr "编写 `HAppend (List α) (NonEmptyList α) (NonEmptyList α)` 的实例并对其进行测试。"

#: src/type-classes/standard-classes.md:368
#, fuzzy
msgid "Implement a `Functor` instance for the binary tree datatype."
msgstr "为二叉树数据类型实现一个 `Functor` 实例。"
