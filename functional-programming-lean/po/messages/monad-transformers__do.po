#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/monad-transformers/do.md:1
#, fuzzy
msgid "More do Features"
msgstr "更多特性"

#: src/monad-transformers/do.md:3
#, fuzzy
msgid ""
"Lean's `do`\\-notation provides a syntax for writing programs with monads "
"that resembles imperative programming languages. In addition to providing a "
"convenient syntax for programs with monads, `do`\\-notation provides syntax "
"for using certain monad transformers."
msgstr ""
"Lean 的 `do` 语法提供了一种语法，用于编写类似于命令式编程语言的单子程序。除了为单子程序提供方便的语法外，`do` "
"语法还提供了使用某些单子变换器的语法。"

#: src/monad-transformers/do.md:6
#, fuzzy
msgid "Single-Branched `if`"
msgstr "单分支 `if`"

#: src/monad-transformers/do.md:8
#, fuzzy
msgid ""
"When working in a monad, a common pattern is to carry out a side effect only"
" if some condition is true. For instance, `countLetters` contains a check "
"for vowels or consonants, and letters that are neither have no effect on the"
" state. This is captured by having the `else` branch evaluate to `pure ()`, "
"which has no effects:"
msgstr ""
"在单子中工作时，一个常见的模式是在某个条件为真时执行副作用。例如，`countLetters` "
"包含对元音或辅音的检查，而既不是元音也不是辅音的字母对状态没有影响。这可以通过让 `else` 分支求值为 `pure ()` 来实现，`pure "
"()` 没有副作用："

#: src/monad-transformers/do.md:29
#, fuzzy
msgid ""
"When an `if` is a statement in a `do`\\-block, rather than being an "
"expression, then `else pure ()` can simply be omitted, and Lean inserts it "
"automatically. The following definition of `countLetters` is completely "
"equivalent:"
msgstr ""
"当 `if` 是 `do` 块中的一个语句，而不是一个表达式时，`else pure ()` 可以简单地省略，Lean 会自动插入它。以下 "
"`countLetters` 的定义完全等效："

#: src/monad-transformers/do.md:46
#, fuzzy
msgid ""
"A program that uses a state monad to count the entries in a list that "
"satisfy some monadic check can be written as follows:"
msgstr "一个使用状态单子来计算列表中满足某个单子检查的项的程序可以写成如下形式："

#: src/monad-transformers/do.md:56
#, fuzzy
msgid ""
"Similarly, `if not E1 then STMT...` can instead be written `unless E1 do "
"STMT...`. The converse of `count` that counts entries that don't satisfy the"
" monadic check can be written by replacing `if` with `unless`:"
msgstr ""
"类似地，`if not E1 then STMT...` 可以写成 `unless E1 do STMT...`。`count` "
"的反向，即计算不满足单子检查的项，可以通过用 `unless` 替换 `if` 来编写："

#: src/monad-transformers/do.md:67
#, fuzzy
msgid ""
"Understanding single-branched `if` and `unless` does not require thinking "
"about monad transformers. They simply replace the missing branch with `pure "
"()`. The remaining extensions in this section, however, require Lean to "
"automatically rewrite the `do`\\-block to add a local transformer on top of "
"the monad that the `do`\\-block is written in."
msgstr ""
"理解单分支 `if` 和 `unless` 无需考虑单子变换器。它们只是用 `pure ()` 替换缺失的分支。然而，本节中剩余的扩展需要 Lean "
"自动重写 `do` 块，以在 `do` 块所写单子的顶部添加一个局部变换器。"

#: src/monad-transformers/do.md:71
#, fuzzy
msgid "Early Return"
msgstr "提前返回"

#: src/monad-transformers/do.md:73
#, fuzzy
msgid ""
"The standard library contains a function `List.find?` that returns the first"
" entry in a list that satisfies some check. A simple implementation that "
"doesn't make use of the fact that `Option` is a monad loops over the list "
"using a recursive function, with an `if` to stop the loop when the desired "
"entry is found:"
msgstr ""
"标准库包含一个函数 `List.find?`，它返回列表中满足某个检查的第一个条目。一个简单的实现不利用 `Option` "
"是一个单子的事实，而是使用递归函数遍历列表，并使用 `if` 在找到所需条目时停止循环："

#: src/monad-transformers/do.md:85
#, fuzzy
msgid ""
"Imperative languages typically sport the `return` keyword that aborts the "
"execution of a function, immediately returning some value to the caller. In "
"Lean, this is available in `do`\\-notation, and `return` halts the execution"
" of a `do`\\-block, with `return`'s argument being the value returned from "
"the monad. In other words, `List.find?` could have been written like this:"
msgstr ""
"命令式语言通常使用 `return` 关键字中止函数的执行，立即向调用者返回某个值。在 Lean 中，这在 `do` 符号中可用，`return` 停止"
" `do` 块的执行，`return` 的参数是单子返回的值。换句话说，`List.find?` 可以这样编写："

#: src/monad-transformers/do.md:96
#, fuzzy
msgid ""
"Early return in imperative languages is a bit like an exception that can "
"only cause the current stack frame to be unwound. Both early return and "
"exceptions terminate execution of a block of code, effectively replacing the"
" surrounding code with the thrown value. Behind the scenes, early return in "
"Lean is implemented using a version of `ExceptT`. Each `do`\\-block that "
"uses early return is wrapped in an exception handler (in the sense of the "
"function `tryCatch`). Early returns are translated to throwing the value as "
"an exception, and the handlers catch the thrown value and return it "
"immediately. In other words, the `do`\\-block's original return value type "
"is also used as the exception type."
msgstr ""
"命令式语言中的提前返回有点像一个异常，它只能导致当前堆栈帧被展开。提前返回和异常都会终止代码块的执行，有效地用抛出的值替换周围的代码。在幕后，Lean "
"中的提前返回是使用 `ExceptT` 的一个版本实现的。每个使用提前返回的 `do` 块都被包装在一个异常处理程序中（在函数 `tryCatch` "
"的意义上）。提前返回被转换为将值作为异常抛出，处理程序捕获抛出的值并立即返回它。换句话说，`do` 块的原始返回值类型也用作异常类型。"

#: src/monad-transformers/do.md:103
#, fuzzy
msgid ""
"Making this more concrete, the helper function `runCatch` strips a layer of "
"`ExceptT` from the top of a monad transformer stack when the exception type "
"and return type are the same:"
msgstr "具体来说，辅助函数 `runCatch` 从单子变换器栈的顶部剥离一层 `ExceptT`，当异常类型和返回类型相同时："

#: src/monad-transformers/do.md:110
#, fuzzy
msgid ""
"The `do`\\-block in `List.find?` that uses early return is translated to a "
"`do`\\-block that does not use early return by wrapping it in a use of "
"`runCatch`, and replacing early returns with `throw`:"
msgstr ""
"`List.find?` 中使用提前返回的 `do` 块被翻译为不使用提前返回的 `do` 块，方法是将其包装在 `runCatch` "
"的使用中，并将提前返回替换为 `throw`："

#: src/monad-transformers/do.md:120
#, fuzzy
msgid ""
"Another situation in which early return is useful is command-line "
"applications that terminate early if the arguments or input are incorrect. "
"Many programs begin with a section that validates arguments and inputs "
"before proceeding to the main body of the program. The following version of "
"[the greeting program `hello-name`](../hello-world/running-a-program.md) "
"checks that no command-line arguments were provided:"
msgstr ""
"提前返回有用的另一个情况是命令行应用程序，如果参数或输入不正确，则提前终止。许多程序从验证参数和输入的部分开始，然后再进入程序的主体。以下版本的 "
"[问候程序 `hello-name`](../hello-world/running-a-program.md) 检查是否未提供命令行参数："

#: src/monad-transformers/do.md:123
msgid ""
"```lean\n"
"def main (argv : List String) : IO UInt32 := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  let stderr ← IO.getStderr\n"
"\n"
"  unless argv == [] do\n"
"    stderr.putStrLn s!\"Expected no arguments, but got {argv.length}\"\n"
"    return 1\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  stdout.flush\n"
"\n"
"  let name := (← stdin.getLine).trim\n"
"  if name == \"\" then\n"
"    stderr.putStrLn s!\"No name provided\"\n"
"    return 1\n"
"\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"\n"
"  return 0\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:145
#, fuzzy
msgid ""
"Running it with no arguments and typing the name `David` yields the same "
"result as the previous version:"
msgstr "在没有参数的情况下运行它并键入名称 `David` 会产生与以前版本相同的结果："

#: src/monad-transformers/do.md:153
#, fuzzy
msgid ""
"Providing the name as a command-line argument instead of an answer causes an"
" error:"
msgstr "将名称作为命令行参数而不是答案提供会导致错误："

#: src/monad-transformers/do.md:159
#, fuzzy
msgid "And providing no name causes the other error:"
msgstr "不提供名称会导致另一个错误："

#: src/monad-transformers/do.md:167
#, fuzzy
msgid ""
"The program that uses early return avoids needing to nest the control flow, "
"as is done in this version that does not use early return:"
msgstr "使用提前返回的程序避免了嵌套控制流的需要，就像不使用提前返回的这个版本所做的那样："

#: src/monad-transformers/do.md:168
msgid ""
"```lean\n"
"def main (argv : List String) : IO UInt32 := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  let stderr ← IO.getStderr\n"
"\n"
"  if argv != [] then\n"
"    stderr.putStrLn s!\"Expected no arguments, but got {argv.length}\"\n"
"    pure 1\n"
"  else\n"
"    stdout.putStrLn \"How would you like to be addressed?\"\n"
"    stdout.flush\n"
"\n"
"    let name := (← stdin.getLine).trim\n"
"    if name == \"\" then\n"
"      stderr.putStrLn s!\"No name provided\"\n"
"      pure 1\n"
"    else\n"
"      stdout.putStrLn s!\"Hello, {name}!\"\n"
"      pure 0\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:190
#, fuzzy
msgid ""
"One important difference between early return in Lean and early return in "
"imperative languages is that Lean's early return applies only to the current"
" `do`\\-block. When the entire definition of a function is in the same `do` "
"block, this difference doesn't matter. But if `do` occurs underneath some "
"other structures, then the difference becomes apparent. For example, given "
"the following definition of `greet`:"
msgstr ""
"Lean 中的提前返回与命令式语言中的提前返回之间的一个重要区别是，Lean 的提前返回仅适用于当前的 `do` 块。当函数的整个定义都在同一个 "
"`do` 块中时，这个区别并不重要。但是，如果 `do` 出现在其他一些结构的下面，那么差异就会变得明显。例如，给定以下 `greet` 的定义："

#: src/monad-transformers/do.md:194
msgid ""
"```lean\n"
"def greet (name : String) : String :=\n"
"  \"Hello, \" ++ Id.run do return name\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:198
#, fuzzy
msgid ""
"the expression `greet \"David\"` evaluates to `\"Hello, David\"`, not just "
"`\"David\"`."
msgstr "表达式 `greet \"David\"` 求值为 `\"Hello, David\"`, 而不是 `\"David\"`。"

#: src/monad-transformers/do.md:200
#, fuzzy
msgid "Loops"
msgstr "循环"

#: src/monad-transformers/do.md:202
#, fuzzy
msgid ""
"Just as every program with mutable state can be rewritten to a program that "
"passes the state as arguments, every loop can be rewritten as a recursive "
"function. From one perspective, `List.find?` is most clear as a recursive "
"function. After all, its definition mirrors the structure of the list: if "
"the head passes the check, then it should be returned; otherwise look in the"
" tail. When no more entries remain, the answer is `none`. From another "
"perspective, `List.find?` is most clear as a loop. After all, the program "
"consults the entries in order until a satisfactory one is found, at which "
"point it terminates. If the loop terminates without having returned, the "
"answer is `none`."
msgstr ""
"就像每个带有可变状态的程序都可以重写为将状态作为参数传递的程序一样，每个循环都可以重写为递归函数。从一个角度来看，`List.find?` "
"最清楚地表现为递归函数。毕竟，它的定义反映了列表的结构：如果头部通过检查，则应返回它；否则在尾部查找。当没有更多条目时，答案是 "
"`none`。从另一个角度来看，`List.find?` "
"最清楚地表现为循环。毕竟，程序按顺序查询条目，直到找到令人满意的条目，然后终止。如果循环在没有返回的情况下终止，则答案是 `none`。"

#: src/monad-transformers/do.md:210
#, fuzzy
msgid "Looping with ForM"
msgstr "使用 ForM 循环"

#: src/monad-transformers/do.md:212
#, fuzzy
msgid ""
"Lean includes a type class that describes looping over a container type in "
"some monad. This class is called `ForM`:"
msgstr "Lean 包含一个类型类，用于描述在某个单子中循环遍历容器类型。此类称为 `ForM`："

#: src/monad-transformers/do.md:218
#, fuzzy
msgid ""
"This class is quite general. The parameter `m` is a monad with some desired "
"effects, `γ` is the collection to be looped over, and `α` is the type of "
"elements from the collection. Typically, `m` is allowed to be any monad, but"
" it is possible to have a data structure that e.g. only supports looping in "
"`IO`. The method `forM` takes a collection, a monadic action to be run for "
"its effects on each element from the collection, and is then responsible for"
" running the actions."
msgstr ""
"此类非常通用。参数 `m` 是具有某些所需效果的单子，`γ` 是要循环遍历的集合，`α` 是集合中元素的类型。通常，`m` "
"可以是任何单子，但可以有一个数据结构，例如仅支持在 `IO` 中循环。`forM` "
"方法获取一个集合，一个单子操作以对其集合中的每个元素产生效果，然后负责运行这些操作。"

#: src/monad-transformers/do.md:223
#, fuzzy
msgid ""
"The instance for `List` allows `m` to be any monad, it sets `γ` to be `List "
"α`, and sets the class's `α` to be the same `α` found in the list:"
msgstr "`List` 的实例允许 `m` 是任何单子，它将 `γ` 设置为 `List α`，并将类的 `α` 设置为列表中找到的相同 `α`："

#: src/monad-transformers/do.md:234
#, fuzzy
msgid ""
"The [function `doList` from `doug`](reader-io.md#implementation) is `forM` "
"for lists. Because `forM` is intended to be used in `do`\\-blocks, it uses "
"`Monad` rather than `Applicative`. `forM` can be used to make `countLetters`"
" much shorter:"
msgstr ""
"`doList` 函数（来自 `doug`）是列表的 `forM`。因为 `forM` 旨在用于 `do` 块中，所以它使用 `Monad` 而不是 "
"`Applicative`。`forM` 可用于使 `countLetters` 变得更短："

#: src/monad-transformers/do.md:249
#, fuzzy
msgid "The instance for `Many` is very similar:"
msgstr "`Many` 的实例非常相似："

#: src/monad-transformers/do.md:261
#, fuzzy
msgid ""
"Because `γ` can be any type at all, `ForM` can support non-polymorphic "
"collections. A very simple collection is one of the natural numbers less "
"than some given number, in reverse order:"
msgstr "因为 `γ` 可以是任何类型，所以 `ForM` 可以支持非多态集合。一个非常简单的集合是小于某个给定数字的自然数之一，按逆序排列："

#: src/monad-transformers/do.md:267
#, fuzzy
msgid "Its `forM` operator applies the provided action to each smaller `Nat`:"
msgstr "它的 `forM` 运算符将提供的操作应用于每个较小的 `Nat`："

#: src/monad-transformers/do.md:280
#, fuzzy
msgid ""
"Running `IO.println` on each number less than five can be accomplished with "
"`forM`:"
msgstr "在小于 5 的每个数字上运行 `IO.println` 可以通过 `forM` 完成："

#: src/monad-transformers/do.md:292
#, fuzzy
msgid ""
"An example `ForM` instance that works only in a particular monad is one that"
" loops over the lines read from an IO stream, such as standard input:"
msgstr "一个仅在特定单子中工作的 `ForM` 实例示例是循环遍历从 IO 流（例如标准输入）读取的行："

#: src/monad-transformers/do.md:293
msgid ""
"```lean\n"
"structure LinesOf where\n"
"  stream : IO.FS.Stream\n"
"\n"
"partial def LinesOf.forM (readFrom : LinesOf) (action : String → IO Unit) : IO Unit := do\n"
"  let line ← readFrom.stream.getLine\n"
"  if line == \"\" then return ()\n"
"  action line\n"
"  forM readFrom action\n"
"\n"
"instance : ForM IO LinesOf String where\n"
"  forM := LinesOf.forM\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:306
#, fuzzy
msgid ""
"The definition of `forM` is marked `partial` because there is no guarantee "
"that the stream is finite. In this case, `IO.FS.Stream.getLine` works only "
"in the `IO` monad, so no other monad can be used for looping."
msgstr ""
"`forM` 的定义标记为 `partial`，因为无法保证流是有限的。在这种情况下，`IO.FS.Stream.getLine` 仅在 `IO` "
"单子中工作，因此无法使用其他单子进行循环。"

#: src/monad-transformers/do.md:309
#, fuzzy
msgid ""
"This example program uses this looping construct to filter out lines that "
"don't contain letters:"
msgstr "此示例程序使用此循环构造来过滤不包含字母的行："

#: src/monad-transformers/do.md:310
msgid ""
"```lean\n"
"def main (argv : List String) : IO UInt32 := do\n"
"  if argv != [] then\n"
"    IO.eprintln \"Unexpected arguments\"\n"
"    return 1\n"
"\n"
"  forM (LinesOf.mk (← IO.getStdin)) fun line => do\n"
"    if line.any (·.isAlpha) then\n"
"      IO.print line\n"
"\n"
"  return 0\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:322
#, fuzzy
msgid "The file `test-data` contains:"
msgstr "`test-data` 文件包含："

#: src/monad-transformers/do.md:331
#, fuzzy
msgid ""
"Invoking this program, which is stored in `ForMIO.lean`, yields the "
"following output:"
msgstr "调用存储在 `ForMIO.lean` 中的此程序会产生以下输出："

#: src/monad-transformers/do.md:339
#, fuzzy
msgid "Stopping Iteration"
msgstr "停止迭代"

#: src/monad-transformers/do.md:341
#, fuzzy
msgid ""
"Terminating a loop early is difficult to do with `forM`. Writing a function "
"that iterates over the `Nat`s in an `AllLessThan` only until `3` is reached "
"requires a means of stopping the loop partway through. One way to achieve "
"this is to use `forM` with the `OptionT` monad transformer. The first step "
"is to define `OptionT.exec`, which discards information about both the "
"return value and whether or not the transformed computation succeeded:"
msgstr ""
"使用 `forM` 很难提前终止循环。编写一个函数来迭代 `AllLessThan` 中的 `Nat` 直到达到 "
"`3`，需要一种方法来中途停止循环。实现此目的的一种方法是将 `forM` 与 `OptionT` 单子转换器一起使用。第一步是定义 "
"`OptionT.exec`，它会丢弃有关返回值以及转换后的计算是否成功的信息："

#: src/monad-transformers/do.md:349
#, fuzzy
msgid ""
"Then, failure in the `OptionT` instance of `Alternative` can be used to "
"terminate looping early:"
msgstr "然后，`Alternative` 的 `OptionT` 实例中的失败可用于提前终止循环："

#: src/monad-transformers/do.md:356
#, fuzzy
msgid "A quick test demonstrates that this solution works:"
msgstr "快速测试表明此解决方案有效："

#: src/monad-transformers/do.md:367
#, fuzzy
msgid ""
"However, this code is not so easy to read. Terminating a loop early is a "
"common task, and Lean provides more syntactic sugar to make this easier. "
"This same function can also be written as follows:"
msgstr "然而，这段代码不太容易阅读。提前终止循环是一项常见任务，而 Lean 提供了更多语法糖来简化此操作。此函数还可以写成如下形式："

#: src/monad-transformers/do.md:377
#, fuzzy
msgid "Testing it reveals that it works just like the prior version:"
msgstr "测试表明它与之前的版本一样有效："

#: src/monad-transformers/do.md:388
#, fuzzy
msgid ""
"At the time of writing, the `for ... in ... do ...` syntax desugars to the "
"use of a type class called `ForIn`, which is a somewhat more complicated "
"version of `ForM` that keeps track of state and early termination. However, "
"there is a plan to refactor `for` loops to use the simpler `ForM`, with "
"monad transformers inserted as necessary. In the meantime, an adapter is "
"provided that converts a `ForM` instance into a `ForIn` instance, called "
"`ForM.forIn`. To enable `for` loops based on a `ForM` instance, add "
"something like the following, with appropriate replacements for "
"`AllLessThan` and `Nat`:"
msgstr ""
"在撰写本文时，`for ... in ... do ...` 语法反糖化为使用一个名为 `ForIn` 的类型类，它是 `ForM` "
"的一个稍微复杂一些的版本，它跟踪状态和提前终止。然而，有一个计划重构 `for` 循环以使用更简单的 "
"`ForM`，并在必要时插入单子变换器。在此期间，提供了一个适配器，它将 `ForM` 实例转换为 `ForIn` 实例，称为 "
"`ForM.forIn`。要启用基于 `ForM` 实例的 `for` 循环，请添加类似以下内容，并用 `AllLessThan` 和 `Nat` "
"的适当替换项替换："

#: src/monad-transformers/do.md:396
#, fuzzy
msgid ""
"Note, however, that this adapter only works for `ForM` instances that keep "
"the monad unconstrained, as most of them do. This is because the adapter "
"uses `StateT` and `ExceptT`, rather than the underlying monad."
msgstr ""
"但是，请注意，此适配器仅适用于保持单子不受约束的 `ForM` 实例，就像大多数实例一样。这是因为该适配器使用 `StateT` 和 "
"`ExceptT`，而不是底层单子。"

#: src/monad-transformers/do.md:399
#, fuzzy
msgid ""
"Early return is supported in `for` loops. The translation of `do` blocks "
"with early return into a use of an exception monad transformer applies "
"equally well underneath `forM` as the earlier use of `OptionT` to halt "
"iteration does. This version of `List.find?` makes use of both:"
msgstr ""
"`for` 循环支持提前返回。将带有提前返回的 `do` 块翻译成使用异常单子变换器同样适用于 `forM`，就像之前使用 `OptionT` "
"停止迭代一样。`List.find?` 的此版本同时使用了这两个功能："

#: src/monad-transformers/do.md:409
#, fuzzy
msgid ""
"In addition to `break`, `for` loops support `continue` to skip the rest of "
"the loop body in an iteration. An alternative (but confusing) formulation of"
" `List.find?` skips elements that don't satisfy the check:"
msgstr ""
"除了 `break` 之外，`for` 循环还支持 `continue` 以在迭代中跳过循环体的其余部分。`List.find?` "
"的另一种（但令人困惑的）公式跳过不满足检查的元素："

#: src/monad-transformers/do.md:419
#, fuzzy
msgid ""
"A `Range` is a structure that consists of a starting number, an ending "
"number, and a step. They represent a sequence of natural numbers, from the "
"starting number to the ending number, increasing by the step each time. Lean"
" has special syntax to construct ranges, consisting of square brackets, "
"numbers, and colons that comes in four varieties. The stopping point must "
"always be provided, while the start and the step are optional, defaulting to"
" `0` and `1`, respectively:"
msgstr ""
"区间`Range`是一个结构，由起始数、终止数和步长组成。它们表示从起始数到终止数的自然数序列，每次增加步长。Lean "
"有特殊的语法来构造区间，包括方括号、数字和冒号，共有四种类型。终止点必须始终提供，而起始点和步长是可选的，分别默认为 `0` 和 `1`："

#: src/monad-transformers/do.md:424
#, fuzzy
msgid "Start"
msgstr "起始"

#: src/monad-transformers/do.md:424
#, fuzzy
msgid "Stop"
msgstr "终止"

#: src/monad-transformers/do.md:424
#, fuzzy
msgid "Step"
msgstr "步长"

#: src/monad-transformers/do.md:424
#, fuzzy
msgid "As List"
msgstr "作为列表"

#: src/monad-transformers/do.md:426
#, fuzzy
msgid "`[:10]`"
msgstr "`[:10]`"

#: src/monad-transformers/do.md:426 src/monad-transformers/do.md:428
#, fuzzy
msgid "`0`"
msgstr "`0`"

#: src/monad-transformers/do.md:426 src/monad-transformers/do.md:427
#: src/monad-transformers/do.md:428 src/monad-transformers/do.md:429
#, fuzzy
msgid "`10`"
msgstr "`10`"

#: src/monad-transformers/do.md:426 src/monad-transformers/do.md:427
#, fuzzy
msgid "`1`"
msgstr "`1`"

#: src/monad-transformers/do.md:426
#, fuzzy
msgid "`[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`"
msgstr "`[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`"

#: src/monad-transformers/do.md:427
#, fuzzy
msgid "`[2:10]`"
msgstr "`[2:10]`"

#: src/monad-transformers/do.md:427 src/monad-transformers/do.md:429
#, fuzzy
msgid "`2`"
msgstr "`2`"

#: src/monad-transformers/do.md:427
#, fuzzy
msgid "`[2, 3, 4, 5, 6, 7, 8, 9]`"
msgstr "`[2, 3, 4, 5, 6, 7, 8, 9]`"

#: src/monad-transformers/do.md:428
#, fuzzy
msgid "`[:10:3]`"
msgstr "`[:10:3]`"

#: src/monad-transformers/do.md:428 src/monad-transformers/do.md:429
#, fuzzy
msgid "`3`"
msgstr "`3`"

#: src/monad-transformers/do.md:428
#, fuzzy
msgid "`[0, 3, 6, 9]`"
msgstr "`[0, 3, 6, 9]`"

#: src/monad-transformers/do.md:429
#, fuzzy
msgid "`[2:10:3]`"
msgstr "`[2:10:3]`"

#: src/monad-transformers/do.md:429
#, fuzzy
msgid "`[2, 5, 8]`"
msgstr "`[2, 5, 8]`"

#: src/monad-transformers/do.md:431
#, fuzzy
msgid ""
"Note that the starting number _is_ included in the range, while the stopping"
" numbers is not. All three arguments are `Nat`s, which means that ranges "
"cannot count down—a range where the starting number is greater than or equal"
" to the stopping number simply contains no numbers."
msgstr ""
"请注意，起始数包含在区间中，而终止数不包含。所有三个参数都是 `Nat`，这意味着区间不能倒数——起始数大于或等于终止数的区间不包含任何数字。"

#: src/monad-transformers/do.md:434
#, fuzzy
msgid ""
"Ranges can be used with `for` loops to draw numbers from the range. This "
"program counts even numbers from four to eight:"
msgstr "区间可以与 `for` 循环一起使用，从区间中提取数字。此程序计算从四到八的偶数："

#: src/monad-transformers/do.md:441
#, fuzzy
msgid "Running it yields:"
msgstr "运行它会产生："

#: src/monad-transformers/do.md:449
#, fuzzy
msgid ""
"Finally, `for` loops support iterating over multiple collections in "
"parallel, by separating the `in` clauses with commas. Looping halts when the"
" first collection runs out of elements, so the declaration:"
msgstr "最后，`for` 循环支持通过用逗号分隔 `in` 子句来并行迭代多个集合。当第一个集合中的元素用完时，循环停止，因此声明："

#: src/monad-transformers/do.md:451
msgid ""
"```lean\n"
"def parallelLoop := do\n"
"  for x in [\"currant\", \"gooseberry\", \"rowan\"], y in [4:8] do\n"
"    IO.println (x, y)\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:456
#, fuzzy
msgid "produces three lines of output:"
msgstr "会产生三行输出："

#: src/monad-transformers/do.md:466
#, fuzzy
msgid "Mutable Variables"
msgstr "可变变量"

#: src/monad-transformers/do.md:468
#, fuzzy
msgid ""
"In addition to early `return`, `else`\\-less `if`, and `for` loops, Lean "
"supports local mutable variables within a `do` block. Behind the scenes, "
"these mutable variables desugar to a use of `StateT`, rather than being "
"implemented by true mutable variables. Once again, functional programming is"
" used to simulate imperative programming."
msgstr ""
"除了早期 `return`、没有 `else` 的 `if` 和 `for` 循环之外，Lean 还支持 `do` "
"块中的局部可变变量。在幕后，这些可变变量会转化为使用 `StateT`，而不是通过真正的可变变量实现。再一次，函数式编程被用来模拟命令式编程。"

#: src/monad-transformers/do.md:472
#, fuzzy
msgid ""
"A local mutable variable is introduced with `let mut` instead of plain "
"`let`. The definition `two`, which uses the identity monad `Id` to enable "
"`do`\\-syntax without introducing any effects, counts to `2`:"
msgstr ""
"局部可变变量使用 `let mut` 而不是 `let` 引入。使用恒等单子 `Id` 以启用 `do` 语法而不引入任何效果的定义 `two` 计数到"
" `2`："

#: src/monad-transformers/do.md:481
#, fuzzy
msgid ""
"This code is equivalent to a definition that uses `StateT` to add `1` twice:"
msgstr "此代码等效于使用 `StateT` 两次添加 `1` 的定义："

#: src/monad-transformers/do.md:492
#, fuzzy
msgid ""
"Local mutable variables work well with all the other features of "
"`do`\\-notation that provide convenient syntax for monad transformers. The "
"definition `three` counts the number of entries in a three-entry list:"
msgstr "局部可变变量与 `do` 符号的所有其他功能配合良好，这些功能为单子转换器提供了便捷的语法。定义 `three` 统计三项列表中的项数："

#: src/monad-transformers/do.md:501
#, fuzzy
msgid "Similarly, `six` adds the entries in a list:"
msgstr "类似地，`six` 添加列表中的项："

#: src/monad-transformers/do.md:510
#, fuzzy
msgid ""
"`List.count` counts the number of entries in a list that satisfy some check:"
msgstr "`List.count` 统计满足某个检查的列表中的项数："

#: src/monad-transformers/do.md:519
#, fuzzy
msgid ""
"Local mutable variables can be more convenient to use and easier to read "
"than an explicit local use of `StateT`. However, they don't have the full "
"power of unrestricted mutable variables from imperative languages. In "
"particular, they can only be modified in the `do`\\-block in which they are "
"introduced. This means, for instance, that `for`\\-loops can't be replaced "
"by otherwise-equivalent recursive helper functions. This version of "
"`List.count`:"
msgstr ""
"局部可变变量比显式局部使用 `StateT` 更方便、更易读。但是，它们没有命令式语言中不受限制的可变变量的全部功能。特别是，它们只能在引入它们的 "
"`do` 块中修改。这意味着，例如，`for` 循环不能被其他等效的递归辅助函数替换。此版本的 `List.count`："

#: src/monad-transformers/do.md:534
#, fuzzy
msgid "yields the following error on the attempted mutation of `found`:"
msgstr "在尝试修改 `found` 时产生以下错误："

#: src/monad-transformers/do.md:538
#, fuzzy
msgid ""
"This is because the recursive function is written in the identity monad, and"
" only the monad of the `do`\\-block in which the variable is introduced is "
"transformed with `StateT`."
msgstr "这是因为递归函数是用恒等单子编写的，并且只有引入变量的 `do` 块的单子才使用 `StateT` 转换。"

#: src/monad-transformers/do.md:540
#, fuzzy
msgid "What counts as a `do` block?"
msgstr "什么算作 `do` 块？"

#: src/monad-transformers/do.md:542
#, fuzzy
msgid ""
"Many features of `do`\\-notation apply only to a single `do`\\-block. Early "
"return terminates the current block, and mutable variables can only be "
"mutated in the block that they are defined in. To use them effectively, it's"
" important to know what counts as \"the same block\"."
msgstr ""
"`do` 符号的许多功能仅适用于单个 `do` "
"块。提前返回终止当前块，并且可变变量只能在其定义的块中修改。为了有效地使用它们，了解什么算作“同一块”非常重要。"

#: src/monad-transformers/do.md:546
#, fuzzy
msgid ""
"Generally speaking, the indented block following the `do` keyword counts as "
"a block, and the immediate sequence of statements underneath it are part of "
"that block. Statements in independent blocks that are nonetheless contained "
"in a block are not considered part of the block. However, the rules that "
"govern what exactly counts as the same block are slightly subtle, so some "
"examples are in order. The precise nature of the rules can be tested by "
"setting up a program with a mutable variable and seeing where the mutation "
"is allowed. This program has a mutation that is clearly in the same block as"
" the mutable variable:"
msgstr ""
"一般来说，`do` "
"关键字后面的缩进块算作一个块，其下方的语句序列是该块的一部分。独立块中的语句虽然包含在块中，但不被视为块的一部分。然而，判断什么算作同一块的规则有些微妙，因此需要一些示例。可以通过设置一个带有可变变量的程序并查看允许变异的位置来测试规则的准确性。该程序有一个变异，显然与可变变量在同一块中："

#: src/monad-transformers/do.md:557
#, fuzzy
msgid ""
"When a mutation occurs in a `do`\\-block that is part of a `let`\\-statement"
" that defines a name using `:=`, then it is not considered to be part of the"
" block:"
msgstr "当变异发生在 `do` 块中，该块是 `let` 语句的一部分，该语句使用 `:=` 定义名称时，它不被视为块的一部分："

#: src/monad-transformers/do.md:568
#, fuzzy
msgid ""
"However, a `do`\\-block that occurs under a `let`\\-statement that defines a"
" name using `←` is considered part of the surrounding block. The following "
"program is accepted:"
msgstr "然而，在 `let` 语句下发生的 `do` 块，该语句使用 `←` 定义名称，被视为周围块的一部分。以下程序被接受："

#: src/monad-transformers/do.md:578
#, fuzzy
msgid ""
"Similarly, `do`\\-blocks that occur as arguments to functions are "
"independent of their surrounding blocks. The following program is not "
"accepted:"
msgstr "同样，作为函数参数出现的 `do` 块独立于其周围块。以下程序不被接受："

#: src/monad-transformers/do.md:591
#, fuzzy
msgid ""
"If the `do` keyword is completely redundant, then it does not introduce a "
"new block. This program is accepted, and is equivalent to the first one in "
"this section:"
msgstr "如果 `do` 关键字完全冗余，则它不会引入新块。该程序被接受，并且等效于本节中的第一个程序："

#: src/monad-transformers/do.md:599
#, fuzzy
msgid ""
"The contents of branches under a `do` (such as those introduced by `match` "
"or `if`) are considered to be part of the surrounding block, whether or not "
"a redundant `do` is added. The following programs are all accepted:"
msgstr ""
"`do` 下的分支内容（例如由 `match` 或 `if` 引入的内容）被视为周围块的一部分，无论是否添加了冗余 `do`。以下程序都被接受："

#: src/monad-transformers/do.md:626
#, fuzzy
msgid ""
"Similarly, the `do` that occurs as part of the `for` and `unless` syntax is "
"just part of their syntax, and does not introduce a fresh `do`\\-block. "
"These programs are also accepted:"
msgstr ""
"同样，作为 `for` 和 `unless` 语法的一部分出现的 `do` 只是其语法的一部分，不会引入新的 `do` 块。这些程序也被接受："

#: src/monad-transformers/do.md:641
#, fuzzy
msgid "Imperative or Functional Programming?"
msgstr "命令式或函数式编程？"

#: src/monad-transformers/do.md:643
#, fuzzy
msgid ""
"The imperative features provided by Lean's `do`\\-notation allow many "
"programs to very closely resemble their counterparts in languages like Rust,"
" Java, or C#. This resemblance is very convenient when translating an "
"imperative algorithm into Lean, and some tasks are just most naturally "
"thought of imperatively. The introduction of monads and monad transformers "
"enables imperative programs to be written in purely functional languages, "
"and `do`\\-notation as a specialized syntax for monads (potentially locally "
"transformed) allows functional programmers to have the best of both worlds: "
"the strong reasoning principles afforded by immutability and a tight control"
" over available effects through the type system are combined with syntax and"
" libraries that allow programs that use effects to look familiar and be easy"
" to read. Monads and monad transformers allow functional versus imperative "
"programming to be a matter of perspective."
msgstr ""
"Lean 的 `do` 语法提供的命令式特性允许许多程序非常接近 Rust、Java 或 C# 等语言中的对应程序。这种相似性在将命令式算法转换为 "
"Lean 时非常方便，并且某些任务最自然地被认为是命令式的。单子（monad）和单子变换器的引入使命令式程序能够用纯函数式语言编写，而 `do` "
"语法作为单子（可能局部转换）的专门语法，允许函数式程序员兼得两全其美：不可变性提供的强大推理原则和通过类型系统对可用效果的严格控制与允许使用效果的程序看起来熟悉且易于阅读的语法和库相结合。单子和单子变换器允许函数式与命令式编程成为一个观点问题。"

#: src/monad-transformers/do.md:651
#, fuzzy
msgid ""
"Rewrite `doug` to use `for` instead of the `doList` function. Are there "
"other opportunities to use the features introduced in this section to "
"improve the code? If so, use them!"
msgstr "使用 `for` 而不是 `doList` 函数重写 `doug`。是否有其他机会使用本节中引入的特性来改进代码？如果有，请使用它们！"
