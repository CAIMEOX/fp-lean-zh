#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/programs-proofs/special-types.md:3
#, fuzzy
msgid ""
"Understanding the representation of data in memory is very important. "
"Usually, the representation can be understood from the definition of a "
"datatype. Each constructor corresponds to an object in memory that has a "
"header that includes a tag and a reference count. The constructor's "
"arguments are each represented by a pointer to some other object. In other "
"words, `List` really is a linked list and extracting a field from a "
"`structure` really does just chase a pointer."
msgstr ""
"理解数据在内存中的表示非常重要。通常，可以从数据类型的定义中理解表示。每个构造函数对应于内存中的一个对象，该对象有一个包含标记和引用计数的头。构造函数的参数分别由指向其他对象的指针表示。换句话说，`List`"
" 实际上是一个链表，从 `structure` 中提取一个字段实际上只是追逐一个指针。"

#: src/programs-proofs/special-types.md:9
#, fuzzy
msgid ""
"There are, however, some important exceptions to this rule. A number of "
"types are treated specially by the compiler. For example, the type `UInt32` "
"is defined as `Fin (2 ^ 32)`, but it is replaced at run-time with an actual "
"native implementation based on machine words. Similarly, even though the "
"definition of `Nat` suggests an implementation similar to `List Unit`, the "
"actual run-time representation uses immediate machine words for "
"sufficiently-small numbers and an efficient arbitrary-precision arithmetic "
"library for larger numbers. The Lean compiler translates from definitions "
"that use pattern matching into the appropriate operations for this "
"representation, and calls to operations like addition and subtraction are "
"mapped to fast operations from the underlying arithmetic library. After all,"
" addition should not take time linear in the size of the addends."
msgstr ""
"然而，这个规则有一些重要的例外。编译器对许多类型进行了特殊处理。例如，类型 `UInt32` 被定义为 `Fin (2 ^ "
"32)`，但在运行时它被替换为基于机器字的实际原生实现。类似地，尽管 `Nat` 的定义暗示了一个类似于 `List Unit` "
"的实现，但实际的运行时表示对足够小的数字使用立即机器字，对较大的数字使用高效的任意精度算术库。Lean "
"编译器从使用模式匹配的定义转换为针对此表示的适当操作，并且对加法和减法等操作的调用被映射到底层算术库中的快速操作。毕竟，加法不应该花费与加数大小成线性的时间。"

#: src/programs-proofs/special-types.md:16
#, fuzzy
msgid ""
"The fact that some types have special representations also means that care "
"is needed when working with them. Most of these types consist of a "
"`structure` that is treated specially by the compiler. With these "
"structures, using the constructor or the field accessors directly can "
"trigger an expensive conversion from an efficient representation to a slow "
"one that is convenient for proofs. For example, `String` is defined as a "
"structure that contains a list of characters, but the run-time "
"representation of strings uses UTF-8, not linked lists of pointers to "
"characters. Applying the constructor to a list of characters creates a byte "
"array that encodes them in UTF-8, and accessing the field of the structure "
"takes time linear in the length of the string to decode the UTF-8 "
"representation and allocate a linked list. Arrays are represented similarly."
" From the logical perspective, arrays are structures that contain a list of "
"array elements, but the run-time representation is a dynamically-sized "
"array. At run time, the constructor translates the list into an array, and "
"the field accessor allocates a linked list from the array. The various array"
" operations are replaced with efficient versions by the compiler that mutate"
" the array when possible instead of allocating a new one."
msgstr ""
"由于某些类型具有特殊表示，因此在使用它们时需要小心。这些类型中的大多数由编译器特殊处理的 `structure` "
"组成。对于这些结构，直接使用构造函数或字段访问器可能会触发从高效表示到方便证明的低效表示的昂贵转换。例如，`String` "
"被定义为包含字符列表的结构，但字符串的运行时表示使用 UTF-8，而不是指向字符的指针链表。将构造函数应用于字符列表会创建一个以 UTF-8 "
"编码它们的字节数组，而访问结构的字段需要线性时间来解码 UTF-8 "
"表示并分配一个链表。数组的表示方式类似。从逻辑角度来看，数组是包含数组元素列表的结构，但运行时表示是一个动态大小的数组。在运行时，构造函数将列表转换为数组，而字段访问器从数组中分配一个链表。编译器用高效版本替换了各种数组操作，这些版本在可能的情况下会改变数组，而不是分配一个新数组。"

#: src/programs-proofs/special-types.md:26
#, fuzzy
msgid ""
"Both types themselves and proofs of propositions are completely erased from "
"compiled code. In other words, they take up no space, and any computations "
"that might have been performed as part of a proof are similarly erased. This"
" means that proofs can take advantage of the convenient interface to strings"
" and arrays as inductively-defined lists, including using induction to prove"
" things about them, without imposing slow conversion steps while the program"
" is running. For these built-in types, a convenient logical representation "
"of the data does not imply that the program must be slow."
msgstr ""
"类型本身和命题的证明都从编译后的代码中完全擦除。换句话说，它们不占用任何空间，并且作为证明的一部分可能执行的任何计算也会被类似地擦除。这意味着证明可以利用字符串和数组作为归纳定义列表的便捷接口，包括使用归纳来证明它们，而不会在程序运行时施加缓慢的转换步骤。对于这些内置类型，数据的便捷逻辑表示并不意味着程序必须很慢。"

#: src/programs-proofs/special-types.md:31
#, fuzzy
msgid ""
"If a structure type has only a single non-type non-proof field, then the "
"constructor itself disappears at run time, being replaced with its single "
"argument. In other words, a subtype is represented identically to its "
"underlying type, rather than with an extra layer of indirection. Similarly, "
"`Fin` is just `Nat` in memory, and single-field structures can be created to"
" keep track of different uses of `Nat`s or `String`s without paying a "
"performance penalty. If a constructor has no non-type non-proof arguments, "
"then the constructor also disappears and is replaced with a constant value "
"where the pointer would otherwise be used. This means that `true`, `false`, "
"and `none` are constant values, rather than pointers to heap-allocated "
"objects."
msgstr ""
"如果一个结构类型只有一个非类型非证明字段，那么构造器本身在运行时会消失，并被其单个参数替换。换句话说，一个子类型与其底层类型完全相同，而不是带有额外的间接层。类似地，`Fin`"
" 在内存中只是 `Nat`，并且可以创建单字段结构来跟踪 `Nat` 或 `String` "
"的不同用法，而无需支付性能损失。如果一个构造器没有非类型非证明参数，那么该构造器也会消失，并被一个常量值替换，否则指针将用于该常量值。这意味着 "
"`true`、`false` 和 `none` 是常量值，而不是指向堆分配对象的指针。"

#: src/programs-proofs/special-types.md:38
#, fuzzy
msgid "The following types have special representations:"
msgstr "以下类型具有特殊表示："

#: src/programs-proofs/special-types.md:40
#, fuzzy
msgid "Type"
msgstr "类型"

#: src/programs-proofs/special-types.md:40
#, fuzzy
msgid "Logical representation"
msgstr "逻辑表示"

#: src/programs-proofs/special-types.md:40
#, fuzzy
msgid "Run-time Representation"
msgstr "运行时表示"

#: src/programs-proofs/special-types.md:42
#, fuzzy
msgid "Unary, with one pointer from each `Nat.succ`"
msgstr "一元，每个 `Nat.succ` 有一个指针"

#: src/programs-proofs/special-types.md:42
#: src/programs-proofs/special-types.md:43
#, fuzzy
msgid "Efficient arbitrary-precision integers"
msgstr "高效任意精度整数"

#: src/programs-proofs/special-types.md:43
#, fuzzy
msgid "`Int`"
msgstr "`Int`"

#: src/programs-proofs/special-types.md:43
#, fuzzy
msgid ""
"A sum type with constructors for positive or negative values, each "
"containing a `Nat`"
msgstr "一个具有正值或负值构造器的和类型，每个构造器都包含一个 `Nat`"

#: src/programs-proofs/special-types.md:44
#, fuzzy
msgid "`UInt8`, `UInt16`, `UInt32`, `UInt64`"
msgstr "`UInt8`、`UInt16`、`UInt32`、`UInt64`"

#: src/programs-proofs/special-types.md:44
#, fuzzy
msgid "A `Fin` with an appropriate bound"
msgstr "具有适当界限的 `Fin`"

#: src/programs-proofs/special-types.md:44
#, fuzzy
msgid "Fixed-precision machine integers"
msgstr "定点机器整数"

#: src/programs-proofs/special-types.md:45
#, fuzzy
msgid "`Char`"
msgstr "`Char`"

#: src/programs-proofs/special-types.md:45
#, fuzzy
msgid "A `UInt32` paired with a proof that it's a valid code point"
msgstr "与证明其为有效代码点的 `UInt32` 配对"

#: src/programs-proofs/special-types.md:45
#, fuzzy
msgid "Ordinary characters"
msgstr "普通字符"

#: src/programs-proofs/special-types.md:46
#, fuzzy
msgid "`String`"
msgstr "`String`"

#: src/programs-proofs/special-types.md:46
#, fuzzy
msgid "A structure that contains a `List Char` in a field called `data`"
msgstr "一个结构，它在一个名为 `data` 的字段中包含一个 `List Char`"

#: src/programs-proofs/special-types.md:46
#, fuzzy
msgid "UTF-8-encoded string"
msgstr "UTF-8 编码字符串"

#: src/programs-proofs/special-types.md:47
#, fuzzy
msgid "`Array α`"
msgstr "`Array α`"

#: src/programs-proofs/special-types.md:47
#, fuzzy
msgid "A structure that contains a `List α` in a field called `data`"
msgstr "一个结构，它在一个名为 `data` 的字段中包含一个 `List α`"

#: src/programs-proofs/special-types.md:47
#, fuzzy
msgid "Packed arrays of pointers to `α` values"
msgstr "指向 `α` 值的指针的打包数组"

#: src/programs-proofs/special-types.md:48
#, fuzzy
msgid "`Sort u`"
msgstr "`Sort u`"

#: src/programs-proofs/special-types.md:48
#, fuzzy
msgid "A type"
msgstr "一个类型"

#: src/programs-proofs/special-types.md:48
#: src/programs-proofs/special-types.md:49
#, fuzzy
msgid "Erased completely"
msgstr "完全擦除"

#: src/programs-proofs/special-types.md:49
#, fuzzy
msgid "Proofs of propositions"
msgstr "命题的证明"

#: src/programs-proofs/special-types.md:49
#, fuzzy
msgid ""
"Whatever data is suggested by the proposition when considered as a type of "
"evidence"
msgstr "当命题被视为证据类型时，命题所暗示的任何数据"

#: src/programs-proofs/special-types.md:53
#, fuzzy
msgid ""
"The [definition of `Pos`](../type-classes/pos.html) does not take advantage "
"of Lean's compilation of `Nat` to an efficient type. At run time, it is "
"essentially a linked list. Alternatively, a subtype can be defined that "
"allows Lean's fast `Nat` type to be used internally, as described [in the "
"initial section on subtypes](../functor-applicative-"
"monad/applicative.md#subtypes). At run time, the proof will be erased. "
"Because the resulting structure has only a single data field, it is "
"represented as that field, which means that this new representation of `Pos`"
" is identical to that of `Nat`."
msgstr ""
"`Pos` 的 [定义](../type-classes/pos.html) 并没有利用 Lean 将 `Nat` "
"编译成高效类型的优势。在运行时，它本质上是一个链表。或者，可以定义一个子类型，允许在内部使用 Lean 的快速 `Nat` 类型，如 "
"[子类型初始部分](../functor-applicative-monad/applicative.md#subtypes) "
"中所述。在运行时，证明将被擦除。由于结果结构只有一个数据字段，因此它表示为该字段，这意味着 `Pos` 的这种新表示与 `Nat` 的表示相同。"

#: src/programs-proofs/special-types.md:59
#, fuzzy
msgid ""
"After proving the theorem `∀ {n k : Nat}, n ≠ 0 → k ≠ 0 → n + k ≠ 0`, define"
" instances of `ToString`, and `Add` for this new representation of `Pos`. "
"Then, define an instance of `Mul`, proving any necessary theorems along the "
"way."
msgstr ""
"在证明定理 `∀ {n k : Nat}, n ≠ 0 → k ≠ 0 → n + k ≠ 0` 后，为 `Pos` 的这种新表示定义 "
"`ToString` 和 `Add` 的实例。然后，定义 `Mul` 的实例，在此过程中证明任何必要的定理。"
