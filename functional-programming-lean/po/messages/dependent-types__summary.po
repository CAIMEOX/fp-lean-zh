#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/dependent-types/summary.md:3
#, fuzzy
msgid "Dependent Types"
msgstr "依赖类型"

#: src/dependent-types/summary.md:5
#, fuzzy
msgid ""
"Dependent types, where types contain non-type code such as function calls "
"and ordinary data constructors, lead to a massive increase in the expressive"
" power of a type system. The ability to _compute_ a type from the _value_ of"
" an argument means that the return type of a function can vary based on "
"which argument is provided. This can be used, for example, to have the "
"result type of a database query depend on the database's schema and the "
"specific query issued, without needing any potentially-failing cast "
"operations on the result of the query. When the query changes, so does the "
"type that results from running it, enabling immediate compile-time feedback."
msgstr ""
"依赖类型，其中类型包含非类型代码（例如函数调用和普通数据构造器），导致类型系统的表达能力大幅提升。从参数的 _值_ _计算_ "
"类型的功能意味着函数的返回类型可以根据提供的参数而变化。例如，这可用于使数据库查询的结果类型取决于数据库的架构和发出的特定查询，而无需对查询结果执行任何可能失败的强制转换操作。当查询更改时，运行它所产生的类型也会更改，从而实现立即的编译时反馈。"

#: src/dependent-types/summary.md:10
#, fuzzy
msgid ""
"When a function's return type depends on a value, analyzing the value with "
"pattern matching can result in the type being _refined_, as a variable that "
"stands for a value is replaced by the constructors in the pattern. The type "
"signature of a function documents the way that the return type depends on "
"the argument value, and pattern matching then explains how the return type "
"can be fulfilled for each potential argument."
msgstr ""
"当函数的返回类型依赖于某个值时，使用模式匹配分析该值可以使类型得到“精炼”，因为代表值的变量被模式中的构造器替换。函数的类型签名记录了返回类型依赖于参数值的方式，然后模式匹配解释了如何为每个潜在参数实现返回类型。"

#: src/dependent-types/summary.md:13
#, fuzzy
msgid ""
"Ordinary code that occurs in types is run during type checking, though "
"`partial` functions that might loop infinitely are not called. Mostly, this "
"computation follows the rules of ordinary evaluation that were introduced in"
" [the very beginning of this book](../getting-to-know/evaluating.md), with "
"expressions being progressively replaced by their values until a final value"
" is found. Computation during type checking has an important difference from"
" run-time computation: some values in types may be _variables_ whose values "
"are not yet known. In these cases, pattern-matching gets \"stuck\" and does "
"not proceed until or unless a particular constructor is selected, e.g. by "
"pattern matching. Type-level computation can be seen as a kind of partial "
"evaluation, where only the parts of the program that are sufficiently known "
"need to be evaluated and other parts are left alone."
msgstr ""
"在类型检查期间发生的普通代码在类型检查期间运行，尽管可能无限循环的“部分”函数不会被调用。通常，此计算遵循本书[开头](../getting-to-"
"know/evaluating.md)中介绍的普通求值规则，表达式逐渐被其值替换，直到找到最终值。类型检查期间的计算与运行时计算有一个重要区别：类型中的一些值可能是其值尚未确定的“变量”。在这些情况下，模式匹配会“卡住”，直到或除非选择了一个特定的构造器，例如通过模式匹配。类型级计算可以看作是一种部分求值，其中只需要求值程序中已知的部分，而其他部分则保持不变。"

#: src/dependent-types/summary.md:19
#, fuzzy
msgid "The Universe Pattern"
msgstr "宇宙模式"

#: src/dependent-types/summary.md:21
#, fuzzy
msgid ""
"A common pattern when working with dependent types is to section off some "
"subset of the type system. For example, a database query library might be "
"able to return varying-length strings, fixed-length strings, or numbers in "
"certain ranges, but it will never return a function, a user-defined "
"datatype, or an `IO` action. A domain-specific subset of the type system can"
" be defined by first defining a datatype with constructors that match the "
"structure of the desired types, and then defining a function that interprets"
" values from this datatype into honest-to-goodness types. The constructors "
"are referred to as _codes_ for the types in question, and the entire pattern"
" is sometimes referred to as a _universe à la Tarski_, or just as a "
"_universe_ when context makes it clear that universes such as `Type 3` or "
"`Prop` are not what's meant."
msgstr ""
"使用依赖类型时的一个常见模式是划分类型系统的一部分。例如，数据库查询库可以返回变长字符串、定长字符串或特定范围内的数字，但它永远不会返回函数、用户定义的数据类型或`IO`操作。可以通过首先定义一个具有与所需类型结构匹配的构造器的类型，然后定义一个将此类型中的值解释为诚实类型的值的函数来定义类型系统的特定于域的子集。构造器被称为相关类型的“代码”，并且整个模式有时被称为“Tarski"
" 风格的宇宙”，或者当上下文清楚地表明诸如`Type 3`或`Prop`之类的宇宙不是指代时，简称为“宇宙”。"

#: src/dependent-types/summary.md:26
#, fuzzy
msgid ""
"Custom universes are an alternative to defining a type class with instances "
"for each type of interest. Type classes are extensible, but extensibility is"
" not always desired. Defining a custom universe has a number of advantages "
"over using the types directly:"
msgstr ""
"自定义宇宙是为每种感兴趣的类型定义类型类及其实例的替代方案。类型类是可扩展的，但可扩展性并不总是需要的。与直接使用类型相比，定义自定义宇宙有许多优势："

#: src/dependent-types/summary.md:29
#, fuzzy
msgid ""
"Generic operations that work for _any_ type in the universe, such as "
"equality testing and serialization, can be implemented by recursion on "
"codes."
msgstr "对宇宙中任何类型的通用操作（例如相等性测试和序列化）可以通过对代码的递归来实现。"

#: src/dependent-types/summary.md:30
#, fuzzy
msgid ""
"The types accepted by external systems can be represented precisely, and the"
" definition of the code datatype serves to document what can be expected."
msgstr "外部系统接受的类型可以精确表示，并且代码数据类型的定义有助于记录可以预期的内容。"

#: src/dependent-types/summary.md:31
#, fuzzy
msgid ""
"Lean's pattern matching completeness checker ensures that no codes are "
"forgotten, while solutions based on type classes defer missing instance "
"errors to client code."
msgstr "Lean 的模式匹配完整性检查器确保不会忘记任何代码，而基于类型类的解决方案将丢失的实例错误推迟到客户端代码。"

#: src/dependent-types/summary.md:36
#, fuzzy
msgid ""
"Datatypes can take two separate kinds of arguments: _parameters_ are "
"identical in each constructor of the datatype, while _indices_ may vary "
"between constructors. For a given choice of index, only some constructors of"
" the datatype are available. As an example, `Vect.nil` is available only "
"when the length index is `0`, and `Vect.cons` is available only when the "
"length index is `n+1` for some `n`. While parameters are typically written "
"as named arguments before the colon in a datatype declaration, and indices "
"as arguments in a function type after the colon, Lean can infer when an "
"argument after the colon is used as a parameter."
msgstr ""
"数据类型可以采用两种不同类型的参数：参数在数据类型的每个构造函数中都是相同的，而索引在构造函数之间可能不同。对于给定的索引选择，只有数据类型的某些构造函数可用。例如，`Vect.nil`"
" 仅在长度索引为 `0` 时可用，而 `Vect.cons` 仅在长度索引为 `n+1` 时可用，其中 `n` "
"为某个数字。虽然参数通常在数据类型声明中的冒号之前作为命名参数编写，而索引作为冒号之后的函数类型中的参数编写，但 Lean "
"可以推断出冒号之后的参数何时用作参数。"

#: src/dependent-types/summary.md:41
#, fuzzy
msgid ""
"Indexed families allow the expression of complicated relationships between "
"data, all checked by the compiler. The datatype's invariants can be encoded "
"directly, and there is no way to violate them, not even temporarily. "
"Informing the compiler about the datatype's invariants brings a major "
"benefit: the compiler can now inform the programmer about what must be done "
"to satisfy them. The strategic use of compile-time errors, especially those "
"resulting from underscores, can make it possible to offload some of the "
"programming thought process to Lean, freeing up the programmer's mind to "
"worry about other things."
msgstr ""
"索引族允许表达数据之间的复杂关系，所有这些关系都由编译器检查。数据类型的变量可以被直接编码，并且没有办法违反它们，甚至暂时也不行。告知编译器有关数据类型的变量的主要好处是：编译器现在可以告知程序员必须做什么才能满足它们。战略性地使用编译时错误，尤其是由下划线引起的错误，可以将一些编程思想过程卸载到"
" Lean，从而释放程序员的思想去考虑其他事情。"

#: src/dependent-types/summary.md:46
#, fuzzy
msgid ""
"Encoding invariants using indexed families can lead to difficulties. First "
"off, each invariant requires its own datatype, which then requires its own "
"support libraries. `List.append` and `Vect.append` are not interchangeable, "
"after all. This can lead to code duplication. Secondly, convenient use of "
"indexed families requires that the recursive structure of functions used in "
"types match the recursive structure of the programs being type checked. "
"Programming with indexed families is the art of arranging for the right "
"coincidences to occur. While it's possible to work around missing "
"coincidences with appeals to equality proofs, it is difficult, and it leads "
"to programs littered with cryptic justifications. Thirdly, running "
"complicated code on large values during type checking can lead to compile-"
"time slowdowns. Avoiding these slowdowns for complicated programs can "
"require specialized techniques."
msgstr ""
"使用索引族编码不变量可能会带来困难。首先，每个不变量都需要自己的数据类型，然后需要自己的支持库。毕竟，`List.append` 和 "
"`Vect.append` "
"是不可互换的。这会导致代码重复。其次，方便地使用索引族需要在类型中使用的函数的递归结构与正在类型检查的程序的递归结构相匹配。使用索引族进行编程就是安排正确的巧合发生的艺术。虽然可以通过诉诸相等证明来解决缺失的巧合，但这很困难，并且会导致程序中充斥着难以理解的理由。第三，在类型检查期间对大值运行复杂代码会导致编译时速度变慢。对于复杂的程序，避免这些速度变慢可能需要专门的技术。"

#: src/dependent-types/summary.md:56
#, fuzzy
msgid "Definitional and Propositional Equality"
msgstr "定义和命题相等"

#: src/dependent-types/summary.md:58
#, fuzzy
msgid ""
"Lean's type checker must, from time to time, check whether two types should "
"be considered interchangeable. Because types can contain arbitrary programs,"
" it must therefore be able to check arbitrary programs for equality. "
"However, there is no efficient algorithm to check arbitrary programs for "
"fully-general mathematical equality. To work around this, Lean contains two "
"notions of equality:"
msgstr ""
"Lean "
"的类型检查器必须不时检查两个类型是否应该被认为是可互换的。因为类型可以包含任意程序，所以它必须能够检查任意程序的相等性。但是，没有有效的算法来检查任意程序的完全通用的数学相等性。为了解决这个问题，Lean"
" 包含了两个相等的概念："

#: src/dependent-types/summary.md:63
#, fuzzy
msgid ""
"_Definitional equality_ is an underapproximation of equality that "
"essentially checks for equality of syntactic representation modulo "
"computation and renaming of bound variables. Lean automatically checks for "
"definitional equality in situations where it is required."
msgstr "_定义相等_是相等性的近似，它本质上检查语法表示的相等性，模计算和重命名绑定变量。Lean 在需要时会自动检查定义相等性。"

#: src/dependent-types/summary.md:65
#, fuzzy
msgid ""
"_Propositional equality_ must be explicitly proved and explicitly invoked by"
" the programmer. In return, Lean automatically checks that the proofs are "
"valid and that the invocations accomplish the right goal."
msgstr "命题等价性必须由程序员明确证明和调用。作为回报，Lean 会自动检查证明是否有效，以及调用是否实现了正确目标。"

#: src/dependent-types/summary.md:67
#, fuzzy
msgid ""
"The two notions of equality represent a division of labor between "
"programmers and Lean itself. Definitional equality is simple, but automatic,"
" while propositional equality is manual, but expressive. Propositional "
"equality can be used to unstick otherwise-stuck programs in types."
msgstr ""
"等价性的两个概念代表了程序员和 Lean 本身之间的分工。定义等价性简单，但自动，而命题等价性是手动，但表达力强。命题等价性可用于取消类型中卡住的程序。"

#: src/dependent-types/summary.md:71
#, fuzzy
msgid ""
"However, the frequent use of propositional equality to unstick type-level "
"computation is typically a code smell. It typically means that coincidences "
"were not well-engineered, and it's usually a better idea to either redesign "
"the types and indices or to use a different technique to enforce the needed "
"invariants. When propositional equality is instead used to prove that a "
"program meets a specification, or as part of a subtype, there is less reason"
" to be suspicious."
msgstr ""
"然而，频繁使用命题等价性来取消类型级计算通常是一种代码异味。它通常意味着巧合没有得到很好的设计，并且通常更好的想法是重新设计类型和索引或使用不同的技术来强制执行所需的变量。当命题等价性被用来证明程序满足规范或作为子类型的部分时，就没有理由怀疑。"
