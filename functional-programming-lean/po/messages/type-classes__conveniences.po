#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/type-classes/conveniences.md:3
#, fuzzy
msgid "Constructor Syntax for Instances"
msgstr "实例的构造函数语法"

#: src/type-classes/conveniences.md:5
#, fuzzy
msgid ""
"Behind the scenes, type classes are structure types and instances are values"
" of these types. The only differences are that Lean stores additional "
"information about type classes, such as which parameters are output "
"parameters, and that instances are registered for searching. While values "
"that have structure types are typically defined using either `⟨...⟩` syntax "
"or with braces and fields, and instances are typically defined using "
"`where`, both syntaxes work for both kinds of definition."
msgstr ""
"在幕后，类型类是结构类型，实例是这些类型的值。唯一的区别是 Lean "
"存储有关类型类的附加信息，例如哪些参数是输出参数，以及实例已注册用于搜索。虽然具有结构类型的通常使用 `⟨...⟩` "
"语法或大括号和字段来定义值，并且实例通常使用 `where` 来定义，但两种语法都适用于两种类型的定义。"

#: src/type-classes/conveniences.md:9
#, fuzzy
msgid "For example, a forestry application might represent trees as follows:"
msgstr "例如，一个林业应用程序可能会如下表示树："

#: src/type-classes/conveniences.md:10
#, fuzzy
msgid ""
"```lean\n"
"structure Tree : Type where\n"
"  latinName : String\n"
"  commonNames : List String\n"
"\n"
"def oak : Tree :=\n"
"  ⟨\"Quercus robur\", [\"common oak\", \"European oak\"]⟩\n"
"\n"
"def birch : Tree :=\n"
"  { latinName := \"Betula pendula\",\n"
"    commonNames := [\"silver birch\", \"warty birch\"]\n"
"  }\n"
"\n"
"def sloe : Tree where\n"
"  latinName := \"Prunus spinosa\"\n"
"  commonNames := [\"sloe\", \"blackthorn\"]\n"
"```"
msgstr ""
"```lean\n"
"structure Tree : Type where\n"
"  latinName : String\n"
"  commonNames : List String\n"
"\n"
"def oak : Tree :=\n"
"  ⟨\"Quercus robur\", [\"common oak\", \"European oak\"]⟩\n"
"\n"
"def birch : Tree :=\n"
"  { latinName := \"Betula pendula\",\n"
"    commonNames := [\"silver birch\", \"warty birch\"]\n"
"  }\n"
"\n"
"def sloe : Tree where\n"
"  latinName := \"Prunus spinosa\"\n"
"  commonNames := [\"sloe\", \"blackthorn\"]\n"
"```"

#: src/type-classes/conveniences.md:27
#, fuzzy
msgid "All three syntaxes are equivalent."
msgstr "这三种语法是等价的。"

#: src/type-classes/conveniences.md:29
#, fuzzy
msgid ""
"Similarly, type class instances can be defined using all three syntaxes:"
msgstr "类似地，类型类实例可以使用这三种语法定义："

#: src/type-classes/conveniences.md:44
#, fuzzy
msgid ""
"Generally speaking, the `where` syntax should be used for instances, and the"
" curly-brace syntax should be used for structures. The `⟨...⟩` syntax can be"
" useful when emphasizing that a structure type is very much like a tuple in "
"which the fields happen to be named, but the names are not important at the "
"moment. However, there are situations where it can make sense to use other "
"alternatives. In particular, a library might provide a function that "
"constructs an instance value. Placing a call to this function after `:=` in "
"an instance declaration is the easiest way to use such a function."
msgstr ""
"一般来说，`where` 语法应该用于实例，而大括号语法应该用于结构。当强调一个结构类型非常像一个元组时，`⟨...⟩` "
"语法很有用，其中的字段恰好被命名，但这些名称目前并不重要。然而，在某些情况下，使用其他替代方案是有意义的。特别是，一个库可能提供一个构造实例值的函数。在实例声明中将对该函数的调用放在"
" `:=` 之后是使用此类函数的最简单方法。"

#: src/type-classes/conveniences.md:50
#, fuzzy
msgid "Examples"
msgstr "示例"

#: src/type-classes/conveniences.md:52
#, fuzzy
msgid ""
"When experimenting with Lean code, definitions can be more convenient to use"
" than `#eval` or `#check` commands. First off, definitions don't produce any"
" output, which can help keep the reader's focus on the most interesting "
"output. Secondly, it's easiest to write most Lean programs by starting with "
"a type signature, allowing Lean to provide more assistance and better error "
"messages while writing the program itself. On the other hand, `#eval` and "
"`#check` are easiest to use in contexts where Lean is able to determine the "
"type from the provided expression. Thirdly, `#eval` cannot be used with "
"expressions whose types don't have `ToString` or `Repr` instances, such as "
"functions. Finally, multi-step `do` blocks, `let`\\-expressions, and other "
"syntactic forms that take multiple lines are particularly difficult to write"
" with a type annotation in `#eval` or `#check`, simply because the required "
"parenthesization can be difficult to predict."
msgstr ""
"在使用 Lean 代码进行实验时，定义比 `#eval` 或 `#check` "
"命令更方便。首先，定义不会产生任何输出，这有助于读者专注于最有趣的输出。其次，最简单的编写大多数 Lean 程序的方法是从类型签名开始，允许 Lean "
"在编写程序本身时提供更多帮助和更好的错误消息。另一方面，`#eval` 和 `#check` 最容易在 Lean "
"能够从提供的表达式中确定类型的情况下使用。第三，`#eval` 不能用于类型没有 `ToString` 或 `Repr` "
"实例的表达式，例如函数。最后，多步 `do` 块、`let` 表达式和其他需要多行的语法形式在 `#eval` 或 `#check` "
"中特别难以用类型注释编写，仅仅是因为所需的括号很难预测。"

#: src/type-classes/conveniences.md:59
#, fuzzy
msgid ""
"To work around these issues, Lean supports the explicit indication of "
"examples in a source file. An example is like a definition without a name. "
"For instance, a non-empty list of birds commonly found in Copenhagen's green"
" spaces can be written:"
msgstr "为了解决这些问题，Lean 支持在源文件中明确指示示例。示例就像没有名称的定义。例如，可以编写在哥本哈根绿地中常见的非空鸟类列表："

#: src/type-classes/conveniences.md:62
#, fuzzy
msgid ""
"```lean\n"
"example : NonEmptyList String :=\n"
"  { head := \"Sparrow\",\n"
"    tail := [\"Duck\", \"Swan\", \"Magpie\", \"Eurasian coot\", \"Crow\"]\n"
"  }\n"
"```"
msgstr ""
"```lean\n"
"example : NonEmptyList String :=\n"
"  { head := \"Sparrow\",\n"
"    tail := [\"Duck\", \"Swan\", \"Magpie\", \"Eurasian coot\", \"Crow\"]\n"
"  }\n"
"```"

#: src/type-classes/conveniences.md:69
#, fuzzy
msgid "Examples may define functions by accepting arguments:"
msgstr "示例可以通过接受参数来定义函数："

#: src/type-classes/conveniences.md:74
#, fuzzy
msgid ""
"While this creates a function behind the scenes, this function has no name "
"and cannot be called. Nonetheless, this is useful for demonstrating how a "
"library can be used with arbitrary or unknown values of some given type. In "
"source files, `example` declarations are best paired with comments that "
"explain how the example illustrates the concepts of the library."
msgstr ""
"虽然这在幕后创建了一个函数，但此函数没有名称，并且无法被调用。尽管如此，这对于演示如何将库与给定类型的任意或未知值一起使用非常有用。在源文件中，`example`"
" 声明最好与解释示例如何说明库概念的注释配对。"
