#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/hello-world/starting-a-project.md:3
#, fuzzy
msgid ""
"As a program written in Lean becomes more serious, an ahead-of-time "
"compiler-based workflow that results in an executable becomes more "
"attractive. Like other languages, Lean has tools for building multiple-file "
"packages and managing dependencies. The standard Lean build tool is called "
"Lake (short for \"Lean Make\"), and it is configured in Lean. Just as Lean "
"contains a special-purpose language for writing programs with effects (the "
"`do` language), Lake contains a special-purpose language for configuring "
"builds. These languages are referred to as _embedded domain-specific "
"languages_ (or sometimes _domain-specific embedded languages_, abbreviated "
"EDSL or DSEL). They are _domain-specific_ in the sense that they are used "
"for a particular purpose, with concepts from some sub-domain, and they are "
"typically not suitable for general-purpose programming. They are _embedded_ "
"because they occur inside another language's syntax. While Lean contains "
"rich facilities for creating EDSLs, they are beyond the scope of this book."
msgstr ""
"随着 Lean 中编写的程序变得越来越复杂，基于提前编译器的工作流变得更具吸引力，因为它可以生成可执行文件。与其他语言类似，Lean "
"具有构建多文件包和管理依赖项的工具。标准的 Lean 构建工具称为 Lake（“Lean Make”的缩写），它在 Lean 中进行配置。正如 Lean"
" 包含一门用于编写带效果程序的特殊语言（`do` 语言）一样，Lake 也包含一门用于配置构建的特殊语言。这些语言被称为 "
"_嵌入式领域特定语言_（或有时称为 _领域特定嵌入式语言_，缩写为 EDSL 或 DSEL）。它们是 _领域特定_ "
"的，因为它们用于特定目的，包含来自某个子领域的术语，并且通常不适用于通用编程。它们是 _嵌入式_ 的，因为它们出现在另一种语言的语法中。虽然 Lean "
"包含丰富的用于创建 EDSL 的工具，但它们超出了本书的范围。"

#: src/hello-world/starting-a-project.md:12
#, fuzzy
msgid "First steps"
msgstr "入门"

#: src/hello-world/starting-a-project.md:14
#, fuzzy
msgid ""
"To get started with a project that uses Lake, use the command `lake new "
"greeting` in a directory that does not already contain a file or directory "
"called `greeting`. This creates a directory called `greeting` that contains "
"the following files:"
msgstr ""
"要开始使用一个使用 Lake 的项目，请在尚未包含名为 `greeting` 的文件或目录的目录中使用命令 `lake new "
"greeting`。这将创建一个名为 `greeting` 的目录，其中包含以下文件："

#: src/hello-world/starting-a-project.md:17
#, fuzzy
msgid ""
"`Main.lean` is the file in which the Lean compiler will look for the `main` "
"action."
msgstr "`Main.lean` 是 Lean 编译器将查找 `main` 操作的文件。"

#: src/hello-world/starting-a-project.md:18
#, fuzzy
msgid ""
"`Greeting.lean` and `Greeting/Basic.lean` are the scaffolding of a support "
"library for the program."
msgstr "`Greeting.lean` 和 `Greeting/Basic.lean` 是程序支持库的脚手架。"

#: src/hello-world/starting-a-project.md:19
#, fuzzy
msgid ""
"`lakefile.lean` contains the configuration that `lake` needs to build the "
"application."
msgstr "`lakefile.lean` 包含 `lake` 构建应用程序所需的配置。"

#: src/hello-world/starting-a-project.md:20
#, fuzzy
msgid ""
"`lean-toolchain` contains an identifier for the specific version of Lean "
"that is used for the project."
msgstr "`lean-toolchain` 包含用于项目的特定 Lean 版本的标识符。"

#: src/hello-world/starting-a-project.md:22
#, fuzzy
msgid ""
"Additionally, `lake new` initializes the project as a Git repository and "
"configures its `.gitignore` file to ignore intermediate build products. "
"Typically, the majority of the application logic will be in a collection of "
"libraries for the program, while `Main.lean` will contain a small wrapper "
"around these pieces that does things like parsing command lines and "
"executing the central application logic. To create a project in an already-"
"existing directory, run `lake init` instead of `lake new`."
msgstr ""
"此外，`lake new` 将项目初始化为 Git 存储库，并配置其 `.gitignore` "
"文件以忽略中间构建产品。通常，应用程序逻辑的大部分将位于程序的库集合中，而 `Main.lean` "
"将包含这些部分周围的一个小包装，它执行诸如解析命令行和执行中央应用程序逻辑之类的操作。要在已存在的目录中创建项目，请运行 `lake init` 而不是"
" `lake new`。"

#: src/hello-world/starting-a-project.md:26
#, fuzzy
msgid ""
"By default, the library file `Greeting/Basic.lean` contains a single "
"definition:"
msgstr "默认情况下，库文件 `Greeting/Basic.lean` 包含一个定义："

#: src/hello-world/starting-a-project.md:27
#, fuzzy
msgid ""
"```lean\n"
"def hello := \"world\"\n"
"```"
msgstr ""
"```lean\n"
"def hello := \"world\"\n"
"```"

#: src/hello-world/starting-a-project.md:30
#, fuzzy
msgid "The library file `Greeting.lean` imports `Greeting/Basic.lean`:"
msgstr "库文件 `Greeting.lean` 导入 `Greeting/Basic.lean`："

#: src/hello-world/starting-a-project.md:36
#, fuzzy
msgid ""
"This means that everything defined in `Greetings/Basic.lean` is also "
"available to files that import `Greetings.lean`. In `import` statements, "
"dots are interpreted as directories on disk. Placing guillemets around a "
"name, as in `«Greeting»`, allow it to contain spaces or other characters "
"that are normally not allowed in Lean names, and it allows reserved keywords"
" such as `if` or `def` to be used as ordinary names by writing `«if»` or "
"`«def»`. This prevents issues when the package name provided to `lake new` "
"contains such characters."
msgstr ""
"这意味着在 `Greetings/Basic.lean` 中定义的所有内容也对导入 `Greetings.lean` 的文件可用。在 `import` "
"语句中，点被解释为磁盘上的目录。在名称周围放置引号，如 `«Greeting»`，允许它包含空格或其他通常不允许在 Lean "
"名称中出现的字符，并且它允许通过编写 `«if»` 或 `«def»` 将保留关键字（如 `if` 或 `def`）用作普通名称。当提供给 `lake "
"new` 的包名称包含此类字符时，这可以防止出现问题。"

#: src/hello-world/starting-a-project.md:41
#, fuzzy
msgid "The executable source `Main.lean` contains:"
msgstr "可执行源 `Main.lean` 包含："

#: src/hello-world/starting-a-project.md:42
#, fuzzy
msgid ""
"```lean\n"
"import «Greeting»\n"
"\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, {hello}!\"\n"
"```"
msgstr ""
"```lean\n"
"import «Greeting»\n"
"\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, {hello}!\"\n"
"```"

#: src/hello-world/starting-a-project.md:48
#, fuzzy
msgid ""
"Because `Main.lean` imports `Greetings.lean` and `Greetings.lean` imports "
"`Greetings/Basic.lean`, the definition of `hello` is available in `main`."
msgstr ""
"因为 `Main.lean` 导入 `Greetings.lean`，而 `Greetings.lean` 导入 "
"`Greetings/Basic.lean`，所以 `hello` 的定义在 `main` 中可用。"

#: src/hello-world/starting-a-project.md:50
msgid ""
"To build the package, run the command `lake build`. After a number of build "
"commands scroll by, the resulting binary has been placed in `build/bin`. "
"Running `./build/bin/greeting` results in `Hello, world!`."
msgstr ""
"要构建包，运行命令 `lake build`。在滚动显示一些构建命令后，结果二进制文件已放置在 `build/bin` 中。运行 "
"`./build/bin/greeting` 会生成 `Hello, world!`。"

#: src/hello-world/starting-a-project.md:54
msgid "Lakefiles"
msgstr "Lakefile"

#: src/hello-world/starting-a-project.md:56
msgid ""
"A `lakefile.lean` describes a _package_, which is a coherent collection of "
"Lean code for distribution, analogous to an `npm` or `nuget` package or a "
"Rust crate. A package may contain any number of libraries or executables. "
"While the [documentation for "
"Lake](https://github.com/leanprover/lean4/blob/master/src/lake/README.md) "
"describes the available options in a lakefile, it makes use of a number of "
"Lean features that have not yet been described here. The generated "
"`lakefile.lean` contains the following:"
msgstr ""
"`lakefile.lean` 描述了一个 _包_，它是一个连贯的 Lean 代码集合，用于分发，类似于 `npm` 或 `nuget` 包或 Rust"
" 箱子。一个包可以包含任意数量的库或可执行文件。虽然 [Lake "
"文档](https://github.com/leanprover/lean4/blob/master/src/lake/README.md) 描述了 "
"lakefile 中的可用选项，但它使用了此处尚未描述的许多 Lean 特性。生成的 `lakefile.lean` 包含以下内容："

#: src/hello-world/starting-a-project.md:79
msgid "This initial Lakefile consists of three items:"
msgstr "这个初始 Lakefile 由三项组成："

#: src/hello-world/starting-a-project.md:80
msgid "a _package_ declaration, named `greeting`,"
msgstr "一个名为 `greeting` 的 _包_声明，"

#: src/hello-world/starting-a-project.md:81
msgid "a _library_ declaration, named `Greeting`, and"
msgstr "一个名为 `Greeting` 的 _库_声明，以及"

#: src/hello-world/starting-a-project.md:82
msgid "an _executable_, also named `greeting`."
msgstr "一个也名为 `greeting` 的 _可执行文件_。"

#: src/hello-world/starting-a-project.md:84
msgid ""
"Each of these names is enclosed in guillemets to allow users more freedom in"
" picking package names."
msgstr "这些名称中的每一个都用引号括起来，以允许用户在选择包名称时有更大的自由度。"

#: src/hello-world/starting-a-project.md:86
msgid ""
"Each Lakefile will contain exactly one package, but any number of libraries "
"or executables. Additionally, Lakefiles may contain _external libraries_, "
"which are libraries not written in Lean to be statically linked with the "
"resulting executable, _custom targets_, which are build targets that don't "
"fit naturally into the library/executable taxonomy, _dependencies_, which "
"are declarations of other Lean packages (either locally or from remote Git "
"repositories), and _scripts_, which are essentially `IO` actions (similar to"
" `main`), but that additionally have access to metadata about the package "
"configuration. The items in the Lakefile allow things like source file "
"locations, module hierarchies, and compiler flags to be configured. "
"Generally speaking, however, the defaults are reasonable."
msgstr ""
"每个 Lakefile 将只包含一个包，但可以包含任意数量的库或可执行文件。此外，Lakefile 可能包含 _外部库_（不是用 Lean "
"编写的库，将与结果可执行文件静态链接）、_自定义目标_（不自然地适合于库/可执行文件分类的构建目标）、_依赖项_（其他 Lean "
"包的声明（在本地或来自远程 Git 存储库））、以及 _脚本_（本质上是 `IO` 操作（类似于 "
"`main`），但还可以访问有关包配置的元数据）。Lakefile 中的项允许配置源文件位置、模块层次结构和编译器标志。然而，一般来说，默认值是合理的。"

#: src/hello-world/starting-a-project.md:91
#, fuzzy
msgid ""
"Libraries, executables, and custom targets are all called _targets_. By "
"default, `lake build` builds those targets that are annotated with "
"`@[default_target]`. This annotation is an _attribute_, which is metadata "
"that can be associated with a Lean declaration. Attributes are similar to "
"Java annotations or C# and Rust attributes. They are used pervasively "
"throughout Lean. To build a target that is not annotated with "
"`@[default_target]`, specify the target's name as an argument after `lake "
"build`."
msgstr ""
"库、可执行文件和自定义目标统称为“目标”。默认情况下，`lake build` 会构建那些标注了 `@[default_target]` "
"的目标。此标注是一个“属性”，它是一种可以与 Lean 声明关联的元数据。属性类似于 Java 标注或 C# 和 Rust 属性。它们在 Lean "
"中被广泛使用。要构建未标注 `@[default_target]` 的目标，请在 `lake build` 后指定目标名称作为参数。"

#: src/hello-world/starting-a-project.md:98
#, fuzzy
msgid "Libraries and Imports"
msgstr "库和导入"

#: src/hello-world/starting-a-project.md:100
#, fuzzy
msgid ""
"A Lean library consists of a hierarchically organized collection of source "
"files from which names can be imported, called _modules_. By default, a "
"library has a single root file that matches its name. In this case, the root"
" file for the library `Greeting` is `Greeting.lean`. The first line of "
"`Main.lean`, which is `import Greeting`, makes the contents of "
"`Greeting.lean` available in `Main.lean`."
msgstr ""
"一个 Lean 库由一个分层组织的源文件集合组成，可以从中导入名称，称为“模块”。默认情况下，一个库有一个与它的名称匹配的单一根文件。在这种情况下，库 "
"`Greeting` 的根文件是 `Greeting.lean`。`Main.lean` 的第一行是 `import Greeting`，它使 "
"`Greeting.lean` 的内容在 `Main.lean` 中可用。"

#: src/hello-world/starting-a-project.md:105
#, fuzzy
msgid ""
"Additional module files may be added to the library by creating a directory "
"called `Greeting` and placing them inside. These names can be imported by "
"replacing the directory separator with a dot. For instance, creating the "
"file `Greeting/Smile.lean` with the contents:"
msgstr ""
"可以通过创建一个名为 `Greeting` 的目录并将它们放在里面来向库中添加额外的模块文件。可以通过用点替换目录分隔符来导入这些名称。例如，创建文件 "
"`Greeting/Smile.lean`，其内容为："

#: src/hello-world/starting-a-project.md:108
#, fuzzy
msgid ""
"```lean\n"
"def expression : String := \"a big smile\"\n"
"```"
msgstr ""
"```lean\n"
"def expression : String := \"a big smile\"\n"
"```"

#: src/hello-world/starting-a-project.md:111
#, fuzzy
msgid "means that `Main.lean` can use the definition as follows:"
msgstr "这意味着 `Main.lean` 可以使用如下定义："

#: src/hello-world/starting-a-project.md:112
#, fuzzy
msgid ""
"```lean\n"
"import Greeting\n"
"import Greeting.Smile\n"
"\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, {hello}, with {expression}!\"\n"
"```"
msgstr ""
"```lean\n"
"import Greeting\n"
"import Greeting.Smile\n"
"\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, {hello}, with {expression}!\"\n"
"```"

#: src/hello-world/starting-a-project.md:120
#, fuzzy
msgid ""
"The module name hierarchy is decoupled from the namespace hierarchy. In "
"Lean, modules are units of code distribution, while namespaces are units of "
"code organization. That is, names defined in the module `Greeting.Smile` are"
" not automatically in a corresponding namespace `Greeting.Smile`. Modules "
"may place names into any namespace they like, and the code that imports them"
" may `open` the namespace or not. `import` is used to make the contents of a"
" source file available, while `open` makes names from a namespace available "
"in the current context without prefixes. In the Lakefile, the line `import "
"Lake` makes the contents of the `Lake` module available, while the line "
"`open Lake DSL` makes the contents of the `Lake` and `Lake.DSL` namespaces "
"available without any prefixes. `Lake.DSL` is opened because opening `Lake` "
"makes `Lake.DSL` available as just `DSL`, just like all other names in the "
"`Lake` namespace. The `Lake` module places names into both the `Lake` and "
"`Lake.DSL` namespaces."
msgstr ""
"模块名称层次结构与命名空间层次结构是分离的。在 Lean 中，模块是代码分发单元，而命名空间是代码组织单元。也就是说，在模块 "
"`Greeting.Smile` 中定义的名称不会自动出现在相应的命名空间 `Greeting.Smile` "
"中。模块可以将名称放入他们喜欢的任何命名空间中，而导入它们的代码可以 `open` 命名空间也可以不 `open`。`import` "
"用于使源文件的内容可用，而 `open` 使命名空间中的名称在当前上下文中可用，而无需前缀。在 Lakefile 中，行 `import Lake` 使"
" `Lake` 模块的内容可用，而行 `open Lake DSL` 使 `Lake` 和 `Lake.DSL` "
"命名空间的内容可用，而无需任何前缀。`Lake.DSL` 被打开，因为打开 `Lake` 使 `Lake.DSL` 可用，就像 `Lake` "
"命名空间中的所有其他名称一样。`Lake` 模块将名称放入 `Lake` 和 `Lake.DSL` 命名空间中。"

#: src/hello-world/starting-a-project.md:129
#, fuzzy
msgid ""
"Namespaces may also be opened _selectively_, making only some of their names"
" available without explicit prefixes. This is done by writing the desired "
"names in parentheses. For example, `Nat.toFloat` converts a natural number "
"to a `Float`. It can be made available as `toFloat` using `open Nat "
"(toFloat)`."
msgstr ""
"命名空间也可以进行_选择性_打开，只公开部分名称而无需显式前缀。这可以通过在括号中编写所需名称来完成。例如，`Nat.toFloat` 将自然数转换为 "
"`Float`。可以使用 `open Nat (toFloat)` 将其公开为 `toFloat`。"
