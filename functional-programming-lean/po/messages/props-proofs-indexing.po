#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/props-proofs-indexing.md:3
#, fuzzy
msgid ""
"Like many languages, Lean uses square brackets for indexing into arrays and "
"lists. For instance, if `woodlandCritters` is defined as follows:"
msgstr "与许多语言一样，Lean 使用方括号对数组和列表进行索引。例如，如果 `woodlandCritters` 定义如下："

#: src/props-proofs-indexing.md:5
#, fuzzy
msgid ""
"```lean\n"
"def woodlandCritters : List String :=\n"
"  [\"hedgehog\", \"deer\", \"snail\"]\n"
"```"
msgstr ""
"```lean\n"
"def woodlandCritters : List String :=\n"
"  [\"hedgehog\", \"deer\", \"snail\"]\n"
"```"

#: src/props-proofs-indexing.md:9
#, fuzzy
msgid "then the individual components can be extracted:"
msgstr "那么可以提取各个组件："

#: src/props-proofs-indexing.md:15
#, fuzzy
msgid ""
"However, attempting to extract the fourth element results in a compile-time "
"error, rather than a run-time error:"
msgstr "但是，尝试提取第四个元素会导致编译时错误，而不是运行时错误："

#: src/props-proofs-indexing.md:27
#, fuzzy
msgid ""
"This error message is saying Lean tried to automatically mathematically "
"prove that `3 < List.length woodlandCritters`, which would mean that the "
"lookup was safe, but that it could not do so. Out-of-bounds errors are a "
"common class of bugs, and Lean uses its dual nature as a programming "
"language and a theorem prover to rule out as many as possible."
msgstr ""
"此错误消息表明 Lean 尝试自动数学证明 `3 < List.length "
"woodlandCritters`，这意味着查找是安全的，但它无法做到。越界错误是一类常见的错误，而 Lean "
"使用其作为编程语言和定理证明器的双重特性来排除尽可能多的错误。"

#: src/props-proofs-indexing.md:30
#, fuzzy
msgid ""
"Understanding how this works requires an understanding of three key ideas: "
"propositions, proofs, and tactics."
msgstr "要理解这是如何工作的，需要理解三个关键概念：命题、证明和策略。"

#: src/props-proofs-indexing.md:32
#, fuzzy
msgid "Propositions and Proofs"
msgstr "命题和证明"

#: src/props-proofs-indexing.md:34
#, fuzzy
msgid ""
"A _proposition_ is a statement that can be true or false. All of the "
"following are propositions:"
msgstr "_命题_ 是可以为真或为假的说法。以下所有都是命题："

#: src/props-proofs-indexing.md:37
#, fuzzy
msgid "1 + 1 = 2"
msgstr "1 + 1 = 2"

#: src/props-proofs-indexing.md:38
#, fuzzy
msgid "Addition is commutative"
msgstr "加法是可交换的"

#: src/props-proofs-indexing.md:39
#, fuzzy
msgid "There are infinitely many prime numbers"
msgstr "质数有无穷多个"

#: src/props-proofs-indexing.md:40
#, fuzzy
msgid "1 + 1 = 15"
msgstr "1 + 1 = 15"

#: src/props-proofs-indexing.md:41
#, fuzzy
msgid "Paris is the capital of France"
msgstr "巴黎是法国的首都"

#: src/props-proofs-indexing.md:42
#, fuzzy
msgid "Buenos Aires is the capital of South Korea"
msgstr "布宜诺斯艾利斯是韩国的首都"

#: src/props-proofs-indexing.md:43
#, fuzzy
msgid "All birds can fly"
msgstr "所有鸟都会飞"

#: src/props-proofs-indexing.md:45
#, fuzzy
msgid ""
"On the other hand, nonsense statements are not propositions. None of the "
"following are propositions:"
msgstr "另一方面，无意义的陈述不是命题。以下都不是命题："

#: src/props-proofs-indexing.md:48
#, fuzzy
msgid "1 + green = ice cream"
msgstr "1 + 绿色 = 冰淇淋"

#: src/props-proofs-indexing.md:49
#, fuzzy
msgid "All capital cities are prime numbers"
msgstr "所有首都都是质数"

#: src/props-proofs-indexing.md:50
#, fuzzy
msgid "At least one gorg is a fleep"
msgstr "至少有一个 gorg 是一个 fleep"

#: src/props-proofs-indexing.md:52
#, fuzzy
msgid ""
"Propositions come in two varieties: those that are purely mathematical, "
"relying only on our definitions of concepts, and those that are facts about "
"the world. Theorem provers like Lean are concerned with the former category,"
" and have nothing to say about the flight capabilities of penguins or the "
"legal status of cities."
msgstr ""
"命题有两种类型：纯粹的数学命题，仅依赖于我们对概念的定义；以及关于世界的事实。像 Lean "
"这样的定理证明器关注的是前一类，而对企鹅的飞行能力或城市的法律地位没有任何说法。"

#: src/props-proofs-indexing.md:55
#, fuzzy
msgid ""
"A _proof_ is a convincing argument that a proposition is true. For "
"mathematical propositions, these arguments make use of the definitions of "
"the concepts that are involved as well as the rules of logical "
"argumentation. Most proofs are written for people to understand, and leave "
"out many tedious details. Computer-aided theorem provers like Lean are "
"designed to allow mathematicians to write proofs while omitting many "
"details, and it is the software's responsibility to fill in the missing "
"explicit steps. This decreases the likelihood of oversights or mistakes."
msgstr ""
"证明是令人信服的论证，证明命题为真。对于数学命题，这些论证利用了所涉及概念的定义以及逻辑论证规则。大多数证明都是为人们理解而写的，并省略了许多繁琐的细节。像"
" Lean 这样的计算机辅助定理证明器旨在允许数学家在省略许多细节的情况下编写证明，而软件负责填写缺失的显式步骤。这降低了疏忽或错误的可能性。"

#: src/props-proofs-indexing.md:61
#, fuzzy
msgid ""
"In Lean, a program's type describes the ways it can be interacted with. For "
"instance, a program of type `Nat → List String` is a function that takes a "
"`Nat` argument and produces a list of strings. In other words, each type "
"specifies what counts as a program with that type."
msgstr ""
"在 Lean 中，程序的类型描述了与它交互的方式。例如，类型为 `Nat → List String` 的程序是一个函数，它接受一个 `Nat` "
"参数并生成一个字符串列表。换句话说，每个类型指定了具有该类型的程序的内容。"

#: src/props-proofs-indexing.md:65
#, fuzzy
msgid ""
"In Lean, propositions are in fact types. They specify what counts as "
"evidence that the statement is true. The proposition is proved by providing "
"this evidence. On the other hand, if the proposition is false, then it will "
"be impossible to construct this evidence."
msgstr ""
"在 Lean 中，命题实际上是类型。它们指定了作为该语句为真的证据的内容。通过提供此证据来证明命题。另一方面，如果命题为假，则不可能构造此证据。"

#: src/props-proofs-indexing.md:70
#, fuzzy
msgid ""
"For example, the proposition \"1 + 1 = 2\" can be written directly in Lean. "
"The evidence for this proposition is the constructor `rfl`, which is short "
"for _reflexivity_:"
msgstr "例如，命题“1 + 1 = 2”可以直接写在 Lean 中。此命题的证据是构造器 `rfl`，它是 _自反性_的缩写："

#: src/props-proofs-indexing.md:75
#, fuzzy
msgid ""
"On the other hand, `rfl` does not prove the false proposition \"1 + 1 = "
"15\":"
msgstr "另一方面，`rfl` 不能证明错误命题“1 + 1 = 15”："

#: src/props-proofs-indexing.md:87
#, fuzzy
msgid ""
"This error message indicates that `rfl` can prove that two expressions are "
"equal when both sides of the equality statement are already the same number."
" Because `1 + 1` evaluates directly to `2`, they are considered to be the "
"same, which allows `onePlusOneIsTwo` to be accepted. Just as `Type` "
"describes types such as `Nat`, `String`, and `List (Nat × String × (Int → "
"Float))` that represent data structures and functions, `Prop` describes "
"propositions."
msgstr ""
"此错误消息表明，当等式语句的两边已经是相同的数字时，`rfl` 可以证明两个表达式相等。因为 `1 + 1` 直接计算为 "
"`2`，所以它们被认为是相同的，这允许接受 `onePlusOneIsTwo`。就像 `Type` 描述表示数据结构和函数的类型（例如 "
"`Nat`、`String` 和 `List (Nat × String × (Int → Float))`）一样，`Prop` 描述命题。"

#: src/props-proofs-indexing.md:91
#, fuzzy
msgid ""
"When a proposition has been proven, it is called a _theorem_. In Lean, it is"
" conventional to declare theorems with the `theorem` keyword instead of "
"`def`. This helps readers see which declarations are intended to be read as "
"mathematical proofs, and which are definitions. Generally speaking, with a "
"proof, what matters is that there is evidence that a proposition is true, "
"but it's not particularly important _which_ evidence was provided. With "
"definitions, on the other hand, it matters very much which particular value "
"is selected—after all, a definition of addition that always returns `0` is "
"clearly wrong."
msgstr ""
"当一个命题被证明后，它被称为一个 _定理_。在 Lean 中，惯例是用 `theorem` 关键字而不是 `def` "
"来声明定理。这有助于读者看出哪些声明旨在被解读为数学证明，哪些是定义。一般来说，对于一个证明，重要的是有证据表明一个命题是正确的，但提供 _哪_ "
"个证据并不特别重要。另一方面，对于定义，选择哪个特定值非常重要——毕竟，一个总是返回 `0` 的加法定义显然是错误的。"

#: src/props-proofs-indexing.md:97
#, fuzzy
msgid "The prior example could be rewritten as follows:"
msgstr "前面的例子可以改写如下："

#: src/props-proofs-indexing.md:104
#, fuzzy
msgid "Tactics"
msgstr "策略"

#: src/props-proofs-indexing.md:106
#, fuzzy
msgid ""
"Proofs are normally written using _tactics_, rather than by providing "
"evidence directly. Tactics are small programs that construct evidence for a "
"proposition. These programs run in a _proof state_ that tracks the statement"
" that is to be proved (called the _goal_) along with the assumptions that "
"are available to prove it. Running a tactic on a goal results in a new proof"
" state that contains new goals. The proof is complete when all goals have "
"been proven."
msgstr ""
"证明通常使用 _策略_ 来编写，而不是直接提供证据。策略是为命题构建证据的小程序。这些程序在一个 _证明状态_ 中运行，该状态跟踪要证明的陈述（称为 "
"_目标_）以及可用于证明它的假设。在目标上运行策略会产生一个包含新目标的新证明状态。当所有目标都被证明后，证明就完成了。"

#: src/props-proofs-indexing.md:112
#, fuzzy
msgid ""
"To write a proof with tactics, begin the definition with `by`. Writing `by` "
"puts Lean into tactic mode until the end of the next indented block. While "
"in tactic mode, Lean provides ongoing feedback about the current proof "
"state. Written with tactics, `onePlusOneIsTwo` is still quite short:"
msgstr ""
"要使用策略编写证明，请以 `by` 开始定义。编写 `by` 会将 Lean 置于策略模式，直到下一个缩进块的末尾。在策略模式下，Lean "
"会持续提供有关当前证明状态的反馈。使用策略编写的 `onePlusOneIsTwo` 仍然很短："

#: src/props-proofs-indexing.md:120
#, fuzzy
msgid ""
"The `simp` tactic, short for \"simplify\", is the workhorse of Lean proofs. "
"It rewrites the goal to as simple a form as possible, taking care of parts "
"of the proof that are small enough. In particular, it proves simple equality"
" statements. Behind the scenes, a detailed formal proof is constructed, but "
"using `simp` hides this complexity."
msgstr ""
"`simp` 策略，即“简化”的缩写，是 Lean "
"证明的主力。它将目标重写为尽可能简单的形式，处理足够小的证明部分。特别是，它证明了简单的等式陈述。在幕后，构建了一个详细的形式化证明，但使用 "
"`simp` 隐藏了这种复杂性。"

#: src/props-proofs-indexing.md:125
#, fuzzy
msgid "Tactics are useful for a number of reasons:"
msgstr "战术在许多方面很有用："

#: src/props-proofs-indexing.md:126
#, fuzzy
msgid ""
"Many proofs are complicated and tedious when written out down to the "
"smallest detail, and tactics can automate these uninteresting parts."
msgstr "许多证明在写到最小的细节时都很复杂且乏味，而战术可以自动完成这些无趣的部分。"

#: src/props-proofs-indexing.md:127
#, fuzzy
msgid ""
"Proofs written with tactics are easier to maintain over time, because "
"flexible automation can paper over small changes to definitions."
msgstr "使用战术编写的证明更容易维护，因为灵活的自动化可以弥补定义的细微更改。"

#: src/props-proofs-indexing.md:128
#, fuzzy
msgid ""
"Because a single tactic can prove many different theorems, Lean can use "
"tactics behind the scenes to free users from writing proofs by hand. For "
"instance, an array lookup requires a proof that the index is in bounds, and "
"a tactic can typically construct that proof without the user needing to "
"worry about it."
msgstr ""
"因为一个战术可以证明许多不同的定理，Lean "
"可以使用幕后的战术来解放用户亲手写证明。例如，数组查找需要证明索引在范围内，而战术通常可以在用户无需担心它的情况下构造该证明。"

#: src/props-proofs-indexing.md:130
#, fuzzy
msgid ""
"Behind the scenes, indexing notation uses a tactic to prove that the user's "
"lookup operation is safe. This tactic is `simp`, configured to take certain "
"arithmetic identities into account."
msgstr "在幕后，索引符号使用战术来证明用户的查找操作是安全的。这个战术是 `simp`，配置为考虑某些算术恒等式。"

#: src/props-proofs-indexing.md:134
#, fuzzy
msgid "Connectives"
msgstr "连接词"

#: src/props-proofs-indexing.md:136
#, fuzzy
msgid ""
"The basic building blocks of logic, such as \"and\", \"or\", \"true\", "
"\"false\", and \"not\", are called _logical connectives_. Each connective "
"defines what counts as evidence of its truth. For example, to prove a "
"statement \"_A_ and _B_\", one must prove both _A_ and _B_. This means that "
"evidence for \"_A_ and _B_\" is a pair that contains both evidence for _A_ "
"and evidence for _B_. Similarly, evidence for \"_A_ or _B_\" consists of "
"either evidence for _A_ or evidence for _B_."
msgstr ""
"逻辑的基本构建块，例如“与”、“或”、“真”、“假”和“非”，称为 _逻辑连接词_。每个连接词定义了什么算作其真值的证据。例如，要证明一个陈述“_A_ "
"与 _B_”，必须证明 _A_ 和 _B_。这意味着“_A_ 与 _B_”的证据是一对，其中包含 _A_ 的证据和 _B_ 的证据。类似地，“_A_ 或"
" _B_”的证据由 _A_ 的证据或 _B_ 的证据组成。"

#: src/props-proofs-indexing.md:142
#, fuzzy
msgid ""
"In particular, most of these connectives are defined like datatypes, and "
"they have constructors. If `A` and `B` are propositions, then \"`A` and "
"`B`\" (written `A ∧ B`) is a proposition. Evidence for `A ∧ B` consists of "
"the constructor `And.intro`, which has the type `A → B → A ∧ B`. Replacing "
"`A` and `B` with concrete propositions, it is possible to prove `1 + 1 = 2 ∧"
" \"Str\".append \"ing\" = \"String\"` with `And.intro rfl rfl`. Of course, "
"`simp` is also powerful enough to find this proof:"
msgstr ""
"特别是，大多数这些连接词都像数据类型一样定义，并且它们有构造函数。如果 `A` 和 `B` 是命题，那么“`A` 与 `B`”（写为 `A ∧ "
"B`）是一个命题。`A ∧ B` 的证据由构造函数 `And.intro` 组成，其类型为 `A → B → A ∧ B`。用具体命题替换 `A` 和 "
"`B`，可以用 `And.intro rfl rfl` 证明 `1 + 1 = 2 ∧ \"Str\".append \"ing\" = "
"\"String\"`。当然，`simp` 也足够强大，可以找到这个证明："

#: src/props-proofs-indexing.md:147
msgid ""
"```leantac\n"
"theorem addAndAppend : 1 + 1 = 2 ∧ \"Str\".append \"ing\" = \"String\" := by simp\n"
"```"
msgstr ""
"定理 addAndAppend : 1 + 1 = 2 ∧ \"Str\".append \"ing\" = \"String\" := by simp\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"：\n"
"\n"
"连接词 | Lean 语法 | 证据\n"
"---|---|---\n"
"真 | `True` | `True.intro : True`\n"
"假 | `False` | 无证据\n"
"_A_ 和 _B_ | `A ∧ B` | `And.intro : A → B → A ∧ B`\n"
"_A_ 或 _B_ | `A ∨ B` | `Or.inl : A → A ∨ B` 或 `Or.inr : B → A ∨ B`\n"
"_A_ 蕴涵 _B_ | `A → B` | 将 _A_ 的证据转换为 _B_ 的证据的函数\n"
"非 _A_ | `¬A` | 将 _A_ 的证据转换为 `False` 的证据的函数\n"
"\n"
"`simp` 战术可以证明使用这些连接词的定理。例如：\n"
"\n"
"证据作为参数\n"
"\n"
"虽然 `simp` 在证明涉及特定数字的相等性和不等性的命题方面做得很好，但它在证明涉及变量的陈述方面并不是很好。例如，`simp` 可以证明 `4 < 15`，但它不能轻易地说明因为 `x < 4`，所以 `x < 15` 也是真的。因为索引表示在幕后使用 `simp` 来证明数组访问是安全的，所以它可能需要一些人工干预。"

#: src/props-proofs-indexing.md:151
msgid ""
"Similarly, \"`A` or `B`\" (written `A ∨ B`) has two constructors, because a "
"proof of \"`A` or `B`\" requires only that one of the two underlying "
"propositions be true. There are two constructors: `Or.inl`, with type `A → A"
" ∨ B`, and `Or.inr`, with type `B → A ∨ B`."
msgstr ""
"类似地，“`A` 或 `B`”（写为 `A ∨ B`）有两个构造器，因为“`A` 或 "
"`B`”的证明仅要求两个底层命题中的一个为真。有两个构造器：`Or.inl`，类型为 `A → A ∨ B`，和 `Or.inr`，类型为 `B → A"
" ∨ B`。"

#: src/props-proofs-indexing.md:154
msgid ""
"Implication (if _A_ then _B_) is represented using functions. In particular,"
" a function that transforms evidence for _A_ into evidence for _B_ is itself"
" evidence that _A_ implies _B_. This is different from the usual description"
" of implication, in which `A → B` is shorthand for `¬A ∨ B`, but the two "
"formulations are equivalent."
msgstr ""
"蕴涵（如果 _A_ 则 _B_）使用函数表示。特别是，将 _A_ 的证据转换为 _B_ 的证据的函数本身就是 _A_ 蕴涵 _B_ "
"的证据。这与蕴涵的通常描述不同，其中 `A → B` 是 `¬A ∨ B` 的简写，但这两个公式是等价的。"

#: src/props-proofs-indexing.md:158
msgid ""
"Because evidence for an \"and\" is a constructor, it can be used with "
"pattern matching. For instance, a proof that _A_ and _B_ implies _A_ or _B_ "
"is a function that pulls the evidence of _A_ (or of _B_) out of the evidence"
" for _A_ and _B_, and then uses this evidence to produce evidence of _A_ or "
"_B_:"
msgstr ""
"因为“与”的证据是一个构造器，所以它可以与模式匹配一起使用。例如，证明 _A_ 和 _B_ 蕴涵 _A_ 或 _B_ 的证明是一个函数，它从 _A_ 和"
" _B_ 的证据中提取 _A_（或 _B_）的证据，然后使用此证据来生成 _A_ 或 _B_ 的证据："

#: src/props-proofs-indexing.md:168
#, fuzzy
msgid "Connective"
msgstr "连接词"

#: src/props-proofs-indexing.md:168
#, fuzzy
msgid "Lean Syntax"
msgstr "Lean 语法"

#: src/props-proofs-indexing.md:168
#, fuzzy
msgid "Evidence"
msgstr "证据"

#: src/props-proofs-indexing.md:170
#, fuzzy
msgid "True"
msgstr "真"

#: src/props-proofs-indexing.md:170
#, fuzzy
msgid "`True`"
msgstr "`True`"

#: src/props-proofs-indexing.md:170
#, fuzzy
msgid "`True.intro : True`"
msgstr "`True.intro : True`"

#: src/props-proofs-indexing.md:171
#, fuzzy
msgid "False"
msgstr "假"

#: src/props-proofs-indexing.md:171
#, fuzzy
msgid "`False`"
msgstr "`False`"

#: src/props-proofs-indexing.md:171
#, fuzzy
msgid "No evidence"
msgstr "无证据"

#: src/props-proofs-indexing.md:172
#, fuzzy
msgid "_A_ and _B_"
msgstr "_A_ 与 _B_"

#: src/props-proofs-indexing.md:172
#, fuzzy
msgid "`A ∧ B`"
msgstr "`A ∧ B`"

#: src/props-proofs-indexing.md:172
#, fuzzy
msgid "`And.intro : A → B → A ∧ B`"
msgstr "`And.intro : A → B → A ∧ B`"

#: src/props-proofs-indexing.md:173
#, fuzzy
msgid "_A_ or _B_"
msgstr "_A_ 或 _B_"

#: src/props-proofs-indexing.md:173
#, fuzzy
msgid "`A ∨ B`"
msgstr "`A ∨ B`"

#: src/props-proofs-indexing.md:173
#, fuzzy
msgid "Either `Or.inl : A → A ∨ B` or `Or.inr : B → A ∨ B`"
msgstr "`Or.inl : A → A ∨ B` 或 `Or.inr : B → A ∨ B`"

#: src/props-proofs-indexing.md:174
#, fuzzy
msgid "_A_ implies _B_"
msgstr "_A_ 蕴含 _B_"

#: src/props-proofs-indexing.md:174
#, fuzzy
msgid "`A → B`"
msgstr "`A → B`"

#: src/props-proofs-indexing.md:174
#, fuzzy
msgid "A function that transforms evidence of _A_ into evidence of _B_"
msgstr "将 _A_ 的证据转换为 _B_ 证据的函数"

#: src/props-proofs-indexing.md:175
#, fuzzy
msgid "not _A_"
msgstr "非 _A_"

#: src/props-proofs-indexing.md:175
#, fuzzy
msgid "`¬A`"
msgstr "`¬A`"

#: src/props-proofs-indexing.md:175
#, fuzzy
msgid ""
"A function that would transform evidence of _A_ into evidence of `False`"
msgstr "将 _A_ 的证据转换为 `False` 证据的函数"

#: src/props-proofs-indexing.md:177
#, fuzzy
msgid ""
"The `simp` tactic can prove theorems that use these connectives. For "
"example:"
msgstr "`simp` 战术可以证明使用这些连接词的定理。例如："

#: src/props-proofs-indexing.md:187
#, fuzzy
msgid "Evidence as Arguments"
msgstr "证据作为参数"

#: src/props-proofs-indexing.md:189
#, fuzzy
msgid ""
"While `simp` does a great job proving propositions that involve equalities "
"and inequalities of specific numbers, it is not very good at proving "
"statements that involve variables. For instance, `simp` can prove that `4 < "
"15`, but it can't easily tell that because `x < 4`, it's also true that `x <"
" 15`. Because index notation uses `simp` behind the scenes to prove that "
"array access is safe, it can require a bit of hand-holding."
msgstr ""
"虽然 `simp` 在证明涉及特定数字的等式和不等式的命题时表现出色，但它在证明涉及变量的语句时效果不佳。例如，`simp` 可以证明 `4 < "
"15`，但它不能轻易地判断出因为 `x < 4`，所以 `x < 15` 也成立。由于索引表示法在幕后使用 `simp` "
"来证明数组访问是安全的，因此它可能需要一些人工干预。"

#: src/props-proofs-indexing.md:193
#, fuzzy
msgid ""
"One of the easiest ways to make indexing notation work well is to have the "
"function that performs a lookup into a data structure take the required "
"evidence of safety as an argument. For instance, a function that returns the"
" third entry in a list is not generally safe because lists might contain "
"zero, one, or two entries:"
msgstr ""
"索引符号要正常工作最简单的方法之一是让执行数据结构查找的函数将所需的安全性证据作为参数。例如，返回列表中第三个条目的函数通常不安全，因为列表可能包含零、一或两个条目："

#: src/props-proofs-indexing.md:208
#, fuzzy
msgid ""
"However, the obligation to show that the list has at least three entries can"
" be imposed on the caller by adding an argument that consists of evidence "
"that the indexing operation is safe:"
msgstr "然而，可以通过添加一个参数来强制调用者证明列表至少有三个条目，该参数包含索引操作安全的证据："

#: src/props-proofs-indexing.md:212
#, fuzzy
msgid ""
"In this example, `xs.length > 2` is not a program that checks _whether_ `xs`"
" has more than 2 entries. It is a proposition that could be true or false, "
"and the argument `ok` must be evidence that it is true."
msgstr ""
"在这个例子中，`xs.length > 2` 不是一个检查 `xs` 是否有 2 个以上条目的程序。它是一个可能是真或假的命题，参数 `ok` "
"必须是它为真的证据。"

#: src/props-proofs-indexing.md:215
#, fuzzy
msgid ""
"When the function is called on a concrete list, its length is known. In "
"these cases, `by simp` can construct the evidence automatically:"
msgstr "当函数被调用到一个具体列表上时，它的长度是已知的。在这些情况下，`by simp` 可以自动构造证据："

#: src/props-proofs-indexing.md:220
#, fuzzy
msgid ""
"```output info\n"
"\"snail\"\n"
"```"
msgstr ""
"```output info\n"
"\"snail\"\n"
"```"

#: src/props-proofs-indexing.md:224
#, fuzzy
msgid "Indexing Without Evidence"
msgstr "无证据索引"

#: src/props-proofs-indexing.md:226
#, fuzzy
msgid ""
"In cases where it's not practical to prove that an indexing operation is in "
"bounds, there are other alternatives. Adding a question mark results in an "
"`Option`, where the result is `some` if the index is in bounds, and `none` "
"otherwise. For example:"
msgstr ""
"在无法证明索引操作在边界内的情况下，还有其他选择。添加一个问号会产生一个 `Option`，如果索引在边界内，结果为 `some`，否则为 "
"`none`。例如："

#: src/props-proofs-indexing.md:234
#, fuzzy
msgid ""
"```output info\n"
"some \"snail\"\n"
"```"
msgstr ""
"```output info\n"
"some \"snail\"\n"
"```"

#: src/props-proofs-indexing.md:237
#, fuzzy
msgid ""
"```lean\n"
"#eval thirdOption [\"only\", \"two\"]\n"
"```"
msgstr ""
"```lean\n"
"#eval thirdOption [\"only\", \"two\"]\n"
"```"

#: src/props-proofs-indexing.md:244
#, fuzzy
msgid ""
"There is also a version that crashes the program when the index is out of "
"bounds, rather than returning an `Option`:"
msgstr "还有一个版本，当索引超出边界时会使程序崩溃，而不是返回一个 `Option`："

#: src/props-proofs-indexing.md:248
#, fuzzy
msgid ""
"```output info\n"
"\"deer\"\n"
"```"
msgstr ""
"```output info\n"
"\"deer\"\n"
"```"

#: src/props-proofs-indexing.md:251
#, fuzzy
msgid ""
"Be careful! Because code that is run with `#eval` runs in the context of the"
" Lean compiler, selecting the wrong index can crash your IDE."
msgstr "小心！因为使用 `#eval` 运行的代码在 Lean 编译器的上下文中运行，选择错误的索引可能会使你的 IDE 崩溃。"

#: src/props-proofs-indexing.md:256
#, fuzzy
msgid ""
"In addition to the error that occurs when Lean is unable to find compile-"
"time evidence that an indexing operation is safe, polymorphic functions that"
" use unsafe indexing may produce the following message:"
msgstr "除了 Lean 无法找到编译时证据来证明索引操作是安全的时发生的错误之外，使用不安全索引的多态函数可能会产生以下消息："

#: src/props-proofs-indexing.md:264
#, fuzzy
msgid ""
"This is due to a technical restriction that is part of keeping Lean usable "
"as both a logic for proving theorems and a programming language. In "
"particular, only programs whose types contain at least one value are allowed"
" to crash. This is because a proposition in Lean is a kind of type that "
"classifies evidence of its truth. False propositions have no such evidence. "
"If a program with an empty type could crash, then that crashing program "
"could be used as a kind of fake evidence for a false proposition."
msgstr ""
"这是由于技术限制，该限制是将 Lean 同时用作证明定理的逻辑和编程语言的一部分。特别是，只有类型中至少包含一个值的程序才允许崩溃。这是因为 Lean "
"中的命题是一种对真值证据进行分类的类型。假命题没有这样的证据。如果具有空类型的程序可能崩溃，那么该崩溃程序可以用作对假命题的一种伪证据。"

#: src/props-proofs-indexing.md:270
#, fuzzy
msgid ""
"Internally, Lean contains a table of types that are known to have at least "
"one value. This error is saying that some arbitrary type `α` is not "
"necessarily in that table. The next chapter describes how to add to this "
"table, and how to successfully write functions like `unsafeThird`."
msgstr ""
"在内部，Lean 包含一个已知至少有一个值的类型的表。此错误表明某个任意类型 `α` 不一定在该表中。下一章描述如何向此表添加内容，以及如何成功编写诸如"
" `unsafeThird` 之类的函数。"

#: src/props-proofs-indexing.md:274
#, fuzzy
msgid ""
"Adding whitespace between a list and the brackets used for lookup can cause "
"another message:"
msgstr "在列表和用于查找的括号之间添加空格会导致另一条消息："

#: src/props-proofs-indexing.md:284
#, fuzzy
msgid ""
"Adding a space causes Lean to treat the expression as a function "
"application, and the index as a list that contains a single number. This "
"error message results from having Lean attempt to treat `woodlandCritters` "
"as a function."
msgstr ""
"添加空格会导致 Lean 将表达式视为函数应用，并将索引视为包含单个数字的列表。此错误消息是由 Lean 尝试将 `woodlandCritters` "
"视为函数而产生的。"

#: src/props-proofs-indexing.md:289
#, fuzzy
msgid ""
"Prove the following theorems using `rfl`: `2 + 3 = 5`, `15 - 8 = 7`, "
"`\"Hello, \".append \"world\" = \"Hello, world\"`. What happens if `rfl` is "
"used to prove `5 < 18`? Why?"
msgstr ""
"使用 `rfl` 证明以下定理：`2 + 3 = 5`、`15 - 8 = 7`、`\"Hello, \".append \"world\" = "
"\"Hello, world\"`。如果使用 `rfl` 证明 `5 < 18` 会发生什么？为什么？"

#: src/props-proofs-indexing.md:290
#, fuzzy
msgid ""
"Prove the following theorems using `by simp`: `2 + 3 = 5`, `15 - 8 = 7`, "
"`\"Hello, \".append \"world\" = \"Hello, world\"`, `5 < 18`."
msgstr ""
"使用 `by simp` 证明以下定理：`2 + 3 = 5`、`15 - 8 = 7`、`\"Hello, \".append \"world\" ="
" \"Hello, world\"`、`5 < 18`。"

#: src/props-proofs-indexing.md:291
#, fuzzy
msgid ""
"Write a function that looks up the fifth entry in a list. Pass the evidence "
"that this lookup is safe as an argument to the function."
msgstr "编写一个函数，用于查找列表中的第五个条目。将此查找安全的证据作为参数传递给函数。"
