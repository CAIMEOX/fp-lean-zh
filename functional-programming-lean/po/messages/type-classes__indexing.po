#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/type-classes/indexing.md:3
#, fuzzy
msgid ""
"The [Interlude](../props-proofs-indexing.md) describes how to use indexing "
"notation in order to look up entries in a list by their position. This "
"syntax is also governed by a type class, and it can be used for a variety of"
" different types."
msgstr ""
"[插曲](../props-proofs-indexing.md) "
"描述了如何使用索引符号根据位置查找列表中的条目。此语法也受类型类的约束，并且可用于各种不同的类型。"

#: src/type-classes/indexing.md:6
#, fuzzy
msgid "Arrays"
msgstr "数组"

#: src/type-classes/indexing.md:7
#, fuzzy
msgid ""
"For instance, Lean arrays are much more efficient than linked lists for most"
" purposes. In Lean, the type `Array α` is a dynamically-sized array holding "
"values of type `α`, much like a Java `ArrayList`, a C++ `std::vector`, or a "
"Rust `Vec`. Unlike `List`, which has a pointer indirection on each use of "
"the `cons` constructor, arrays occupy a contiguous region of memory, which "
"is much better for processor caches. Also, looking up a value in an array "
"takes constant time, while lookup in a linked list takes time proportional "
"to the index being accessed."
msgstr ""
"例如，对于大多数目的，Lean 数组比链表的效率要高得多。在 Lean 中，类型 `Array α` 是一个动态大小的数组，它保存类型为 `α` "
"的值，很像 Java 中的 `ArrayList`、C++ 中的 `std::vector` 或 Rust 中的 `Vec`。与 `List` "
"不同，`List` 在每次使用 `cons` "
"构造函数时都有一个指针间接，而数组占据一个连续的内存区域，这对于处理器缓存来说要好得多。此外，在数组中查找一个值需要恒定时间，而在链表中查找则需要与被访问的索引成正比的时间。"

#: src/type-classes/indexing.md:12
#, fuzzy
msgid ""
"In pure functional languages like Lean, it is not possible to mutate a given"
" position in a data structure. Instead, a copy is made that has the desired "
"modifications. When using an array, the Lean compiler and runtime contain an"
" optimization that can allow modifications to be implemented as mutations "
"behind the scenes when there is only a single unique reference to an array."
msgstr ""
"在 Lean 这样的纯函数式语言中，不可能改变数据结构中的给定位置。相反，会创建一个具有所需修改的副本。在使用数组时，Lean "
"编译器和运行时包含一个优化，当数组只有一个唯一引用时，该优化可以允许将修改实现为幕后的变异。"

#: src/type-classes/indexing.md:16
#, fuzzy
msgid "Arrays are written similarly to lists, but with a leading `#`:"
msgstr "数组的编写方式与列表类似，但前面有一个 `#`："

#: src/type-classes/indexing.md:17
#, fuzzy
msgid ""
"```lean\n"
"def northernTrees : Array String :=\n"
"  #[\"sloe\", \"birch\", \"elm\", \"oak\"]\n"
"```"
msgstr ""
"```lean\n"
"def northernTrees : Array String :=\n"
"  #[\"sloe\", \"birch\", \"elm\", \"oak\"]\n"
"```"

#: src/type-classes/indexing.md:21
#, fuzzy
msgid ""
"The number of values in an array can be found using `Array.size`. For "
"instance, `northernTrees.size` evaluates to `4`. For indices that are "
"smaller than an array's size, indexing notation can be used to find the "
"corresponding value, just as with lists. That is, `northernTrees[2]` "
"evaluates to `\"elm\"`. Similarly, the compiler requires a proof that an "
"index is in bounds, and attempting to look up a value outside the bounds of "
"the array results in a compile-time error, just as with lists. For instance,"
" `northernTrees[8]` results in:"
msgstr ""
"数组中值的个数可以通过 `Array.size` 找到。例如，`northernTrees.size` 计算结果为 "
"`4`。对于小于数组大小的索引，可以使用索引符号来查找相应的值，就像列表一样。也就是说，`northernTrees[2]` 计算结果为 "
"`\"elm\"`。同样，编译器需要一个证明，即索引在范围内，并且尝试查找数组范围之外的值会导致编译时错误，就像列表一样。例如，`northernTrees[8]`"
" 的结果是："

#: src/type-classes/indexing.md:36
#, fuzzy
msgid "Non-Empty Lists"
msgstr "非空列表"

#: src/type-classes/indexing.md:38
#, fuzzy
msgid ""
"A datatype that represents non-empty lists can be defined as a structure "
"with a field for the head of the list and a field for the tail, which is an "
"ordinary, potentially empty list:"
msgstr "可以将表示非空列表的数据类型定义为一个结构，其中有一个字段表示列表的头部，另一个字段表示尾部，它是一个普通的、可能为空的列表："

#: src/type-classes/indexing.md:44
#, fuzzy
msgid ""
"For example, the non-empty list `idahoSpiders` (which contains some spider "
"species native to the US state of Idaho) consists of `\"Banded Garden "
"Spider\"` followed by four other spiders, for a total of five spiders:"
msgstr ""
"例如，非空列表 `idahoSpiders`（其中包含一些原产于美国爱达荷州的蜘蛛物种）由 `\"Banded Garden Spider\"` "
"后跟其他四种蜘蛛组成，总共五种蜘蛛："

#: src/type-classes/indexing.md:45
#, fuzzy
msgid ""
"```lean\n"
"def idahoSpiders : NonEmptyList String := {\n"
"  head := \"Banded Garden Spider\",\n"
"  tail := [\n"
"    \"Long-legged Sac Spider\",\n"
"    \"Wolf Spider\",\n"
"    \"Hobo Spider\",\n"
"    \"Cat-faced Spider\"\n"
"  ]\n"
"}\n"
"```"
msgstr ""
"```lean\n"
"def idahoSpiders : NonEmptyList String := {\n"
"  head := \"Banded Garden Spider\",\n"
"  tail := [\n"
"    \"Long-legged Sac Spider\",\n"
"    \"Wolf Spider\",\n"
"    \"Hobo Spider\",\n"
"    \"Cat-faced Spider\"\n"
"  ]\n"
"}\n"
"```"

#: src/type-classes/indexing.md:57
#, fuzzy
msgid ""
"Looking up the value at a specific index in this list with a recursive "
"function should consider three possibilities:"
msgstr "使用递归函数查找此列表中特定索引处的值时，应考虑三种可能性："

#: src/type-classes/indexing.md:58
#, fuzzy
msgid ""
"The index is `0`, in which case the head of the list should be returned."
msgstr "索引为 `0`，在这种情况下应返回列表的头部。"

#: src/type-classes/indexing.md:59
#, fuzzy
msgid ""
"The index is `n + 1` and the tail is empty, in which case the index is out "
"of bounds."
msgstr "索引为 `n + 1` 且尾部为空，在这种情况下索引超出范围。"

#: src/type-classes/indexing.md:60
#, fuzzy
msgid ""
"The index is `n + 1` and the tail is non-empty, in which case the function "
"can be called recursively on the tail and `n`."
msgstr "索引为 `n + 1` 且尾部非空，在这种情况下可以在尾部和 `n` 上递归调用该函数。"

#: src/type-classes/indexing.md:62
#, fuzzy
msgid ""
"For example, a lookup function that returns an `Option` can be written as "
"follows:"
msgstr "例如，一个返回 `Option` 的查找函数可以写成如下形式："

#: src/type-classes/indexing.md:69
#, fuzzy
msgid ""
"Each case in the pattern match corresponds to one of the possibilities "
"above. The recursive call to `get?` does not require a `NonEmptyList` "
"namespace qualifier because the body of the definition is implicitly in the "
"definition's namespace. Another way to write this function uses `get?` for "
"lists when the index is greater than zero:"
msgstr ""
"模式匹配中的每个 case 对应于上述的一种可能性。对 `get?` 的递归调用不需要 `NonEmptyList` "
"命名空间限定符，因为定义的主体隐式地位于定义的命名空间中。另一种编写此函数的方法是当索引大于零时对列表使用 `get?`："

#: src/type-classes/indexing.md:78
#, fuzzy
msgid ""
"If the list contains one entry, then only `0` is a valid index. If it "
"contains two entries, then both `0` and `1` are valid indices. If it "
"contains three entries, then `0`, `1`, and `2` are valid indices. In other "
"words, the valid indices into a non-empty list are natural numbers that are "
"strictly less than the length of the list, which are less than or equal to "
"the length of the tail."
msgstr ""
"如果列表包含一个条目，则只有 `0` 是有效的索引。如果它包含两个条目，则 `0` 和 `1` 都是有效的索引。如果它包含三个条目，则 `0`、`1` "
"和 `2` 是有效的索引。换句话说，非空列表中的有效索引是严格小于列表长度的自然数，它们小于或等于尾部的长度。"

#: src/type-classes/indexing.md:83
#, fuzzy
msgid ""
"The definition of what it means for an index to be in bounds should be "
"written as an `abbrev` because the tactics used to find evidence that "
"indices are acceptable are able to solve inequalities of numbers, but they "
"don't know anything about the name `NonEmptyList.inBounds`:"
msgstr ""
"对于索引处于界内意味着什么的定义应该写成一个 `abbrev`，因为用于查找索引是否可接受的证据的策略能够解决数字的不等式，但它们对名称 "
"`NonEmptyList.inBounds` 一无所知："

#: src/type-classes/indexing.md:88
#, fuzzy
msgid ""
"This function returns a proposition that might be true or false. For "
"instance, `2` is in bounds for `idahoSpiders`, while `5` is not:"
msgstr "此函数返回一个可能是真或假的命题。例如，`2` 对于 `idahoSpiders` 处于界内，而 `5` 则不处于界内："

#: src/type-classes/indexing.md:95
#, fuzzy
msgid ""
"The logical negation operator has a very low precedence, which means that "
"`¬idahoSpiders.inBounds 5` is equivalent to `¬(idahoSpiders.inBounds 5)`."
msgstr ""
"逻辑否定运算符的优先级非常低，这意味着 `¬idahoSpiders.inBounds 5` 等价于 `¬(idahoSpiders.inBounds "
"5)`。"

#: src/type-classes/indexing.md:98
#, fuzzy
msgid ""
"This fact can be used to write a lookup function that requires evidence that"
" the index is valid, and thus need not return `Option`, by delegating to the"
" version for lists that checks the evidence at compile time:"
msgstr "此事实可用于编写一个查找函数，该函数需要证据证明索引有效，因此不必返回 `Option`，方法是委托给在编译时检查证据的列表版本："

#: src/type-classes/indexing.md:105
#, fuzzy
msgid ""
"It is, of course, possible to write this function to use the evidence "
"directly, rather than delegating to a standard library function that happens"
" to be able to use the same evidence. This requires techniques for working "
"with proofs and propositions that are described later in this book."
msgstr "当然，也可以直接使用证据来编写此函数，而不是委托给碰巧能够使用相同证据的标准库函数。这需要使用本书后面描述的处理证明和命题的技术。"

#: src/type-classes/indexing.md:109
#, fuzzy
msgid "Overloading Indexing"
msgstr "重载索引"

#: src/type-classes/indexing.md:111
#, fuzzy
msgid ""
"Indexing notation for a collection type can be overloaded by defining an "
"instance of the `GetElem` type class. For the sake of flexiblity, `GetElem` "
"has four parameters:"
msgstr "可以通过定义`GetElem`类型类的实例来重载集合类型的索引表示法。为了灵活性，`GetElem`有四个参数："

#: src/type-classes/indexing.md:113
#, fuzzy
msgid "The type of the collection"
msgstr "集合的类型"

#: src/type-classes/indexing.md:114
#, fuzzy
msgid "The type of the index"
msgstr "索引的类型"

#: src/type-classes/indexing.md:115
#, fuzzy
msgid "The type of elements that are extracted from the collection"
msgstr "从集合中提取的元素的类型"

#: src/type-classes/indexing.md:116
#, fuzzy
msgid ""
"A function that determines what counts as evidence that the index is in "
"bounds"
msgstr "一个函数，用于确定索引在边界内的证据"

#: src/type-classes/indexing.md:118
#, fuzzy
msgid ""
"The element type and the evidence function are both output parameters. "
"`GetElem` has a single method, `getElem`, which takes a collection value, an"
" index value, and evidence that the index is in bounds as arguments, and "
"returns an element:"
msgstr ""
"元素类型和证据函数都是输出参数。`GetElem`有一个方法`getElem`，它以集合值、索引值和索引在边界内的证据作为参数，并返回一个元素："

#: src/type-classes/indexing.md:125
#, fuzzy
msgid "In the case of `NonEmptyList α`, these parameters are:"
msgstr "对于`NonEmptyList α`，这些参数是："

#: src/type-classes/indexing.md:126
#, fuzzy
msgid "The collection is `NonEmptyList α`"
msgstr "集合是`NonEmptyList α`"

#: src/type-classes/indexing.md:127
#, fuzzy
msgid "Indices have type `Nat`"
msgstr "索引的类型是`Nat`"

#: src/type-classes/indexing.md:128
#, fuzzy
msgid "The type of elements is `α`"
msgstr "元素的类型是`α`"

#: src/type-classes/indexing.md:129
#, fuzzy
msgid ""
"An index is in bounds if it is less than or equal to the length of the tail"
msgstr "如果索引小于或等于尾部的长度，则索引在边界内"

#: src/type-classes/indexing.md:131
#, fuzzy
msgid ""
"In fact, the `GetElem` instance can delegate directly to `NonEmptyList.get`:"
msgstr "事实上，`GetElem`实例可以直接委托给`NonEmptyList.get`："

#: src/type-classes/indexing.md:136
#, fuzzy
msgid ""
"With this instance, `NonEmptyList` becomes just as convenient to use as "
"`List`. Evaluating `idahoSpiders[0]` yields `\"Banded Garden Spider\"`, "
"while `idahoSpiders[9]` leads to the compile-time error:"
msgstr ""
"有了这个实例，`NonEmptyList`的使用就和`List`一样方便了。求值`idahoSpiders[0]`得到`\"Banded Garden "
"Spider\"，而`idahoSpiders[9]`导致编译时错误："

#: src/type-classes/indexing.md:147
#, fuzzy
msgid ""
"Because both the collection type and the index type are input parameters to "
"the `GetElem` type class, new types can be used to index into existing "
"collections. The positive number type `Pos` is a perfectly reasonable index "
"into a `List`, with the caveat that it cannot point at the first entry. The "
"follow instance of `GetElem` allows `Pos` to be used just as conveniently as"
" `Nat` to find a list entry:"
msgstr ""
"因为集合类型和索引类型都是`GetElem`类型类的输入参数，所以可以使用新类型来索引现有集合。正数类型`Pos`是`List`中一个非常合理的索引，但它不能指向第一个条目。`GetElem`的以下实例允许`Pos`像`Nat`一样方便地用于查找列表条目："

#: src/type-classes/indexing.md:155
#, fuzzy
msgid ""
"Indexing can also make sense for non-numeric indices. For example, `Bool` "
"can be used to select between the fields in a point, with `false` "
"corresponding to `x` and `true` corresponding to `y`:"
msgstr "索引也可以用于非数字索引。例如，`Bool` 可用于选择点中的字段，其中 `false` 对应于 `x`，`true` 对应于 `y`："

#: src/type-classes/indexing.md:162
#, fuzzy
msgid ""
"In this case, both Booleans are valid indices. Because every possible `Bool`"
" is in bounds, the evidence is simply the true proposition `True`."
msgstr "在这种情况下，两个布尔值都是有效的索引。因为每个可能的 `Bool` 都在范围内，所以证据只是真命题 `True`。"
