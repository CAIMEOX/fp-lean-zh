#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/type-classes/out-params.md:3
#, fuzzy
msgid ""
"An instance of the `Add` class is sufficient to allow two expressions with "
"type `Pos` to be conveniently added, producing another `Pos`. However, in "
"many cases, it can be useful to be more flexible and allow _heterogeneous_ "
"operator overloading, where the arguments may have different types. For "
"example, adding a `Nat` to a `Pos` or a `Pos` to a `Nat` will always yield a"
" `Pos`:"
msgstr ""
"`Add` 类的实例足以允许两个类型为 `Pos` 的表达式方便地相加，生成另一个 "
"`Pos`。然而，在许多情况下，更灵活并允许异构运算符重载可能很有用，其中参数可以具有不同的类型。例如，将 `Nat` 添加到 `Pos` 或将 "
"`Pos` 添加到 `Nat` 总是会产生 `Pos`："

#: src/type-classes/out-params.md:15
#, fuzzy
msgid ""
"These functions allow natural numbers to be added to positive numbers, but "
"they cannot be used with the `Add` type class, which expects both arguments "
"to `add` to have the same type."
msgstr "这些函数允许将自然数添加到正数，但不能与 `Add` 类型类一起使用，后者期望 `add` 的两个参数具有相同的类型。"

#: src/type-classes/out-params.md:17
#, fuzzy
msgid "Heterogeneous Overloadings"
msgstr "异构重载"

#: src/type-classes/out-params.md:19
#, fuzzy
msgid ""
"As mentioned in the section on [overloaded addition](pos.md#overloaded-"
"addition), Lean provides a type class called `HAdd` for overloading addition"
" heterogeneously. The `HAdd` class takes three type parameters: the two "
"argument types and the return type. Instances of `HAdd Nat Pos Pos` and "
"`HAdd Pos Nat Pos` allow ordinary addition notation to be used to mix the "
"types:"
msgstr ""
"正如 [重载加法](pos.md#overloaded-addition) 部分所述，Lean 提供了一个名为 `HAdd` "
"的类型类，用于异构地重载加法。`HAdd` 类采用三个类型参数：两个参数类型和返回类型。`HAdd Nat Pos Pos` 和 `HAdd Pos "
"Nat Pos` 的实例允许使用普通加法符号来混合类型："

#: src/type-classes/out-params.md:29
#, fuzzy
msgid "Given the above two instances, the following examples work:"
msgstr "给定以上两个实例，以下示例有效："

#: src/type-classes/out-params.md:43
#, fuzzy
msgid ""
"The definition of the `HAdd` type class is very much like the following "
"definition of `HPlus` with the corresponding instances:"
msgstr "`HAdd` 类型类的定义非常类似于以下带有相应实例的 `HPlus` 定义："

#: src/type-classes/out-params.md:54
#, fuzzy
msgid ""
"However, instances of `HPlus` are significantly less useful than instances "
"of `HAdd`. When attempting to use these instances with `#eval`, an error "
"occurs:"
msgstr "然而，`HPlus` 的实例远不如 `HAdd` 的实例有用。当尝试使用这些实例与 `#eval` 时，会发生错误："

#: src/type-classes/out-params.md:63
#, fuzzy
msgid ""
"This happens because there is a metavariable in the type, and Lean has no "
"way to solve it."
msgstr "这发生在类型中存在元变量时，而 Lean 无法解决它。"

#: src/type-classes/out-params.md:65
#, fuzzy
msgid ""
"As discussed in [the initial description of polymorphism](../getting-to-"
"know/polymorphism.md), metavariables represent unknown parts of a program "
"that could not be inferred. When an expression is written following `#eval`,"
" Lean attempts to determine its type automatically. In this case, it could "
"not. Because the third type parameter for `HPlus` was unknown, Lean couldn't"
" carry out type class instance search, but instance search is the only way "
"that Lean could determine the expression's type. That is, the `HPlus Pos Nat"
" Pos` instance can only apply if the expression should have type `Pos`, but "
"there's nothing in the program other than the instance itself to indicate "
"that it should have this type."
msgstr ""
"如 [多态性的初始描述](../getting-to-know/polymorphism.md) 中所述，元变量表示程序中无法推断的未知部分。当在 "
"`#eval` 后面写一个表达式时，Lean 会尝试自动确定其类型。在这种情况下，它无法确定。由于 `HPlus` 的第三个类型参数未知，Lean "
"无法执行类型类实例搜索，但实例搜索是 Lean 确定表达式类型的唯一方法。也就是说，`HPlus Pos Nat Pos` 实例只能在表达式应具有 "
"`Pos` 类型时应用，但程序中除了实例本身之外没有任何内容表明它应该具有此类型。"

#: src/type-classes/out-params.md:71
#, fuzzy
msgid ""
"One solution to the problem is to ensure that all three types are available "
"by adding a type annotation to the whole expression:"
msgstr "解决此问题的一种方法是通过向整个表达式添加类型注释来确保所有三个类型都可用："

#: src/type-classes/out-params.md:78
#, fuzzy
msgid ""
"However, this solution is not very convenient for users of the positive "
"number library."
msgstr "但是，对于正数库的用户来说，此解决方案不是很方便。"

#: src/type-classes/out-params.md:81
#, fuzzy
msgid "Output Parameters"
msgstr "输出参数"

#: src/type-classes/out-params.md:83
#, fuzzy
msgid ""
"This problem can also be solved by declaring `γ` to be an _output "
"parameter_. Most type class parameters are inputs to the search algorithm: "
"they are used to select an instance. For example, in an `OfNat` instance, "
"both the type and the natural number are used to select a particular "
"interpretation of a natural number literal. However, in some cases, it can "
"be convenient to start the search process even when some of the type "
"parameters are not yet known, and use the instances that are discovered in "
"the search to determine values for metavariables. The parameters that aren't"
" needed to start instance search are outputs of the process, which is "
"declared with the `outParam` modifier:"
msgstr ""
"还可以通过将 `γ` 声明为 _输出参数_ 来解决此问题。大多数类型类参数是搜索算法的输入：它们用于选择实例。例如，在 `OfNat` "
"实例中，类型和自然数都用于选择自然数文字的特定解释。然而，在某些情况下，即使某些类型参数尚未知道，也可以开始搜索过程，并使用在搜索中发现的实例来确定元变量的值。不需要开始实例搜索的参数是该过程的输出，该过程使用"
" `outParam` 修饰符声明："

#: src/type-classes/out-params.md:93
#, fuzzy
msgid ""
"With this output parameter, type class instance search is able to select an "
"instance without knowing `γ` in advance. For instance:"
msgstr "通过输出参数，类型类实例搜索能够在不提前知道 `γ` 的情况下选择一个实例。例如："

#: src/type-classes/out-params.md:102
#, fuzzy
msgid ""
"It might be helpful to think of output parameters as defining a kind of "
"function. Any given instance of a type class that has one or more output "
"parameters provides Lean with instructions for determining the outputs from "
"the inputs. The process of searching for an instance, possibly recursively, "
"ends up being more powerful than mere overloading. Output parameters can "
"determine other types in the program, and instance search can assemble a "
"collection of underlying instances into a program that has this type."
msgstr ""
"将输出参数视为定义一种函数可能会有所帮助。任何具有一个或多个输出参数的类型类的给定实例都为 Lean "
"提供了确定从输入到输出的说明。搜索实例的过程（可能递归）最终比单纯的重载更强大。输出参数可以确定程序中的其他类型，并且实例搜索可以将底层实例集合组装成具有此类型的程序。"

#: src/type-classes/out-params.md:107
#, fuzzy
msgid "Default Instances"
msgstr "默认实例"

#: src/type-classes/out-params.md:109
#, fuzzy
msgid ""
"Deciding whether a parameter is an input or an output controls the "
"circumstances under which Lean will initiate type class search. In "
"particular, type class search does not occur until all inputs are known. "
"However, in some cases, output parameters are not enough, and instance "
"search should also occur when some inputs are unknown. This is a bit like "
"default values for optional function arguments in Python or Kotlin, except "
"default _types_ are being selected."
msgstr ""
"决定一个参数是输入还是输出控制了 Lean "
"将启动类型类搜索的情况。特别是，在所有输入都已知之前，不会发生类型类搜索。但是，在某些情况下，输出参数还不够，并且在某些输入未知时也应该进行实例搜索。这有点像"
" Python 或 Kotlin 中可选函数参数的默认值，除了正在选择默认 _类型_。"

#: src/type-classes/out-params.md:114
#, fuzzy
msgid ""
"_Default instances_ are instances that are available for instance search "
"_even when not all their inputs are known_. When one of these instances can "
"be used, it will be used. This can cause programs to successfully type "
"check, rather than failing with errors related to unknown types and "
"metavariables. On the other hand, default instances can make instance "
"selection less predictable. In particular, if an undesired default instance "
"is selected, then an expression may have a different type than expected, "
"which can cause confusing type errors to occur elsewhere in the program. Be "
"selective about where default instances are used!"
msgstr ""
"_默认实例_ "
"是可用于实例搜索的实例，_即使并非其所有输入都已知_。当可以使用其中一个实例时，将使用它。这会导致程序成功类型检查，而不是因与未知类型和元变量相关的错误而失败。另一方面，默认实例会使实例选择变得不那么可预测。特别是，如果选择了不需要的默认实例，那么表达式的类型可能与预期不同，这会导致程序中其他位置出现令人困惑的类型错误。要谨慎选择使用默认实例的位置！"

#: src/type-classes/out-params.md:121
#, fuzzy
msgid ""
"One example of where default instances can be useful is an instance of "
"`HPlus` that can be derived from an `Add` instance. In other words, ordinary"
" addition is a special case of heterogeneous addition in which all three "
"types happen to be the same. This can be implemented using the following "
"instance:"
msgstr ""
"一个默认实例有用的例子是，可以从 `Add` 实例派生的 `HPlus` "
"实例。换句话说，普通加法是异构加法的一个特例，其中所有三种类型恰好相同。这可以使用以下实例实现："

#: src/type-classes/out-params.md:128
#, fuzzy
msgid ""
"With this instance, `hPlus` can be used for any addable type, like `Nat`:"
msgstr "有了这个实例，`hPlus` 可以用于任何可加类型，例如 `Nat`："

#: src/type-classes/out-params.md:136
#, fuzzy
msgid ""
"However, this instance will only be used in situations where the types of "
"both arguments are known. For example,"
msgstr "然而，此实例仅在已知两个参数的类型的情况下使用。例如，"

#: src/type-classes/out-params.md:141
#, fuzzy
msgid "yields the type"
msgstr "产生类型"

#: src/type-classes/out-params.md:145
#, fuzzy
msgid "as expected, but"
msgstr "如预期的那样，但"

#: src/type-classes/out-params.md:149
#, fuzzy
msgid ""
"yields a type that contains two metavariables, one for the remaining "
"argument and one for the return type:"
msgstr "产生一个包含两个元变量的类型，一个用于剩余参数，一个用于返回类型："

#: src/type-classes/out-params.md:154
#, fuzzy
msgid ""
"In the vast majority of cases, when someone supplies one argument to "
"addition, the other argument will have the same type. To make this instance "
"into a default instance, apply the `default_instance` attribute:"
msgstr ""
"在绝大多数情况下，当有人向加法提供一个参数时，另一个参数将具有相同的类型。要将此实例变成默认实例，请应用 `default_instance` 属性："

#: src/type-classes/out-params.md:161
#, fuzzy
msgid "With this default instance, the example has a more useful type:"
msgstr "有了这个默认实例，示例具有更有用的类型："

#: src/type-classes/out-params.md:170
#, fuzzy
msgid ""
"Each operator that exists in overloadable heterogeneous and homogeneous "
"versions follows the pattern of a default instance that allows the "
"homogeneous version to be used in contexts where the heterogeneous is "
"expected. The infix operator is replaced with a call to the heterogeneous "
"version, and the homogeneous default instance is selected when possible."
msgstr ""
"每个在可重载异构和同构版本中存在的运算符都遵循默认实例的模式，允许在预期异构的情况下使用同构版本。中缀运算符被替换为对异构版本的调用，并在可能的情况下选择同构默认实例。"

#: src/type-classes/out-params.md:173
#, fuzzy
msgid ""
"Similarly, simply writing `5` gives a `Nat` rather than a type with a "
"metavariable that is waiting for more information in order to select an "
"`OfNat` instance. This is because the `OfNat` instance for `Nat` is a "
"default instance."
msgstr ""
"类似地，简单地写 `5` 会给出一个 `Nat`，而不是一个带有元变量的类型，等待更多信息以选择一个 `OfNat` 实例。这是因为 `Nat` 的 "
"`OfNat` 实例是一个默认实例。"

#: src/type-classes/out-params.md:176
#, fuzzy
msgid ""
"Default instances can also be assigned _priorities_ that affect which will "
"be chosen in situations where more than one might apply. For more "
"information on default instance priorities, please consult the Lean manual."
msgstr "默认实例还可以分配 _优先级_，这会影响在可能应用多个实例的情况下选择哪个实例。有关默认实例优先级的更多信息，请查阅 Lean 手册。"

#: src/type-classes/out-params.md:182
#, fuzzy
msgid ""
"Define an instance of `HMul (PPoint α) α (PPoint α)` that multiplies both "
"projections by the scalar. It should work for any type `α` for which there "
"is a `Mul α` instance. For example,"
msgstr ""
"定义 `HMul (PPoint α) α (PPoint α)` 的一个实例，将两个投影乘以标量。它应该适用于任何具有 `Mul α` 实例的类型 "
"`α`。例如，"
