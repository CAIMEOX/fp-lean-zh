#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/dependent-types/universe-pattern.md:3
#, fuzzy
msgid ""
"In Lean, types such as `Type`, `Type 3`, and `Prop` that classify other "
"types are known as universes. However, the term _universe_ is also used for "
"a design pattern in which a datatype is used to represent a subset of Lean's"
" types, and a function converts the datatype's constructors into actual "
"types. The values of this datatype are called _codes_ for their types."
msgstr ""
"在 Lean 中，将其他类型分类的类型（如 `Type`、`Type 3` 和 "
"`Prop`）称为宇宙。然而，术语“宇宙”也用于设计模式，其中数据类型用于表示 Lean "
"类型的一个子集，并且一个函数将数据类型的构造函数转换为实际类型。该数据类型的值称为其类型的“代码”。"

#: src/dependent-types/universe-pattern.md:7
#, fuzzy
msgid ""
"Just like Lean's built-in universes, the universes implemented with this "
"pattern are types that describe some collection of available types, even "
"though the mechanism by which it is done is different. In Lean, there are "
"types such as `Type`, `Type 3`, and `Prop` that directly describe other "
"types. This arrangement is referred to as _universes à la Russell_. The "
"user-defined universes described in this section represent all of their "
"types as _data_, and include an explicit function to interpret these codes "
"into actual honest-to-goodness types. This arrangement is referred to as "
"_universes à la Tarski_. While languages such as Lean that are based on "
"dependent type theory almost always use Russell-style universes, Tarski-"
"style universes are a useful pattern for defining APIs in these languages."
msgstr ""
"就像 Lean 的内置宇宙一样，使用此模式实现的宇宙是描述一些可用类型集合的类型，即使完成此操作的机制不同。在 Lean "
"中，有直接描述其他类型的类型，如 `Type`、`Type 3` 和 "
"`Prop`。这种安排被称为“罗素式宇宙”。本节中描述的用户定义宇宙将其所有类型表示为“数据”，并包含一个显式函数，将这些代码解释为实际的、诚实可靠的类型。这种安排被称为“塔斯基式宇宙”。虽然基于依值类型论的语言（如"
" Lean）几乎总是使用罗素式宇宙，但塔斯基式宇宙是为这些语言中的 API 定义提供帮助的一种有用模式。"

#: src/dependent-types/universe-pattern.md:14
#, fuzzy
msgid ""
"Defining a custom universe makes it possible to carve out a closed "
"collection of types that can be used with an API. Because the collection of "
"types is closed, recursion over the codes allows programs to work for _any_ "
"type in the universe. One example of a custom universe has the codes `nat`, "
"standing for `Nat`, and `bool`, standing for `Bool`:"
msgstr ""
"自定义宇宙可以划分出封闭的类型集合，该集合可与 API 一起使用。由于类型集合是封闭的，因此对代码的递归允许程序适用于宇宙中的 _任何_ "
"类型。自定义宇宙的一个示例具有代码 `nat`（代表 `Nat`）和 `bool`（代表 `Bool`）："

#: src/dependent-types/universe-pattern.md:26
#, fuzzy
msgid ""
"Pattern matching on a code allows the type to be refined, just as pattern "
"matching on the constructors of `Vect` allows the expected length to be "
"refined. For instance, a program that deserializes the types in this "
"universe from a string can be written as follows:"
msgstr ""
"对代码进行模式匹配可以优化类型，就像对 `Vect` "
"构造函数进行模式匹配可以优化预期长度一样。例如，可以编写一个从字符串反序列化此宇宙中类型的程序，如下所示："

#: src/dependent-types/universe-pattern.md:28
msgid ""
"```lean\n"
"def decode (t : NatOrBool) (input : String) : Option t.asType :=\n"
"  match t with\n"
"  | .nat => input.toNat?\n"
"  | .bool =>\n"
"    match input with\n"
"    | \"true\" => some true\n"
"    | \"false\" => some false\n"
"    | _ => none\n"
"```"
msgstr ""

#: src/dependent-types/universe-pattern.md:38
#, fuzzy
msgid ""
"Dependent pattern matching on `t` allows the expected result type `t.asType`"
" to be respectively refined to `NatOrBool.nat.asType` and "
"`NatOrBool.bool.asType`, and these compute to the actual types `Nat` and "
"`Bool`."
msgstr ""
"对 `t` 进行依赖模式匹配可以分别将预期结果类型 `t.asType` 优化为 `NatOrBool.nat.asType` 和 "
"`NatOrBool.bool.asType`，它们计算为实际类型 `Nat` 和 `Bool`。"

#: src/dependent-types/universe-pattern.md:40
#, fuzzy
msgid ""
"Like any other data, codes may be recursive. The type `NestedPairs` codes "
"for any possible nesting of the pair and natural number types:"
msgstr "与任何其他数据一样，代码可以是递归的。`NestedPairs` 类型为对和自然数类型的任何可能嵌套进行编码："

#: src/dependent-types/universe-pattern.md:51
#, fuzzy
msgid ""
"In this case, the interpretation function `NestedPairs.asType` is recursive."
" This means that recursion over codes is required in order to implement "
"`BEq` for the universe:"
msgstr "在这种情况下，解释函数 `NestedPairs.asType` 是递归的。这意味着为了实现宇宙的 `BEq`，需要对代码进行递归："

#: src/dependent-types/universe-pattern.md:63
#, fuzzy
msgid ""
"Even though every type in the `NestedPairs` universe already has a `BEq` "
"instance, type class search does not automatically check every possible case"
" of a datatype in an instance declaration, because there might be infinitely"
" many such cases, as with `NestedPairs`. Attempting to appeal directly to "
"the `BEq` instances rather than explaining to Lean how to find them by "
"recursion on the codes results in an error:"
msgstr ""
"尽管 `NestedPairs` 宇宙中的每种类型都已具有 `BEq` "
"实例，但类型类搜索不会在实例声明中自动检查数据类型的每种可能情况，因为可能存在无限多个此类情况，如 `NestedPairs`。尝试直接调用 `BEq`"
" 实例，而不是向 Lean 解释如何通过对代码进行递归来查找它们，会导致错误："

#: src/dependent-types/universe-pattern.md:73
#, fuzzy
msgid ""
"The `t` in the error message stands for an unknown value of type "
"`NestedPairs`."
msgstr "错误消息中的 `t` 表示 `NestedPairs` 类型的未知值。"

#: src/dependent-types/universe-pattern.md:75
#, fuzzy
msgid "Type Classes vs Universes"
msgstr "类型类与宇宙"

#: src/dependent-types/universe-pattern.md:77
#, fuzzy
msgid ""
"Type classes allow an open-ended collection of types to be used with an API "
"as long as they have implementations of the necessary interfaces. In most "
"cases, this is preferable. It is hard to predict all use cases for an API "
"ahead of time, and type classes are a convenient way to allow library code "
"to be used with more types than the original author expected."
msgstr ""
"类型类允许一组开放的类型与 API 一起使用，只要它们实现了必要的接口。在大多数情况下，这是可取的。很难提前预测 API "
"的所有用例，而类型类是一种方便的方法，允许库代码与比原始作者预期的更多类型一起使用。"

#: src/dependent-types/universe-pattern.md:81
#, fuzzy
msgid ""
"A universe à la Tarski, on the other hand, restricts the API to be usable "
"only with a predetermined collection of types. This is useful in a few "
"situations:"
msgstr "另一方面，塔斯基式的宇宙将 API 限制为仅可与预先确定的类型集合一起使用。这在以下几种情况下很有用："

#: src/dependent-types/universe-pattern.md:83
#, fuzzy
msgid ""
"When a function should act very differently depending on which type it is "
"passed—it is impossible to pattern match on types themselves, but pattern "
"matching on codes for types is allowed"
msgstr "当一个函数应该根据传递给它的类型而表现得非常不同时——不可能对类型本身进行模式匹配，但允许对类型的代码进行模式匹配"

#: src/dependent-types/universe-pattern.md:84
#, fuzzy
msgid ""
"When an external system inherently limits the types of data that may be "
"provided, and extra flexibility is not desired"
msgstr "当外部系统本质上限制了可以提供的数据类型，并且不需要额外的灵活性时"

#: src/dependent-types/universe-pattern.md:85
#, fuzzy
msgid ""
"When additional properties of a type are required over and above the "
"implementation of some operations"
msgstr "当除了某些操作的实现之外，还需要类型的附加属性时"

#: src/dependent-types/universe-pattern.md:87
#, fuzzy
msgid ""
"Type classes are useful in many of the same situations as interfaces in Java"
" or C#, while a universe à la Tarski can be useful in cases where a sealed "
"class might be used, but where an ordinary inductive datatype is not usable."
msgstr "类型类在许多情况下与 Java 或 C# 中的接口类似，而塔斯基式的宇宙可以在可以使用密封类但无法使用普通归纳数据类型的情况下使用。"

#: src/dependent-types/universe-pattern.md:89
#, fuzzy
msgid "A Universe of Finite Types"
msgstr "有限类型宇宙"

#: src/dependent-types/universe-pattern.md:91
#, fuzzy
msgid ""
"Restricting the types that can be used with an API to a predetermined "
"collection can enable operations that would be impossible for an open-ended "
"API. For example, functions can't normally be compared for equality. "
"Functions should be considered equal when they map the same inputs to the "
"same outputs. Checking this could take infinite amounts of time, because "
"comparing two functions with type `Nat → Bool` would require checking that "
"the functions returned the same `Bool` for each and every `Nat`."
msgstr ""
"将可与 API 一起使用的类型限制为预先确定的集合可以启用对开放式 API "
"来说不可能的操作。例如，通常无法比较函数的相等性。当函数将相同的输入映射到相同的输出时，应将它们视为相等的。检查这可能需要无限量的时间，因为比较两个类型为"
" `Nat → Bool` 的函数需要检查这些函数为每个 `Nat` 返回相同的 `Bool`。"

#: src/dependent-types/universe-pattern.md:96
#, fuzzy
msgid ""
"In other words, a function from an infinite type is itself infinite. "
"Functions can be viewed as tables, and a function whose argument type is "
"infinite requires infinitely many rows to represent each case. But functions"
" from finite types require only finitely many rows in their tables, making "
"them finite. Two functions whose argument type is finite can be checked for "
"equality by enumerating all possible arguments, calling the functions on "
"each of them, and then comparing the results. Checking higher-order "
"functions for equality requires generating all possible functions of a given"
" type, which additionally requires that the return type is finite so that "
"each element of the argument type can be mapped to each element of the "
"return type. This is not a _fast_ method, but it does complete in finite "
"time."
msgstr ""
"换句话说，从无限类型来的函数本身也是无限的。函数可以看作表格，而参数类型为无限的函数需要无限多的行来表示每种情况。但从有限类型来的函数只需要有限多的行，因此是有限的。参数类型为有限的两个函数可以通过枚举所有可能的参数，对每个参数调用函数，然后比较结果来检查相等性。检查高阶函数的相等性需要生成给定类型的所有可能函数，此外还需要返回类型是有限的，以便参数类型的每个元素都可以映射到返回类型的每个元素。这不是一种快速的方法，但它确实可以在有限时间内完成。表示有限类型的一种方法是使用宇宙：在这个宇宙中，构造器"
" `arr` 表示函数类型，它用一个箭头 `arr` 来表示。比较这个宇宙中的两个值的相等性与在 `NestedPairs` "
"宇宙中几乎相同。唯一重要的区别是添加了 `arr` 的情况，它使用一个名为 `Finite.enumerate` 的帮助器来生成 `t1` "
"编码的类型中的每个值，检查这两个函数对每个可能的输入返回相等的结果：标准库函数 `List.all` 检查提供的函数是否对列表的每个条目返回 "
"`true`。此函数可用于比较布尔值上的函数是否相等："

#: src/dependent-types/universe-pattern.md:103
#, fuzzy
msgid "One way to represent finite types is by a universe:"
msgstr "?"

#: src/dependent-types/universe-pattern.md:117
#, fuzzy
msgid ""
"In this universe, the constructor `arr` stands for the function type, which "
"is written with an `arr`ow."
msgstr "?"

#: src/dependent-types/universe-pattern.md:119
#, fuzzy
msgid ""
"Comparing two values from this universe for equality is almost the same as "
"in the `NestedPairs` universe. The only important difference is the addition"
" of the case for `arr`, which uses a helper called `Finite.enumerate` to "
"generate every value from the type coded for by `t1`, checking that the two "
"functions return equal results for every possible input:"
msgstr "?"

#: src/dependent-types/universe-pattern.md:130
#, fuzzy
msgid ""
"The standard library function `List.all` checks that the provided function "
"returns `true` on every entry of a list. This function can be used to "
"compare functions on the Booleans for equality:"
msgstr "?"

#: src/dependent-types/universe-pattern.md:138
#, fuzzy
msgid "It can also be used to compare functions from the standard library:"
msgstr "它还可以用于比较标准库中的函数："

#: src/dependent-types/universe-pattern.md:145
#, fuzzy
msgid ""
"It can even compare functions built using tools such as function "
"composition:"
msgstr "它甚至可以比较使用函数组合等工具构建的函数："

#: src/dependent-types/universe-pattern.md:152
#, fuzzy
msgid ""
"This is because the `Finite` universe codes for Lean's _actual_ function "
"type, not a special analogue created by the library."
msgstr "这是因为 `Finite` 宇宙编码了 Lean 的_实际_函数类型，而不是库创建的特殊类似物。"

#: src/dependent-types/universe-pattern.md:154
#, fuzzy
msgid ""
"The implementation of `enumerate` is also by recursion on the codes from "
"`Finite`."
msgstr "`enumerate` 的实现也是通过对 `Finite` 中代码的递归。"

#: src/dependent-types/universe-pattern.md:163
#, fuzzy
msgid ""
"In the case for `Unit`, there is only a single value. In the case for "
"`Bool`, there are two values to return (`true` and `false`). In the case for"
" pairs, the result should be the Cartesian product of the values for the "
"type coded for by `t1` and the values for the type coded for by `t2`. In "
"other words, every value from `t1` should be paired with every value from "
"`t2`. The helper function `List.product` can certainly be written with an "
"ordinary recursive function, but here it is defined using `for` in the "
"identity monad:"
msgstr ""
"对于 `Unit`，只有一个值。对于 `Bool`，有两个值要返回（`true` 和 `false`）。对于对，结果应该是 `t1` 编码的类型的值和 "
"`t2` 编码的类型的值的笛卡尔积。换句话说，`t1` 中的每个值都应该与 `t2` 中的每个值配对。辅助函数 `List.product` "
"当然可以用普通递归函数编写，但这里使用恒等单子中的 `for` 定义它："

#: src/dependent-types/universe-pattern.md:176
#, fuzzy
msgid ""
"Finally, the case of `Finite.enumerate` for functions delegates to a helper "
"called `Finite.functions` that takes a list of all of the return values to "
"target as an argument."
msgstr ""
"最后，`Finite.enumerate` 的函数情况委托给一个名为 `Finite.functions` 的辅助函数，该函数将所有返回值列表作为参数。"

#: src/dependent-types/universe-pattern.md:178
#, fuzzy
msgid ""
"Generally speaking, generating all of the functions from some finite type to"
" a collection of result values can be thought of as generating the "
"functions' tables. Each function assigns an output to each input, which "
"means that a given function has \\\\( k \\\\) rows in its table when there "
"are \\\\( k \\\\) possible arguments. Because each row of the table could "
"select any of \\\\( n \\\\) possible outputs, there are \\\\( n ^ k \\\\) "
"potential functions to generate."
msgstr ""
"一般来说，将所有函数从某个有限类型生成到结果值集合可以被认为是生成函数表。每个函数将输出分配给每个输入，这意味着当有 \\\\( k \\\\) "
"个可能的参数时，给定函数在其表中有 \\\\( k \\\\) 行。因为表的每一行都可以选择 \\\\( n \\\\) "
"个可能的输出中的任何一个，所以有 \\\\( n ^ k \\\\) 个潜在函数要生成。"

#: src/dependent-types/universe-pattern.md:182
#, fuzzy
msgid ""
"Once again, generating the functions from a finite type to some list of "
"values is recursive on the code that describes the finite type:"
msgstr "再次，从有限类型生成函数到某个值列表是递归于描述有限类型的代码："

#: src/dependent-types/universe-pattern.md:188
#, fuzzy
msgid ""
"The table for functions from `Unit` contains one row, because the function "
"can't pick different results based on which input it is provided. This means"
" that one function is generated for each potential input."
msgstr "从 `Unit` 到函数的表包含一行，因为函数不能根据提供的输入选择不同的结果。这意味着为每个潜在输入生成一个函数。"

#: src/dependent-types/universe-pattern.md:195
#, fuzzy
msgid ""
"There are \\\\( n^2 \\\\) functions from `Bool` when there are \\\\( n \\\\)"
" result values, because each individual function of type `Bool → α` uses the"
" `Bool` to select between two particular `α`s:"
msgstr ""
"当有 \\\\( n \\\\) 个结果值时，从 `Bool` 到函数有 \\\\( n^2 \\\\)，因为每个类型为 `Bool → α` "
"的函数使用 `Bool` 在两个特定的 `α` 之间进行选择："

#: src/dependent-types/universe-pattern.md:203
#, fuzzy
msgid ""
"Generating the functions from pairs can be achieved by taking advantage of "
"currying. A function from a pair can be transformed into a function that "
"takes the first element of the pair and returns a function that's waiting "
"for the second element of the pair. Doing this allows `Finite.functions` to "
"be used recursively in this case:"
msgstr ""
"通过利用柯里化可以生成从对生成函数。从对的函数可以转换为一个函数，该函数获取对的第一个元素并返回一个等待对的第二个元素的函数。这样做允许 "
"`Finite.functions` 在这种情况下递归使用："

#: src/dependent-types/universe-pattern.md:214
#, fuzzy
msgid ""
"Generating higher-order functions is a bit of a brain bender. Each higher-"
"order function takes a function as its argument. This argument function can "
"be distinguished from other functions based on its input/output behavior. In"
" general, the higher-order function can apply the argument function to every"
" possible argument, and it can then carry out any possible behavior based on"
" the result of applying the argument function. This suggests a means of "
"constructing the higher-order functions:"
msgstr ""
"生成高阶函数有点费脑。每个高阶函数都将函数作为其参数。此参数函数可以根据其输入/输出行为与其他函数区分开来。通常，高阶函数可以将参数函数应用于每个可能的参数，然后它可以根据应用参数函数的结果执行任何可能的函数。这表明了构建高阶函数的方法："

#: src/dependent-types/universe-pattern.md:219
#, fuzzy
msgid ""
"Begin with a list of all possible arguments to the function that is itself "
"an argument."
msgstr "从函数的所有可能参数的列表开始，该函数本身是一个参数。"

#: src/dependent-types/universe-pattern.md:220
#, fuzzy
msgid ""
"For each possible argument, construct all possible behaviors that can result"
" from the observation of applying the argument function to the possible "
"argument. This can be done using `Finite.functions` and recursion over the "
"rest of the possible arguments, because the result of the recursion "
"represents the functions based on the observations of the rest of the "
"possible arguments. `Finite.functions` constructs all the ways of achieving "
"these based on the observation for the current argument."
msgstr ""
"对于每个可能的参数，构造所有可能的行为，这些行为可能由观察将参数函数应用于可能的参数而产生。这可以使用 `Finite.functions` "
"和对其余可能参数的递归来完成，因为递归的结果表示基于其余可能参数的观察的函数。`Finite.functions` "
"基于当前参数的观察构建了实现这些的所有方法。"

#: src/dependent-types/universe-pattern.md:221
#, fuzzy
msgid ""
"For potential behavior in response to these observations, construct a "
"higher-order function that applies the argument function to the current "
"possible argument. The result of this is then passed to the observation "
"behavior."
msgstr "针对这些观察结果的潜在行为，构造一个高阶函数，将参数函数应用于当前可能的参数。然后将结果传递给观察行为。"

#: src/dependent-types/universe-pattern.md:222
#, fuzzy
msgid ""
"The base case of the recursion is a higher-order function that observes "
"nothing for each result value—it ignores the argument function and simply "
"returns the result value."
msgstr "递归的基本情况是一个高阶函数，它对每个结果值都不进行观察——它忽略参数函数，只返回结果值。"

#: src/dependent-types/universe-pattern.md:224
#, fuzzy
msgid ""
"Defining this recursive function directly causes Lean to be unable to prove "
"that the whole function terminates. However, using a simpler form of "
"recursion called a _right fold_ can be used to make it clear to the "
"termination checker that the function terminates. A right fold takes three "
"arguments: a step function that combines the head of the list with the "
"result of the recursion over the tail, a default value to return when the "
"list is empty, and the list being processed. It then analyzes the list, "
"essentially replacing each `::` in the list with a call to the step function"
" and replacing `[]` with the default value:"
msgstr ""
"直接定义这个递归函数会导致 Lean "
"无法证明整个函数终止。然而，使用一种称为“右折叠”的更简单的递归形式可以向终止检查器清楚地表明函数终止。右折叠接受三个参数：一个将列表的头部与递归在尾部上的结果相结合的步骤函数，一个在列表为空时返回的默认值，以及正在处理的列表。然后它分析列表，实质上用对步骤函数的调用替换列表中的每个"
" `::`，并用默认值替换 `[]`："

#: src/dependent-types/universe-pattern.md:233
#, fuzzy
msgid "Finding the sum of the `Nat`s in a list can be done with `foldr`:"
msgstr "使用 `foldr` 可以找到列表中 `Nat` 的和："

#: src/dependent-types/universe-pattern.md:244
#, fuzzy
msgid "With `foldr`, the higher-order functions can be created as follows:"
msgstr "使用 `foldr`，可以按如下方式创建高阶函数："

#: src/dependent-types/universe-pattern.md:257
#, fuzzy
msgid "The complete definition of `Finite.Functions` is:"
msgstr "`Finite.Functions` 的完整定义是："

#: src/dependent-types/universe-pattern.md:288
#, fuzzy
msgid ""
"Because `Finite.enumerate` and `Finite.functions` call each other, they must"
" be defined in a `mutual` block. In other words, right before the definition"
" of `Finite.enumerate` is the `mutual` keyword:"
msgstr ""
"因为 `Finite.enumerate` 和 `Finite.functions` 相互调用，所以它们必须在一个 `mutual` "
"块中定义。换句话说，在 `Finite.enumerate` 的定义之前是 `mutual` 关键字："

#: src/dependent-types/universe-pattern.md:295
#, fuzzy
msgid ""
"and right after the definition of `Finite.functions` is the `end` keyword:"
msgstr "在 `Finite.functions` 的定义之后是 `end` 关键字："

#: src/dependent-types/universe-pattern.md:310
#, fuzzy
msgid ""
"This algorithm for comparing functions is not particularly practical. The "
"number of cases to check grows exponentially; even a simple type like "
"`((Bool × Bool) → Bool) → Bool` describes 65536 distinct functions. Why are "
"there so many? Based on the reasoning above, and using \\\\( \\\\left| T "
"\\\\right| \\\\) to represent the number of values described by the type "
"\\\\( T \\\\), we should expect that \\\\\\[ \\\\left| \\\\left( \\\\left( "
"\\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right) \\\\rightarrow "
"\\\\mathtt{Bool} \\\\right) \\\\rightarrow \\\\mathtt{Bool} \\\\right| "
"\\\\\\] is  \\\\\\[ \\\\left|\\\\mathrm{Bool}\\\\right|^{\\\\left| \\\\left("
" \\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right) \\\\rightarrow "
"\\\\mathtt{Bool} \\\\right| }, \\\\\\] which is \\\\\\[ 2^{2^{\\\\left| "
"\\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right| }}, \\\\\\] which is "
"\\\\\\[ 2^{2^4} \\\\\\] or 65536. Nested exponentials grow quickly, and "
"there are many higher-order functions."
msgstr ""
"这种比较函数的算法并不是特别实用。要检查的情况数呈指数增长；即使像 `((Bool × Bool) → Bool) → Bool` "
"这样的简单类型也描述了 65536 个不同的函数。为什么会有这么多？基于以上推理，并使用 \\\\( \\\\left| T \\\\right| "
"\\\\) 表示类型 \\\\( T \\\\) 描述的值的数量，我们应该预期 \\\\\\[ \\\\left| \\\\left( "
"\\\\left( \\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right) "
"\\\\rightarrow \\\\mathtt{Bool} \\\\right) \\\\rightarrow \\\\mathtt{Bool} "
"\\\\right| \\\\\\] 为  \\\\\\[ \\\\left|\\\\mathrm{Bool}\\\\right|^{\\\\left|"
" \\\\left( \\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right) "
"\\\\rightarrow \\\\mathtt{Bool} \\\\right| }, \\\\\\] 即 \\\\\\[ "
"2^{2^{\\\\left| \\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right| }}, "
"\\\\\\] 即 \\\\\\[ 2^{2^4} \\\\\\] 或 65536。嵌套指数增长很快，而且有许多高阶函数。"

#: src/dependent-types/universe-pattern.md:327
#, fuzzy
msgid ""
"Write a function that converts any value from a type coded for by `Finite` "
"into a string. Functions should be represented as their tables."
msgstr "编写一个函数，将由 `Finite` 编码的任何值转换为字符串。函数应表示为其表。"

#: src/dependent-types/universe-pattern.md:328
#, fuzzy
msgid "Add the empty type `Empty` to `Finite` and `Finite.beq`."
msgstr "将空类型 `Empty` 添加到 `Finite` 和 `Finite.beq`。"

#: src/dependent-types/universe-pattern.md:329
#, fuzzy
msgid "Add `Option` to `Finite` and `Finite.beq`."
msgstr "将 `Option` 添加到 `Finite` 和 `Finite.beq`。"
