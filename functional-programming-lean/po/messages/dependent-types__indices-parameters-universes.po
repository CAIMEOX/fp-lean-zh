#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/dependent-types/indices-parameters-universes.md:3
#, fuzzy
msgid ""
"The distinction between indices and parameters of an inductive type is more "
"than just a way to describe arguments to the type that either vary or do not"
" between the constructors. Whether an argument to an inductive type is a "
"parameter or an index also matters when it comes time to determine the "
"relationships between their universe levels. In particular, an inductive "
"type may have the same universe level as a parameter, but it must be in a "
"larger universe than its indices. This restriction is necessary to ensure "
"that Lean can be used as a theorem prover as well as a programming "
"language—without it, Lean's logic would be inconsistent. Experimenting with "
"error messages is a good way to illustrate these rules, as well as the "
"precise rules that determine whether an argument to a type is a parameter or"
" an index."
msgstr ""
"归纳类型的索引和参数之间的区别不仅仅是描述类型参数的一种方式，这些参数在构造函数之间变化或不变。归纳类型的参数是参数还是索引在确定它们宇宙级别之间的关系时也很重要。特别是，归纳类型可能与参数具有相同的宇宙级别，但它必须大于其索引的宇宙。此限制对于确保"
" Lean 可用作定理证明器和编程语言是必要的——如果没有它，Lean "
"的逻辑将不一致。尝试错误消息是说明这些规则的好方法，以及确定类型参数是参数还是索引的确切规则。"

#: src/dependent-types/indices-parameters-universes.md:9
#, fuzzy
msgid ""
"Generally speaking, the definition of an inductive type takes its parameters"
" before a colon and its indices after the colon. Parameters are given names "
"like function arguments, whereas indices only have their types described. "
"This can be seen in the definition of `Vect`:"
msgstr ""
"一般来说，归纳类型的定义在冒号前给出其参数，在冒号后给出其索引。参数被赋予函数参数一样的名称，而索引只描述它们的类型。这可以在 `Vect` "
"的定义中看到："

#: src/dependent-types/indices-parameters-universes.md:17
#, fuzzy
msgid ""
"In this definition, `α` is a parameter and the `Nat` is an index. Parameters"
" may be referred to throughout the definition (for example, `Vect.cons` uses"
" `α` for the type of its first argument), but they must always be used "
"consistently. Because indices are expected to change, they are assigned "
"individual values at each constructor, rather than being provided as "
"arguments at the top of the datatype definition."
msgstr ""
"在这个定义中，`α` 是一个参数，`Nat` 是一个索引。参数可以在整个定义中被引用（例如，`Vect.cons` 使用 `α` "
"作为其第一个参数的类型），但它们必须始终被一致地使用。由于索引预期会改变，因此它们在每个构造函数中被分配单独的值，而不是在数据类型定义的顶部作为参数提供。"

#: src/dependent-types/indices-parameters-universes.md:22
#, fuzzy
msgid "A very simple datatype with a parameter is `WithParameter`:"
msgstr "一个带有参数的非常简单的类型是 `WithParameter`："

#: src/dependent-types/indices-parameters-universes.md:27
#, fuzzy
msgid ""
"The universe level `u` can be used for both the parameter and for the "
"inductive type itself, illustrating that parameters do not increase the "
"universe level of a datatype. Similarly, when there are multiple parameters,"
" the inductive type receives whichever universe level is greater:"
msgstr ""
"universe 级别 `u` 可以同时用于参数和归纳类型本身，这说明参数不会增加数据类型的 universe "
"级别。类似地，当有多个参数时，归纳类型接收较大的 universe 级别："

#: src/dependent-types/indices-parameters-universes.md:33
#, fuzzy
msgid ""
"Because parameters do not increase the universe level of a datatype, they "
"can be more convenient to work with. Lean attempts to identify arguments "
"that are described like indices (after the colon), but used like parameters,"
" and turn them into parameters: Both of the following inductive datatypes "
"have their parameter written after the colon:"
msgstr ""
"由于参数不会增加数据类型的 universe 级别，因此使用它们会更方便。Lean "
"尝试识别像索引（在冒号后）一样描述但像参数一样使用的参数，并将它们转换为参数：以下两个归纳数据类型都将它们的放在冒号后："

#: src/dependent-types/indices-parameters-universes.md:45
#, fuzzy
msgid ""
"When a parameter is not named in the initial datatype declaration, different"
" names may be used for it in each constructor, so long as they are used "
"consistently. The following declaration is accepted:"
msgstr "当一个参数在初始数据类型声明中没有被命名时，可以在每个构造函数中使用不同的名称，只要它们被一致地使用。以下声明是可以接受的："

#: src/dependent-types/indices-parameters-universes.md:52
#, fuzzy
msgid ""
"However, this flexibility does not extend to datatypes that explicitly "
"declare the names of their parameters:"
msgstr "然而，这种灵活性不适用于明确声明其参数名称的数据类型："

#: src/dependent-types/indices-parameters-universes.md:64
#, fuzzy
msgid "Similarly, attempting to name an index results in an error:"
msgstr "同样，尝试命名索引也会导致错误："

#: src/dependent-types/indices-parameters-universes.md:77
#, fuzzy
msgid ""
"Using an appropriate universe level and placing the index after the colon "
"results in a declaration that is acceptable:"
msgstr "使用适当的宇宙级别并将索引放在冒号后面会导致可接受的声明："

#: src/dependent-types/indices-parameters-universes.md:85
#, fuzzy
msgid ""
"Even though Lean can sometimes determine that an argument after the colon in"
" an inductive type declaration is a parameter when it is used consistently "
"in all constructors, all parameters are still required to come before all "
"indices. Attempting to place a parameter after an index results in the "
"argument being considered an index itself, which would require the universe "
"level of the datatype to increase:"
msgstr ""
"尽管 Lean "
"有时可以确定归纳类型声明中冒号后面的参数在所有构造函数中一致使用时是参数，但所有参数仍然需要在所有索引之前。尝试将参数放在索引之后会导致参数本身被视为索引，这将需要增加数据类型的宇宙级别："

#: src/dependent-types/indices-parameters-universes.md:101
#, fuzzy
msgid ""
"Parameters need not be types. This example shows that ordinary datatypes "
"such as `Nat` may be used as parameters:"
msgstr "参数不必是类型。此示例表明，普通数据类型（如 `Nat`）可以用作参数："

#: src/dependent-types/indices-parameters-universes.md:113
#, fuzzy
msgid "Using the `n` as suggested causes the declaration to be accepted:"
msgstr "按建议使用 `n` 会导致声明被接受："

#: src/dependent-types/indices-parameters-universes.md:122
#, fuzzy
msgid ""
"What can be concluded from these experiments? The rules of parameters and "
"indices are as follows:"
msgstr "从这些实验中可以得出什么结论？参数和索引的规则如下："

#: src/dependent-types/indices-parameters-universes.md:124
#, fuzzy
msgid "Parameters must be used identically in each constructor's type."
msgstr "参数必须在每个构造函数的类型中相同使用。"

#: src/dependent-types/indices-parameters-universes.md:125
#, fuzzy
msgid "All parameters must come before all indices."
msgstr "所有参数必须在所有索引之前。"

#: src/dependent-types/indices-parameters-universes.md:126
#, fuzzy
msgid ""
"The universe level of the datatype being defined must be at least as large "
"as the largest parameter, and strictly larger than the largest index."
msgstr "正在定义的数据类型的宇宙级别必须至少与最大参数一样大，并且严格大于最大索引。"

#: src/dependent-types/indices-parameters-universes.md:127
#, fuzzy
msgid ""
"Named arguments written before the colon are always parameters, while "
"arguments after the colon are typically indices. Lean may determine that the"
" usage of arguments after the colon makes them into parameters if they are "
"used consistently in all constructors and don't come after any indices."
msgstr ""
"写在冒号之前的命名参数始终是参数，而冒号之后的参数通常是索引。如果在所有构造函数中一致使用并且不位于任何索引之后，Lean "
"可能会确定冒号后面参数的使用方式使其成为参数。"

#: src/dependent-types/indices-parameters-universes.md:129
#, fuzzy
msgid ""
"When in doubt, the Lean command `#print` can be used to check how many of a "
"datatype's arguments are parameters. For example, for `Vect`, it points out "
"that the number of parameters is 1:"
msgstr "当有疑问时，可以使用 Lean 命令 `#print` 来检查数据类型的参数数量。例如，对于 `Vect`，它指出参数数量为 1："

#: src/dependent-types/indices-parameters-universes.md:142
#, fuzzy
msgid ""
"It is worth thinking about which arguments should be parameters and which "
"should be indices when choosing the order of arguments to a datatype. Having"
" as many arguments as possible be parameters helps keep universe levels "
"under control, which can make a complicated program easier to type check. "
"One way to make this possible is to ensure that all parameters come before "
"all indices in the argument list."
msgstr ""
"在选择数据类型参数的顺序时，值得考虑哪些参数应该是参数，哪些应该是索引。尽可能多地将参数作为参数有助于控制宇宙级别，这可以使复杂的程序更容易进行类型检查。实现此目的的一种方法是确保所有参数都在参数列表中的所有索引之前。"

#: src/dependent-types/indices-parameters-universes.md:146
#, fuzzy
msgid ""
"Additionally, even though Lean is capable of determining that arguments "
"after the colon are nonetheless parameters by their usage, it's a good idea "
"to write parameters with explicit names. This makes the intention clear to "
"readers, and it causes Lean to report an error if the argument is mistakenly"
" used inconsistently across the constructors."
msgstr ""
"此外，即使 Lean "
"能够确定冒号后面的参数仍然是参数，但最好使用显式名称编写参数。这可以向读者明确表达意图，并且如果在构造函数中错误地不一致地使用了参数，Lean "
"会报告错误。"
