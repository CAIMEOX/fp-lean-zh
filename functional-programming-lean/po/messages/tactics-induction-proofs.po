#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/tactics-induction-proofs.md:3
#, fuzzy
msgid "A Note on Proofs and User Interfaces"
msgstr "关于证明和用户界面的说明"

#: src/tactics-induction-proofs.md:5
#, fuzzy
msgid ""
"This book presents the process of writing proofs as if they are written in "
"one go and submitted to Lean, which then replies with error messages that "
"describe what remains to be done. The actual process of interacting with "
"Lean is much more pleasant. Lean provides information about the proof as the"
" cursor is moved through it and there are a number of interactive features "
"that make proving easier. Please consult the documentation of your Lean "
"development environment for more information."
msgstr ""
"本书介绍了编写证明的过程，就好像它们一次性编写并提交给 Lean，然后 Lean 用描述剩余工作的错误消息进行回复。与 Lean "
"交互的实际过程要愉快得多。当光标在证明中移动时，Lean 会提供有关证明的信息，并且有一些交互式功能可以使证明更容易。有关更多信息，请查阅 Lean "
"开发环境的文档。"

#: src/tactics-induction-proofs.md:10
#, fuzzy
msgid ""
"The approach in this book that focuses on incrementally building a proof and"
" showing the messages that result demonstrates the kinds of interactive "
"feedback that Lean provides while writing a proof, even though it is much "
"slower than the process used by experts. At the same time, seeing incomplete"
" proofs evolve towards completeness is a useful perspective on proving. As "
"your skill in writing proofs increases, Lean's feedback will come to feel "
"less like errors and more like support for your own thought processes. "
"Learning the interactive approach is very important."
msgstr ""
"本书中专注于逐步构建证明并显示结果消息的方法演示了 Lean "
"在编写证明时提供的交互式反馈类型，即使它比专家使用的过程慢得多。同时，看到不完整的证明向完整性演变是对证明的有用视角。随着您编写证明的技能提高，Lean"
" 的反馈将不再像错误，而更像是对您自己思维过程的支持。学习交互式方法非常重要。"

#: src/tactics-induction-proofs.md:15
#, fuzzy
msgid "Recursion and Induction"
msgstr "递归和归纳"

#: src/tactics-induction-proofs.md:17
#, fuzzy
msgid ""
"The functions `plusR_succ_left` and `plusR_zero_left` from the preceding "
"chapter can be seen from two perspectives. On the one hand, they are "
"recursive functions that build up evidence for a proposition, just as other "
"recursive functions might construct a list, a string, or any other data "
"structure. On the other, they also correspond to proofs by _mathematical "
"induction_."
msgstr ""
"前一章中的函数 `plusR_succ_left` 和 `plusR_zero_left` "
"可以从两个角度来看。一方面，它们是递归函数，用于为命题建立证据，就像其他递归函数可能构造列表、字符串或任何其他数据结构一样。另一方面，它们也对应于数学归纳法的证明。"

#: src/tactics-induction-proofs.md:21
#, fuzzy
msgid ""
"Mathematical induction is a proof technique where a statement is proven for "
"_all_ natural numbers in two steps:"
msgstr "数学归纳法是一种证明技术，其中一个陈述被证明适用于所有自然数，分为两步："

#: src/tactics-induction-proofs.md:22
#, fuzzy
msgid ""
"The statement is shown to hold for \\\\( 0 \\\\). This is called the _base "
"case_."
msgstr "证明该陈述对 \\\\( 0 \\\\) 成立。这称为基本情况。"

#: src/tactics-induction-proofs.md:23
#, fuzzy
msgid ""
"Under the assumption that the statement holds for some arbitrarily chosen "
"number \\\\( n \\\\), it is shown to hold for \\\\( n + 1 \\\\). This is "
"called the _induction step_. The assumption that the statement holds for "
"\\\\( n \\\\) is called the _induction hypothesis_."
msgstr ""
"在假设该陈述对任意选定的数字 \\\\( n \\\\) 成立的情况下，证明它对 \\\\( n + 1 \\\\) 成立。这称为归纳步骤。假设该陈述对"
" \\\\( n \\\\) 成立称为归纳假设。"

#: src/tactics-induction-proofs.md:25
#, fuzzy
msgid ""
"Because it's impossible to check the statement for _every_ natural number, "
"induction provides a means of writing a proof that could, in principle, be "
"expanded to any particular natural number. For example, if a concrete proof "
"were desired for the number 3, then it could be constructed by using first "
"the base case and then the induction step three times, to show the statement"
" for 0, 1, 2, and finally 3. Thus, it proves the statement for all natural "
"numbers."
msgstr ""
"由于不可能检查每个自然数的陈述，因此归纳提供了一种编写证明的方法，原则上可以扩展到任何特定的自然数。例如，如果需要对数字 3 "
"进行具体证明，则可以通过首先使用基本情况，然后使用归纳步骤三次来构造它，以显示 0、1、2 和最终 3 的陈述。因此，它证明了所有自然数的陈述。"

#: src/tactics-induction-proofs.md:29
#, fuzzy
msgid "The Induction Tactic"
msgstr "归纳策略"

#: src/tactics-induction-proofs.md:31
#, fuzzy
msgid ""
"Writing proofs by induction as recursive functions that use helpers such as "
"`congrArg` does not always do a good job of expressing the intentions behind"
" the proof. While recursive functions indeed have the structure of "
"induction, they should probably be viewed as an _encoding_ of a proof. "
"Furthermore, Lean's tactic system provides a number of opportunities to "
"automate the construction of a proof that are not available when writing the"
" recursive function explicitly. Lean provides an induction _tactic_ that can"
" carry out an entire proof by induction in a single tactic block. Behind the"
" scenes, Lean constructs the recursive function that corresponds the use of "
"induction."
msgstr ""
"将归纳证明写为使用诸如 `congrArg` "
"之类的帮助程序的递归函数并不总是能够很好地表达证明背后的意图。虽然递归函数确实具有归纳的结构，但它们可能应该被视为证明的编码。此外，Lean "
"的策略系统提供了许多机会来自动化证明的构建，而这些机会在显式编写递归函数时不可用。Lean "
"提供了一个归纳策略，可以在一个策略块中执行整个归纳证明。在幕后，Lean 构造了与使用归纳相对应的递归函数。"

#: src/tactics-induction-proofs.md:37
#, fuzzy
msgid ""
"To prove `plusR_zero_left` with the induction tactic, begin by writing its "
"signature (using `theorem`, because this really is a proof). Then, use `by "
"induction k` as the body of the definition:"
msgstr ""
"使用归纳法证明 `plusR_zero_left`，首先写出它的签名（使用 `theorem`，因为它确实是一个证明）。然后，使用 `by "
"induction k` 作为定义的主体："

#: src/tactics-induction-proofs.md:43
#, fuzzy
msgid "The resulting message states that there are two goals:"
msgstr "生成的提示指出有两个目标："

#: src/tactics-induction-proofs.md:54
#, fuzzy
msgid ""
"A tactic block is a program that is run while the Lean type checker "
"processes a file, somewhat like a much more powerful C preprocessor macro. "
"The tactics generate the actual program."
msgstr "策略块是一个程序，它在 Lean 类型检查器处理文件时运行，有点像一个功能更强大的 C 预处理器宏。策略生成实际程序。"

#: src/tactics-induction-proofs.md:57
#, fuzzy
msgid ""
"In the tactic language, there can be a number of goals. Each goal consists "
"of a type together with some assumptions. These are analogous to using "
"underscores as placeholders—the type in the goal represents what is to be "
"proved, and the assumptions represent what is in-scope and can be used. In "
"the case of the goal `case zero`, there are no assumptions and the type is "
"`Nat.zero = Nat.plusR 0 Nat.zero`—this is the theorem statement with `0` "
"instead of `k`. In the goal `case succ`, there are two assumptions, named "
"`n✝` and `n_ih✝`. Behind the scenes, the `induction` tactic creates a "
"dependent pattern match that refines the overall type, and `n✝` represents "
"the argument to `Nat.succ` in the pattern. The assumption `n_ih✝` represents"
" the result of calling the generated function recursively on `n✝`. Its type "
"is the overall type of the theorem, just with `n✝` instead of `k`. The type "
"to be fulfilled as part of the goal `case succ` is the overall theorem "
"statement, with `Nat.succ n✝` instead of `k`."
msgstr ""
"在策略语言中，可以有多个目标。每个目标由一个类型和一些假设组成。这些类似于使用下划线作为占位符——目标中的类型表示要证明的内容，而假设表示范围内可以使用的内容。在目标"
" `case zero` 的情况下，没有假设，类型为 `Nat.zero = Nat.plusR 0 Nat.zero`——这是定理陈述，其中 `0` "
"代替了 `k`。在目标 `case succ` 中，有两个假设，分别命名为 `n✝` 和 `n_ih✝`。在幕后，`induction` "
"策略创建了一个依赖模式匹配，它细化了整体类型，`n✝` 表示模式中 `Nat.succ` 的参数。假设 `n_ih✝` 表示在 `n✝` "
"上递归调用生成函数的结果。它的类型是定理的整体类型，只是用 `n✝` 代替了 `k`。作为目标 `case succ` "
"的一部分要实现的类型是整体定理陈述，其中 `Nat.succ n✝` 代替了 `k`。"

#: src/tactics-induction-proofs.md:67
#, fuzzy
msgid ""
"The two goals that result from the use of the `induction` tactic correspond "
"to the base case and the induction step in the description of mathematical "
"induction. The base case is `case zero`. In `case succ`, `n_ih✝` corresponds"
" to the induction hypothesis, while the whole of `case succ` is the "
"induction step."
msgstr ""
"使用 `induction` 策略产生的两个目标对应于数学归纳法描述中的基本情况和归纳步骤。基本情况是 `case zero`。在 `case "
"succ` 中，`n_ih✝` 对应于归纳假设，而整个 `case succ` 是归纳步骤。"

#: src/tactics-induction-proofs.md:71
#, fuzzy
msgid ""
"The next step in writing the proof is to focus on each of the two goals in "
"turn. Just as `pure ()` can be used in a `do` block to indicate \"do "
"nothing\", the tactic language has a statement `skip` that also does "
"nothing. This can be used when Lean's syntax requires a tactic, but it's not"
" yet clear which one should be used. Adding `with` to the end of the "
"`induction` statement provides a syntax that is similar to pattern matching:"
msgstr ""
"接下来，证明的步骤是依次关注两个目标。正如 `pure ()` 可用于 `do` 块中以表示“什么都不做”，策略语言有一个语句 "
"`skip`，它也什么都不做。当 Lean 的语法需要一个策略，但尚不清楚应该使用哪一个策略时，可以使用它。在 `induction` 语句的末尾添加 "
"`with` 提供了一个类似于模式匹配的语法："

#: src/tactics-induction-proofs.md:81
#, fuzzy
msgid ""
"Each of the two `skip` statements has a message associated with it. The "
"first shows the base case:"
msgstr "每个 `skip` 语句都有一个关联的消息。第一个显示基本情况："

#: src/tactics-induction-proofs.md:88
#, fuzzy
msgid "The second shows the induction step:"
msgstr "第二个显示归纳步骤："

#: src/tactics-induction-proofs.md:96
#, fuzzy
msgid ""
"In the induction step, the inaccessible names with daggers have been "
"replaced with the names provided after `succ`, namely `n` and `ih`."
msgstr "在归纳步骤中，带匕首的不可访问名称已被替换为 `succ` 后提供的名称，即 `n` 和 `ih`。"

#: src/tactics-induction-proofs.md:98
#, fuzzy
msgid ""
"The cases after `induction ... with` are not patterns: they consist of the "
"name of a goal followed by zero or more names. The names are used for "
"assumptions introduced in the goal; it is an error to provide more names "
"than the goal introduces:"
msgstr ""
"`induction ... with` 之后的 case "
"不是模式：它们由目标名称后跟零个或多个名称组成。这些名称用于目标中引入的假设；提供比目标引入的更多名称是错误的："

#: src/tactics-induction-proofs.md:110
#, fuzzy
msgid ""
"Focusing on the base case, the `rfl` tactic works just as well inside of the"
" `induction` tactic as it does in a recursive function:"
msgstr "关注基本情况，`rfl` 策略在 `induction` 策略中与在递归函数中一样有效："

#: src/tactics-induction-proofs.md:117
#, fuzzy
msgid ""
"In the recursive function version of the proof, a type annotation made the "
"expected type something that was easier to understand. In the tactic "
"language, there are a number of specific ways to transform a goal to make it"
" easier to solve. The `unfold` tactic replaces a defined name with its "
"definition:"
msgstr ""
"在证明的递归函数版本中，类型注释使预期类型变得更容易理解。在策略语言中，有许多特定方法可以转换目标以使其更容易求解。`unfold` "
"策略用其定义替换已定义的名称："

#: src/tactics-induction-proofs.md:127
#, fuzzy
msgid ""
"Now, the right-hand side of the equality in the goal has become `Nat.plusR 0"
" n + 1` instead of `Nat.plusR 0 (Nat.succ n)`:"
msgstr "现在，目标中等式的右侧已变为 `Nat.plusR 0 n + 1`，而不是 `Nat.plusR 0 (Nat.succ n)`："

#: src/tactics-induction-proofs.md:136
#, fuzzy
msgid ""
"Instead of appealing to functions like `congrArg` and operators like `▸`, "
"there are tactics that allow equality proofs to be used to transform proof "
"goals. One of the most important is `rw`, which takes a list of equality "
"proofs and replaces the left side with the right side in the goal. This "
"almost does the right thing in `plusR_zero_left`:"
msgstr ""
"与其诉诸于 `congrArg` 等函数和 `▸` 等运算符，有一些策略允许使用等式证明来转换证明目标。其中最重要的一个策略是 "
"`rw`，它获取一个等式证明列表，并在目标中用右侧替换左侧。这几乎在 `plusR_zero_left` 中做了正确的事情："

#: src/tactics-induction-proofs.md:147
#, fuzzy
msgid ""
"However, the direction of the rewrite was incorrect. Replacing `n` with "
"`Nat.plusR 0 n` made the goal more complicated rather than less complicated:"
msgstr "然而，重写的方向不正确。将 `n` 替换为 `Nat.plusR 0 n` 使得目标变得更加复杂，而不是更简单："

#: src/tactics-induction-proofs.md:156
#, fuzzy
msgid ""
"This can be remedied by placing a left arrow before `ih` in the call to "
"`rewrite`, which instructs it to replace the right-hand side of the equality"
" with the left-hand side:"
msgstr "这可以通过在 `rewrite` 调用中在 `ih` 之前放置一个左箭头来补救，它指示用等式的右侧替换左侧："

#: src/tactics-induction-proofs.md:165
#, fuzzy
msgid ""
"This rewrite makes both sides of the equation identical, and Lean takes care"
" of the `rfl` on its own. The proof is complete."
msgstr "此重写使等式的两边相同，Lean 自行处理 `rfl`。证明完成。"

#: src/tactics-induction-proofs.md:168
#, fuzzy
msgid "Tactic Golf"
msgstr "策略高尔夫"

#: src/tactics-induction-proofs.md:170
#, fuzzy
msgid ""
"So far, the tactic language has not shown its true value. The above proof is"
" no shorter than the recursive function; it's merely written in a domain-"
"specific language instead of the full Lean language. But proofs with tactics"
" can be shorter, easier, and more maintainable. Just as a lower score is "
"better in the game of golf, a shorter proof is better in the game of tactic "
"golf."
msgstr ""
"到目前为止，策略语言还没有显示其真正的价值。上述证明并不比递归函数短；它只是用特定于领域的语言而不是完整的 Lean "
"语言编写的。但是，使用策略的证明可以更短、更容易和更易于维护。就像在高尔夫球比赛中较低的分数更好一样，在策略高尔夫球比赛中较短的证明更好。"

#: src/tactics-induction-proofs.md:175
#, fuzzy
msgid ""
"The induction step of `plusR_zero_left` can be proved using the "
"simplification tactic `simp`. Using `simp` on its own does not help:"
msgstr "`plusR_zero_left` 的归纳步骤可以使用简化策略 `simp` 来证明。单独使用 `simp` 并没有帮助："

#: src/tactics-induction-proofs.md:187
#, fuzzy
msgid ""
"However, `simp` can be configured to make use of a set of definitions. Just "
"like `rw`, these arguments are provided in a list. Asking `simp` to take the"
" definition of `Nat.plusR` into account leads to a simpler goal:"
msgstr ""
"但是，可以配置 `simp` 以使用一组定义。就像 `rw` 一样，这些参数在列表中提供。要求 `simp` 考虑 `Nat.plusR` "
"的定义会导致一个更简单的目标："

#: src/tactics-induction-proofs.md:204
#, fuzzy
msgid ""
"In particular, the goal is now identical to the induction hypothesis. In "
"addition to automatically proving simple equality statements, the simplifier"
" automatically replaces goals like `Nat.succ A = Nat.succ B` with `A = B`. "
"Because the induction hypothesis `ih` has exactly the right type, the "
"`exact` tactic can indicate that it should be used:"
msgstr ""
"特别是，目标现在与归纳假设相同。除了自动证明简单的等式语句外，简化器还会自动将 `Nat.succ A = Nat.succ B` 这样的目标替换为 "
"`A = B`。因为归纳假设 `ih` 恰好具有正确的类型，所以 `exact` 策略可以指示应该使用它："

#: src/tactics-induction-proofs.md:216
#, fuzzy
msgid ""
"However, the use of `exact` is somewhat fragile. Renaming the induction "
"hypothesis, which may happen while \"golfing\" the proof, would cause this "
"proof to stop working. The `assumption` tactic solves the current goal if "
"_any_ of the assumptions match it:"
msgstr ""
"然而，使用 `exact` 有些脆弱。重命名归纳假设（这可能发生在“高尔夫”证明时）会导致此证明停止工作。`assumption` "
"策略解决了当前目标，如果 _任何_ 假设与之匹配："

#: src/tactics-induction-proofs.md:228
#, fuzzy
msgid ""
"This proof is no shorter than the prior proof that used unfolding and "
"explicit rewriting. However, a series of transformations can make it much "
"shorter, taking advantage of the fact that `simp` can solve many kinds of "
"goals. The first step is to drop the `with` at the end of `induction`. For "
"structured, readable proofs, the `with` syntax is convenient. It complains "
"if any cases are missing, and it shows the structure of the induction "
"clearly. But shortening proofs can often require a more liberal approach."
msgstr ""
"此证明并不比使用展开和显式重写的先前证明短。然而，一系列变换可以使它更短，利用 `simp` 可以解决多种目标这一事实。第一步是在 "
"`induction` 末尾删除 `with`。对于结构化、可读的证明，`with` "
"语法很方便。如果缺少任何情况，它会抱怨，并且它清楚地显示了归纳的结构。但缩短证明通常需要更自由的方法。"

#: src/tactics-induction-proofs.md:235
#, fuzzy
msgid ""
"Using `induction` without `with` simply results in a proof state with two "
"goals. The `case` tactic can be used to select one of them, just as in the "
"branches of the `induction ... with` tactic. In other words, the following "
"proof is equivalent to the prior proof:"
msgstr ""
"在没有 `with` 的情况下使用 `induction` 只会产生一个有两个目标的证明状态。`case` 策略可用于选择其中一个，就像 "
"`induction ... with` 策略的分支一样。换句话说，以下证明等效于先前的证明："

#: src/tactics-induction-proofs.md:247
#, fuzzy
msgid ""
"In a context with a single goal (namely, `k = Nat.plusR 0 k`), the "
"`induction k` tactic yields two goals. In general, a tactic will either fail"
" with an error or take a goal and transform it into zero or more new goals. "
"Each new goal represents what remains to be proved. If the result is zero "
"goals, then the tactic was a success, and that part of the proof is done."
msgstr ""
"在具有单个目标（即 `k = Nat.plusR 0 k`）的上下文中，`induction k` "
"策略产生两个目标。通常，策略要么失败并出现错误，要么获取目标并将其转换为零个或多个新目标。每个新目标代表待证明的内容。如果结果是零个目标，则策略成功，并且证明的那部分就完成了。"

#: src/tactics-induction-proofs.md:252
#, fuzzy
msgid ""
"The `<;>` operator takes two tactics as arguments, resulting in a new "
"tactic. `T1 <;> T2` applies `T1` to the current goal, and then applies `T2` "
"in _all_ goals created by `T1`. In other words, `<;>` enables a general "
"tactic that can solve many kinds of goals to be used on multiple new goals "
"all at once. One such general tactic is `simp`."
msgstr ""
"`<;>` 运算符将两个策略作为参数，从而产生一个新策略。`T1 <;> T2` 将 `T1` 应用于当前目标，然后将 `T2` 应用于 `T1` "
"创建的所有目标。换句话说，`<;>` 允许可以解决多种目标的通用策略一次用于多个新目标。`simp` 就是这样一个通用策略。"

#: src/tactics-induction-proofs.md:257
#, fuzzy
msgid ""
"Because `simp` can both complete the proof of the base case and make "
"progress on the proof of the induction step, using it with `induction` and "
"`<;>` shortens the proof:"
msgstr ""
"由于 `simp` 既能完成基本情况的证明，又能推进归纳步骤的证明，因此将其与 `induction` 和 `<;>` 一起使用可以缩短证明过程："

#: src/tactics-induction-proofs.md:262
#, fuzzy
msgid "This results in only a single goal, the transformed induction step:"
msgstr "这仅产生了一个目标，即转换后的归纳步骤："

#: src/tactics-induction-proofs.md:270
#, fuzzy
msgid "Running `assumption` in this goal completes the proof:"
msgstr "在此目标中运行 `assumption` 可以完成证明："

#: src/tactics-induction-proofs.md:275
#, fuzzy
msgid ""
"Here, `exact` would not have been possible, because `ih` was never "
"explicitly named."
msgstr "此处，`exact` 不可能，因为从未明确命名 `ih`。"

#: src/tactics-induction-proofs.md:277
#, fuzzy
msgid ""
"For beginners, this proof is not easier to read. However, a common pattern "
"for expert users is to take care of a number of simple cases with powerful "
"tactics like `simp`, allowing them to focus the text of the proof on the "
"interesting cases. Additionally, these proofs tend to be more robust in the "
"face of small changes to the functions and datatypes involved in the proof. "
"The game of tactic golf is a useful part of developing good taste and style "
"when writing proofs."
msgstr ""
"对于初学者来说，此证明并不容易理解。然而，专家用户的一个常见模式是用 `simp` "
"等强大的策略处理一些简单的情况，从而使他们能够将证明的重点放在有趣的情况上。此外，这些证明在面对证明中涉及的函数和数据类型的细微更改时往往更加稳健。策略高尔夫游戏是培养编写证明时的良好品味和风格的有用部分。"

#: src/tactics-induction-proofs.md:282
#, fuzzy
msgid "Induction on Other Datatypes"
msgstr "其他数据类型的归纳"

#: src/tactics-induction-proofs.md:284
#, fuzzy
msgid ""
"Mathematical induction proves a statement for natural numbers by providing a"
" base case for `Nat.zero` and an induction step for `Nat.succ`. The "
"principle of induction is also valid for other datatypes. Constructors "
"without recursive arguments form the base cases, while constructors with "
"recursive arguments form the induction steps. The ability to carry out "
"proofs by induction is the very reason why they are called _inductive_ "
"datatypes."
msgstr ""
"数学归纳通过为 `Nat.zero` 提供基本情况和为 `Nat.succ` "
"提供归纳步骤来证明自然数的陈述。归纳原理也适用于其他数据类型。没有递归参数的构造函数形成基本情况，而有递归参数的构造函数形成归纳步骤。通过归纳进行证明的能力正是它们被称为"
" _归纳_ 数据类型的原因。"

#: src/tactics-induction-proofs.md:289
#, fuzzy
msgid ""
"One example of this is induction on binary trees. Induction on binary trees "
"is a proof technique where a statement is proven for _all_ binary trees in "
"two steps:"
msgstr "二叉树归纳就是一个例子。二叉树归纳是一种证明技术，其中一个陈述通过两个步骤被证明适用于 _所有_ 二叉树："

#: src/tactics-induction-proofs.md:291
#, fuzzy
msgid ""
"The statement is shown to hold for `BinTree.leaf`. This is called the base "
"case."
msgstr "该陈述被证明适用于 `BinTree.leaf`。这称为基本情况。"

#: src/tactics-induction-proofs.md:292
#, fuzzy
msgid ""
"Under the assumption that the statement holds for some arbitrarily chosen "
"trees `l` and `r`, it is shown to hold for `BinTree.branch l x r`, where `x`"
" is an arbitrarily-chosen new data point. This is called the _induction "
"step_. The assumptions that the statement holds for `l` and `r` are called "
"the _induction hypotheses_."
msgstr ""
"在假设该陈述对任意选定的树 `l` 和 `r` 成立的情况下，已证明它对 `BinTree.branch l x r` 成立，其中 `x` "
"是任意选定的新数据点。这称为_归纳步骤_。假设该陈述对 `l` 和 `r` 成立称为_归纳假设_。"

#: src/tactics-induction-proofs.md:294
#, fuzzy
msgid "`BinTree.count` counts the number of branches in a tree:"
msgstr "`BinTree.count` 统计树中的分支数："

#: src/tactics-induction-proofs.md:301
#, fuzzy
msgid ""
"[Mirroring a tree](monads/conveniences.md#leading-dot-notation) does not "
"change the number of branches in it. This can be proven using induction on "
"trees. The first step is to state the theorem and invoke `induction`:"
msgstr ""
"[镜像树](monads/conveniences.md#leading-dot-notation) "
"不会改变其中的分支数。这可以通过对树进行归纳来证明。第一步是陈述定理并调用 `induction`："

#: src/tactics-induction-proofs.md:310
#, fuzzy
msgid ""
"The base case states that counting the mirror of a leaf is the same as "
"counting the leaf:"
msgstr "基本情况指出，统计镜像叶与统计叶相同："

#: src/tactics-induction-proofs.md:317
#, fuzzy
msgid ""
"The induction step allows the assumption that mirroring the left and right "
"subtrees won't affect their branch counts, and requests a proof that "
"mirroring a branch with these subtrees also preserves the overall branch "
"count:"
msgstr "归纳步骤允许假设镜像左右子树不会影响它们的分支计数，并要求证明镜像具有这些子树的分支也保留了整体分支计数："

#: src/tactics-induction-proofs.md:331
#, fuzzy
msgid ""
"The base case is true because mirroring `leaf` results in `leaf`, so the "
"left and right sides are definitionally equal. This can be expressed by "
"using `simp` with instructions to unfold `BinTree.mirror`:"
msgstr ""
"基本情况为真，因为镜像 `leaf` 会生成 `leaf`，所以左右两侧在定义上相等。这可以通过使用 `simp` 和展开 "
"`BinTree.mirror` 的指令来表示："

#: src/tactics-induction-proofs.md:339
#, fuzzy
msgid ""
"In the induction step, nothing in the goal immediately matches the induction"
" hypotheses. Simplifying using the definitions of `BinTree.count` and "
"`BinTree.mirror` reveals the relationship:"
msgstr ""
"在归纳步骤中，目标中的任何内容都不立即匹配归纳假设。使用 `BinTree.count` 和 `BinTree.mirror` "
"的定义进行简化，揭示了关系："

#: src/tactics-induction-proofs.md:359
#, fuzzy
msgid ""
"Both induction hypotheses can be used to rewrite the left-hand side of the "
"goal into something almost like the right-hand side:"
msgstr "两个归纳假设都可以用来将目标的左侧重写为几乎类似于右侧的东西："

#: src/tactics-induction-proofs.md:380
#, fuzzy
msgid ""
"The `simp_arith` tactic, a version of `simp` that can use additional "
"arithmetic identities, is enough to prove this goal, yielding:"
msgstr "`simp_arith` 策略（一种可以使用其他算术恒等式的 `simp`）足以证明此目标，产生："

#: src/tactics-induction-proofs.md:391
#, fuzzy
msgid ""
"In addition to definitions to be unfolded, the simplifier can also be passed"
" names of equality proofs to use as rewrites while it simplifies proof "
"goals. `BinTree.mirror_count` can also be written:"
msgstr ""
"除了要展开的定义外，简化器还可以传递等式证明的名称，以便在简化证明目标时用作重写。`BinTree.mirror_count` 还可以写成："

#: src/tactics-induction-proofs.md:400
#, fuzzy
msgid ""
"As proofs grow more complicated, listing assumptions by hand can become "
"tedious. Furthermore, manually writing assumption names can make it more "
"difficult to re-use proof steps for multiple subgoals. The argument `*` to "
"`simp` or `simp_arith` instructs them to use _all_ assumptions while "
"simplifying or solving the goal. In other words, the proof could also be "
"written:"
msgstr ""
"随着证明变得越来越复杂，手动列出假设会变得很繁琐。此外，手动编写假设名称会使为多个子目标重用证明步骤变得更加困难。`simp` 或 "
"`simp_arith` 的参数 `*` 指示它们在简化或求解目标时使用 _所有_假设。换句话说，证明也可以写成："

#: src/tactics-induction-proofs.md:411
#, fuzzy
msgid ""
"Because both branches are using the simplifier, the proof can be reduced to:"
msgstr "由于两个分支都使用简化器，因此可以将证明简化为："

#: src/tactics-induction-proofs.md:420
#, fuzzy
msgid "Prove `plusR_succ_left` using the `induction ... with` tactic."
msgstr "使用 `induction ... with` 策略证明 `plusR_succ_left`。"

#: src/tactics-induction-proofs.md:421
#, fuzzy
msgid "Rewrite the proof of `plus_succ_left` to use `<;>` in a single line."
msgstr "重写 `plus_succ_left` 的证明，在单行中使用 `<;>`。"

#: src/tactics-induction-proofs.md:422
#, fuzzy
msgid ""
"Prove that appending lists is associative using induction on lists: `theorem"
" List.append_assoc (xs ys zs : List α) : xs ++ (ys ++ zs) = (xs ++ ys) ++ "
"zs`"
msgstr ""
"使用列表归纳法证明追加列表是关联的：`theorem List.append_assoc (xs ys zs : List α) : xs ++ (ys"
" ++ zs) = (xs ++ ys) ++ zs`"
