#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/functor-applicative-monad/summary.md:3
#, fuzzy
msgid "Type Classes and Structures"
msgstr "类型类和结构"

#: src/functor-applicative-monad/summary.md:5
#, fuzzy
msgid ""
"Behind the scenes, type classes are represented by structures. Defining a "
"class defines a structure, and additionally creates an empty table of "
"instances. Defining an instance creates a value that either has the "
"structure as its type or is a function that can return the structure, and "
"additionally adds an entry to the table. Instance search consists of "
"constructing an instance by consulting the instance tables. Both structures "
"and classes may provide default values for fields (which are default "
"implementations of methods)."
msgstr ""
"在幕后，类型类由结构表示。定义一个类定义了一个结构，并另外创建一个空的实例表。定义一个实例会创建一个值，该值要么具有结构作为其类型，要么是一个可以返回结构的函数，并另外向表中添加一个条目。实例搜索包括通过查阅实例表来构造实例。结构和类都可以为字段提供默认值（这是方法的默认实现）。"

#: src/functor-applicative-monad/summary.md:13
#, fuzzy
msgid ""
"Structures may inherit from other structures. Behind the scenes, a structure"
" that inherits from another structure contains an instance of the original "
"structure as a field. In other words, inheritance is implemented with "
"composition. When multiple inheritance is used, only the unique fields from "
"the additional parent structures are used to avoid a diamond problem, and "
"the functions that would normally extract the parent value are instead "
"organized to construct one. Record dot notation takes structure inheritance "
"into account."
msgstr ""
"结构可以从其他结构继承。在幕后，从另一个结构继承的结构包含一个原始结构的实例作为字段。换句话说，继承是通过组合实现的。当使用多重继承时，仅使用来自附加父结构的唯一字段来避免菱形问题，并且通常用于提取父值的功能被组织为构造一个功能。记录点表示法考虑了结构继承。"

#: src/functor-applicative-monad/summary.md:19
#, fuzzy
msgid ""
"Because type classes are just structures with some additional automation "
"applied, all of these features are available in type classes. Together with "
"default methods, this can be used to create a fine-grained hierarchy of "
"interfaces that nonetheless does not impose a large burden on clients, "
"because the small classes that the large classes inherit from can be "
"automatically implemented."
msgstr ""
"因为类型类只是应用了一些额外自动化的结构，所以所有这些特性在类型类中都是可用的。结合默认方法，这可用于创建粒度很细的接口层次结构，但不会给客户端带来很大的负担，因为大类继承的小类可以自动实现。"

#: src/functor-applicative-monad/summary.md:24
#, fuzzy
msgid "An applicative functor is a functor with two additional operations:"
msgstr "应用函子是一个具有两个附加操作的函子："

#: src/functor-applicative-monad/summary.md:25
#, fuzzy
msgid "`pure`, which is the same operator as that for `Monad`"
msgstr "`pure`，与 `Monad` 中的同名运算符相同"

#: src/functor-applicative-monad/summary.md:26
#, fuzzy
msgid ""
"`seq`, which allows a function to be applied in the context of the functor."
msgstr "`seq`，允许在函子的上下文中应用函数。"

#: src/functor-applicative-monad/summary.md:28
#, fuzzy
msgid ""
"While monads can represent arbitrary programs with control flow, applicative"
" functors can only run function arguments from left to right. Because they "
"are less powerful, they provide less control to programs written against the"
" interface, while the implementor of the method has a greater degree of "
"freedom. Some useful types can implement `Applicative` but not `Monad`."
msgstr ""
"虽然单子可以表示具有控制流的任意程序，但应用函子只能从左到右运行函数参数。由于它们的功能较弱，因此对针对该接口编写的程序提供的控制较少，而方法的实现者拥有更大的自由度。一些有用的类型可以实现"
" `Applicative` 但不能实现 `Monad`。"

#: src/functor-applicative-monad/summary.md:32
#, fuzzy
msgid ""
"In fact, the type classes `Functor`, `Applicative`, and `Monad` form a "
"hierarchy of power. Moving up the hierarchy, from `Functor` towards `Monad`,"
" allows more powerful programs to be written, but fewer types implement the "
"more powerful classes. Polymorphic programs should be written to use as weak"
" of an abstraction as possible, while datatypes should be given instances "
"that are as powerful as possible. This maximizes code re-use. The more "
"powerful type classes extend the less powerful ones, which means that an "
"implementation of `Monad` provides implementations of `Functor` and "
"`Applicative` for free."
msgstr ""
"事实上，类型类 `Functor`、`Applicative` 和 `Monad` 构成了一个功能层次结构。从 `Functor` 向 `Monad` "
"移动，允许编写更强大的程序，但实现更强大类的类型更少。多态程序应该编写为使用尽可能弱的抽象，而数据类型应该被赋予尽可能强大的实例。这最大限度地提高了代码的重用性。更强大的类型类扩展了功能较弱的类型类，这意味着"
" `Monad` 的实现免费提供了 `Functor` 和 `Applicative` 的实现。"

#: src/functor-applicative-monad/summary.md:38
#, fuzzy
msgid ""
"Each class has a set of methods to be implemented and a corresponding "
"contract that specifies additional rules for the methods. Programs that are "
"written against these interfaces expect that the additional rules are "
"followed, and may be buggy if they are not. The default implementations of "
"`Functor`'s methods in terms of `Applicative`'s, and of `Applicative`'s in "
"terms of `Monad`'s, will obey these rules."
msgstr ""
"每个类都有一组要实现的方法，以及一个对应的契约，该契约为这些方法指定了附加规则。针对这些接口编写的程序期望遵循这些附加规则，如果不遵循这些规则，则可能会出现错误。`Functor`"
" 的方法相对于 `Applicative` 的默认实现，以及 `Applicative` 相对于 `Monad` 的默认实现，将遵守这些规则。"

#: src/functor-applicative-monad/summary.md:44
#, fuzzy
msgid ""
"To allow Lean to be used as both a programming language and a theorem "
"prover, some restrictions on the language are necessary. This includes "
"restrictions on recursive functions that ensure that they all either "
"terminate or are marked as `partial` and written to return types that are "
"not uninhabited. Additionally, it must be impossible to represent certain "
"kinds of logical paradoxes as types."
msgstr ""
"为了让 Lean 既可以用作编程语言，又可以用作定理证明器，对该语言进行了一些限制。这包括对递归函数的限制，以确保它们要么终止，要么标记为 "
"`partial`，并写入返回类型，该类型不是空类型。此外，必须不可能将某些类型的逻辑悖论表示为类型。"

#: src/functor-applicative-monad/summary.md:48
#, fuzzy
msgid ""
"One of the restrictions that rules out certain paradoxes is that every type "
"is assigned to a _universe_. Universes are types such as `Prop`, `Type`, "
"`Type 1`, `Type 2`, and so forth. These types describe other types—just as "
"`0` and `17` are described by `Nat`, `Nat` is itself described by `Type`, "
"and `Type` is described by `Type 1`. The type of functions that take a type "
"as an argument must be a larger universe than the argument's universe."
msgstr ""
"排除某些悖论的限制之一是，每个类型都分配给一个 _universe_。Universe 是类型，例如 `Prop`、`Type`、`Type "
"1`、`Type 2` 等。这些类型描述其他类型——就像 `0` 和 `17` 由 `Nat` 描述一样，`Nat` 本身由 `Type` "
"描述，`Type` 由 `Type 1` 描述。将类型作为参数的函数的类型必须大于参数的 universe。"

#: src/functor-applicative-monad/summary.md:53
#, fuzzy
msgid ""
"Because each declared datatype has a universe, writing code that uses types "
"like data would quickly become annoying, requiring each polymorphic type to "
"be copy-pasted to take arguments from `Type 1`. A feature called _universe "
"polymorphism_ allows Lean programs and datatypes to take universe levels as "
"arguments, just as ordinary polymorphism allows programs to take types as "
"arguments. Generally speaking, Lean libraries should use universe "
"polymorphism when implementing libraries of polymorphic operations."
msgstr ""
"因为每个声明的数据类型都有一个 universe，所以编写使用数据类型类型的代码会很快变得很烦人，需要将每个多态类型复制粘贴到从 `Type 1` "
"获取参数。一个称为 _universe polymorphism_ 的特性允许 Lean 程序和数据类型将 universe "
"级别作为参数，就像普通多态性允许程序将类型作为参数一样。一般来说，在实现多态操作的库时，Lean 库应该使用 universe 多态性。"
