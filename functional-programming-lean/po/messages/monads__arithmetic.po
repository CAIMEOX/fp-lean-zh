#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/monads/arithmetic.md:3
#, fuzzy
msgid ""
"Monads are a way of encoding programs with side effects into a language that"
" does not have them. It would be easy to read this as a sort of admission "
"that pure functional programs are missing something important, requiring "
"programmers to jump through hoops just to write a normal program. However, "
"while using the `Monad` API does impose a syntactic cost on a program, it "
"brings two important benefits:"
msgstr ""
"Monad "
"是一种将具有副作用的程序编码到没有副作用的语言中的方式。很容易将此解读为一种承认，纯函数式程序缺少一些重要的东西，要求程序员跳过障碍才能编写一个普通的程序。然而，虽然使用"
" `Monad` API 确实给程序带来了语法成本，但它带来了两个重要的优点："

#: src/monads/arithmetic.md:6
#, fuzzy
msgid ""
"Programs must be honest about which effects they use in their types. A quick"
" glance at a type signature describes _everything_ that the program can do, "
"rather than just what it accepts and what it returns."
msgstr "程序必须诚实地说明它们在类型中使用的效果。快速浏览类型签名描述了程序可以做的一切，而不仅仅是它接受什么和返回什么。"

#: src/monads/arithmetic.md:7
#, fuzzy
msgid ""
"Not every language provides the same effects. For example, only some "
"language have exceptions. Other languages have unique, exotic effects, such "
"as [Icon's searching over multiple "
"values](https://www2.cs.arizona.edu/icon/) and Scheme or Ruby's "
"continuations. Because monads can encode _any_ effect, programmers can "
"choose which ones are the best fit for a given application, rather than "
"being stuck with what the language developers provided."
msgstr ""
"并非每种语言都提供相同的效果。例如，只有某些语言有异常。其他语言具有独特的新奇效果，例如 [Icon "
"对多个值进行搜索](https://www2.cs.arizona.edu/icon/) 以及 Scheme 或 Ruby 的延续。由于 monad "
"可以编码任何效果，因此程序员可以选择最适合给定应用程序的效果，而不是局限于语言开发者提供的效果。"

#: src/monads/arithmetic.md:9
#, fuzzy
msgid ""
"One example of a program that can make sense in a variety of monads is an "
"evaluator for arithmetic expressions."
msgstr "一个可以在各种 monad 中有意义的程序示例是算术表达式的求值器。"

#: src/monads/arithmetic.md:11
#, fuzzy
msgid "Arithmetic Expressions"
msgstr "算术表达式"

#: src/monads/arithmetic.md:13
#, fuzzy
msgid ""
"An arithmetic expression is either a literal integer or a primitive binary "
"operator applied to two expressions. The operators are addition, "
"subtraction, multiplication, and division:"
msgstr "算术表达式要么是字面整数，要么是应用于两个表达式的原始二元运算符。运算符是加法、减法、乘法和除法："

#: src/monads/arithmetic.md:26
#, fuzzy
msgid "The expression `2 + 3` is represented:"
msgstr "表达式 `2 + 3` 表示为："

#: src/monads/arithmetic.md:33
#, fuzzy
msgid "and `14 / (45 - 5 * 9)` is represented:"
msgstr "而 `14 / (45 - 5 * 9)` 表示为："

#: src/monads/arithmetic.md:43
#, fuzzy
msgid ""
"Because expressions include division, and division by zero is undefined, "
"evaluation might fail. One way to represent failure is to use `Option`:"
msgstr "由于表达式包含除法，而除以零是未定义的，因此求值可能会失败。表示失败的一种方法是使用 `Option`："

#: src/monads/arithmetic.md:57
#, fuzzy
msgid ""
"This definition uses the `Monad Option` instance to propagate failures from "
"evaluating both branches of a binary operator. However, the function mixes "
"two concerns: evaluating subexpressions and applying a binary operator to "
"the results. It can be improved by splitting it into two functions:"
msgstr ""
"此定义使用 `Monad Option` "
"实例来传播从二元运算符的两个分支求值产生的失败。但是，该函数混合了两个问题：求值子表达式和将二元运算符应用于结果。可以通过将其拆分为两个函数来改进它："

#: src/monads/arithmetic.md:75
#, fuzzy
msgid ""
"Running `#eval evaluateOption fourteenDivided` yields `none`, as expected, "
"but this is not a very useful error message. Because the code was written "
"using `>>=` rather than by explicitly handling the `none` constructor, only "
"a small modification is required for it to provide an error message on "
"failure:"
msgstr ""
"运行 `#eval evaluateOption fourteenDivided` 会产生 "
"`none`，正如预期的那样，但这不是一个非常有用的错误消息。由于代码是使用 `>>=` 编写的，而不是显式处理 `none` "
"构造函数，因此只需进行少量修改即可在失败时提供错误消息："

#: src/monads/arithmetic.md:77
#, fuzzy
msgid ""
"```lean\n"
"def applyPrim : Arith → Int → Int → Except String Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"\n"
"def evaluateExcept : Expr Arith → Except String Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateExcept e1 >>= fun v1 =>\n"
"    evaluateExcept e2 >>= fun v2 =>\n"
"    applyPrim p v1 v2\n"
"```"
msgstr ""
"```lean\n"
"def applyPrim : Arith → Int → Int → Except String Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"\n"
"def evaluateExcept : Expr Arith → Except String Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateExcept e1 >>= fun v1 =>\n"
"    evaluateExcept e2 >>= fun v2 =>\n"
"    applyPrim p v1 v2\n"
"```"

#: src/monads/arithmetic.md:95
#, fuzzy
msgid ""
"The only difference is that the type signature mentions `Except String` "
"instead of `Option`, and the failing case uses `Except.error` instead of "
"`none`. By making `evaluate` polymorphic over its monad and passing it "
"`applyPrim` as an argument, a single evaluator becomes capable of both forms"
" of error reporting:"
msgstr ""
"唯一的区别是类型签名提到 `Except String` 而不是 `Option`，并且失败的情况使用 `Except.error` 而不是 "
"`none`。通过使 `evaluate` 在其单子上多态并将其作为参数传递给 `applyPrim`，单个求值器能够以两种形式进行错误报告："

#: src/monads/arithmetic.md:97
#, fuzzy
msgid ""
"```lean\n"
"def applyPrimOption : Arith → Int → Int → Option Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      none\n"
"    else pure (x / y)\n"
"\n"
"def applyPrimExcept : Arith → Int → Int → Except String Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def evaluateM [Monad m] (applyPrim : Arith → Int → Int → m Int): Expr Arith → m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applyPrim e1 >>= fun v1 =>\n"
"    evaluateM applyPrim e2 >>= fun v2 =>\n"
"    applyPrim p v1 v2\n"
"```"
msgstr "**applyPrimOption** 函数与 `evaluate` 的第一个版本类似，使用它时效果相同。"

#: src/monads/arithmetic.md:123
#, fuzzy
msgid ""
"Using it with `applyPrimOption` works just like the first version of "
"`evaluate`:"
msgstr "同样，使用 **applyPrimExcept** 函数时效果与带有错误消息的版本相同："

#: src/monads/arithmetic.md:130
#, fuzzy
msgid ""
"Similarly, using it with `applyPrimExcept` works just like the version with "
"error messages:"
msgstr ""
"```output info\n"
"Except.error \"尝试将 14 除以零\"\n"
"```"

#: src/monads/arithmetic.md:134
#, fuzzy
msgid ""
"```output info\n"
"Except.error \"Tried to divide 14 by zero\"\n"
"```"
msgstr ""
"代码仍有改进空间。**applyPrimOption** 和 **applyPrimExcept** "
"函数仅在除法处理上有所不同，可以将其提取到求值器的另一个参数中："

#: src/monads/arithmetic.md:138
#, fuzzy
msgid ""
"The code can still be improved. The functions `applyPrimOption` and "
"`applyPrimExcept` differ only in their treatment of division, which can be "
"extracted into another parameter to the evaluator:"
msgstr ""
"```lean\n"
"def applyDivOption (x : Int) (y : Int) : Option Int :=\n"
"    如果 y == 0 则\n"
"      无\n"
"    否则\n"
"      纯 (x / y)\n"
"\n"
"def applyDivExcept (x : Int) (y : Int) : Except String Int :=\n"
"    如果 y == 0 则\n"
"      Except.error s!\"尝试将 {x} 除以零\"\n"
"    否则\n"
"      纯 (x / y)\n"
"\n"
"def applyPrim [Monad m] (applyDiv : Int → Int → m Int) : Arith → Int → Int → m Int\n"
"  | Arith.plus, x, y => 纯 (x + y)\n"
"  | Arith.minus, x, y => 纯 (x - y)\n"
"  | Arith.times, x, y => 纯 (x * y)\n"
"  | Arith.div, x, y => applyDiv x y\n"
"\n"
"def evaluateM [Monad m] (applyDiv : Int → Int → m Int): Expr Arith → m Int\n"
"  | Expr.const i => 纯 i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applyDiv e1 >>= fun v1 =>\n"
"    evaluateM applyDiv e2 >>= fun v2 =>\n"
"    applyPrim applyDiv p v1 v2\n"
"```"

#: src/monads/arithmetic.md:140
msgid ""
"```lean\n"
"def applyDivOption (x : Int) (y : Int) : Option Int :=\n"
"    if y == 0 then\n"
"      none\n"
"    else pure (x / y)\n"
"\n"
"def applyDivExcept (x : Int) (y : Int) : Except String Int :=\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def applyPrim [Monad m] (applyDiv : Int → Int → m Int) : Arith → Int → Int → m Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y => applyDiv x y\n"
"\n"
"def evaluateM [Monad m] (applyDiv : Int → Int → m Int): Expr Arith → m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applyDiv e1 >>= fun v1 =>\n"
"    evaluateM applyDiv e2 >>= fun v2 =>\n"
"    applyPrim applyDiv p v1 v2\n"
"```"
msgstr ""

#: src/monads/arithmetic.md:165
#, fuzzy
msgid ""
"In this refactored code, the fact that the two code paths differ only in "
"their treatment of failure has been made fully apparent."
msgstr "在重构后的代码中，两个代码路径仅在对失败的处理上有所不同，这一事实已完全显而易见。"

#: src/monads/arithmetic.md:167
#, fuzzy
msgid "Further Effects"
msgstr "其他影响"

#: src/monads/arithmetic.md:169
#, fuzzy
msgid ""
"Failure and exceptions are not the only kinds of effects that can be "
"interesting when working with an evaluator. While division's only side "
"effect is failure, adding other primitive operators to the expressions make "
"it possible to express other effects."
msgstr "在使用求值器时，失败和异常并不是唯一可能引起兴趣的影响类型。虽然除法的唯一副作用是失败，但将其他原始运算符添加到表达式中可以表达其他影响。"

#: src/monads/arithmetic.md:172
#, fuzzy
msgid ""
"The first step is an additional refactoring, extracting division from the "
"datatype of primitives:"
msgstr "第一步是进行额外的重构，从原始数据类型中提取除法："

#: src/monads/arithmetic.md:183
#, fuzzy
msgid ""
"The name `CanFail` suggests that the effect introduced by division is "
"potential failure."
msgstr "名称 `CanFail` 表明除法引入的影响是潜在的失败。"

#: src/monads/arithmetic.md:185
#, fuzzy
msgid ""
"The second step is to broaden the scope of the division handler argument to "
"`evaluateM` so that it can process any special operator:"
msgstr "第二步是将除法处理程序参数的作用域扩展到 `evaluateM`，以便它可以处理任何特殊运算符："

#: src/monads/arithmetic.md:186
#, fuzzy
msgid ""
"```lean\n"
"def divOption : CanFail → Int → Int → Option Int\n"
"  | CanFail.div, x, y => if y == 0 then none else pure (x / y)\n"
"\n"
"def divExcept : CanFail → Int → Int → Except String Int\n"
"  | CanFail.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def applyPrim [Monad m] (applySpecial : special → Int → Int → m Int) : Prim special → Int → Int → m Int\n"
"  | Prim.plus, x, y => pure (x + y)\n"
"  | Prim.minus, x, y => pure (x - y)\n"
"  | Prim.times, x, y => pure (x * y)\n"
"  | Prim.other op, x, y => applySpecial op x y\n"
"\n"
"def evaluateM [Monad m] (applySpecial : special → Int → Int → m Int): Expr (Prim special) → m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applySpecial e1 >>= fun v1 =>\n"
"    evaluateM applySpecial e2 >>= fun v2 =>\n"
"    applyPrim applySpecial p v1 v2\n"
"```"
msgstr ""
"```lean\n"
"def divOption : CanFail → Int → Int → Option Int\n"
"  | CanFail.div, x, y => if y == 0 then none else pure (x / y)\n"
"\n"
"def divExcept : CanFail → Int → Int → Except String Int\n"
"  | CanFail.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def applyPrim [Monad m] (applySpecial : special → Int → Int → m Int) : Prim special → Int → Int → m Int\n"
"  | Prim.plus, x, y => pure (x + y)\n"
"  | Prim.minus, x, y => pure (x - y)\n"
"  | Prim.times, x, y => pure (x * y)\n"
"  | Prim.other op, x, y => applySpecial op x y\n"
"\n"
"def evaluateM [Monad m] (applySpecial : special → Int → Int → m Int): Expr (Prim special) → m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applySpecial e1 >>= fun v1 =>\n"
"    evaluateM applySpecial e2 >>= fun v2 =>\n"
"    applyPrim applySpecial p v1 v2\n"
"```"

#: src/monads/arithmetic.md:210
#, fuzzy
msgid "No Effects"
msgstr "无副作用"

#: src/monads/arithmetic.md:212
#, fuzzy
msgid ""
"The type `Empty` has no constructors, and thus no values, like the `Nothing`"
" type in Scala or Kotlin. In Scala and Kotlin, `Nothing` can represent "
"computations that never return a result, such as functions that crash the "
"program, throw exceptions, or always fall into infinite loops. An argument "
"to a function or method of type `Nothing` indicates dead code, as there will"
" never be a suitable argument value. Lean doesn't support infinite loops and"
" exceptions, but `Empty` is still useful as an indication to the type system"
" that a function cannot be called. Using the syntax `nomatch E` when `E` is "
"an expression whose type has no constructors indicates to Lean that the "
"current expression need not return a result, because it could never have "
"been called. "
msgstr ""
"`Empty` 类型没有构造函数，因此没有值，就像 Scala 或 Kotlin 中的 `Nothing` 类型。在 Scala 和 Kotlin "
"中，`Nothing` 可以表示永不返回结果的计算，例如导致程序崩溃、引发异常或始终陷入无限循环的函数。类型为 `Nothing` "
"的函数或方法的参数表示死代码，因为永远不会有合适的参数值。Lean 不支持无限循环和异常，但 `Empty` "
"仍然可作为指示类型系统函数不可调用的标志。当 `E` 是类型没有构造函数的表达式的表达式时，使用语法 `nomatch E` 向 Lean "
"指示当前表达式不需要返回结果，因为它永远不会被调用。"

#: src/monads/arithmetic.md:218
#, fuzzy
msgid ""
"Using `Empty` as the parameter to `Prim` indicates that there are no "
"additional cases beyond `Prim.plus`, `Prim.minus`, and `Prim.times`, because"
" it is impossible to come up with a value of type `Empty` to place in the "
"`Prim.other` constructor. Because a function to apply an operator of type "
"`Empty` to two integers can never be called, it doesn't need to return a "
"result. Thus, it can be used in _any_ monad:"
msgstr ""
"将 `Empty` 用作 `Prim` 的参数表示除了 `Prim.plus`、`Prim.minus` 和 `Prim.times` "
"之外没有其他情况，因为不可能想出一个 `Empty` 类型的值来放在 `Prim.other` 构造函数中。由于应用类型为 `Empty` "
"的运算符到两个整数的函数永远不会被调用，因此它不需要返回结果。因此，它可以在 _任何_ 单子中使用："

#: src/monads/arithmetic.md:225
#, fuzzy
msgid ""
"This can be used together with `Id`, the identity monad, to evaluate "
"expressions that have no effects whatsoever:"
msgstr "这可以与恒等单子 `Id` 一起使用，以计算没有任何副作用的表达式："

#: src/monads/arithmetic.md:234
#, fuzzy
msgid "Nondeterministic Search"
msgstr "非确定性搜索"

#: src/monads/arithmetic.md:236
#, fuzzy
msgid ""
"Instead of simply failing when encountering division by zero, it would also "
"be sensible to backtrack and try a different input. Given the right monad, "
"the very same `evaluateM` can perform a nondeterministic search for a _set_ "
"of answers that do not result in failure. This requires, in addition to "
"division, some means of specifying a choice of results. One way to do this "
"is to add a function `choose` to the language of expressions that instructs "
"the evaluator to pick either of its arguments while searching for non-"
"failing results."
msgstr ""
"遇到除以零时，除了直接失败之外，还可以回溯并尝试不同的输入。给定正确的单子，同一个 `evaluateM` 可以对不导致失败的答案 _集_ "
"执行非确定性搜索。除了除法之外，还需要一些指定结果选择的方法。一种方法是在表达式的语言中添加一个函数 "
"`choose`，指示求值器在搜索非失败结果时选择其任一参数。"

#: src/monads/arithmetic.md:241
#, fuzzy
msgid ""
"The result of the evaluator is now a multiset of values, rather than a "
"single value. The rules for evaluation into a multiset are:"
msgstr "求值结果现在是一个多重集，而不是一个单一值。求值到多重集的规则如下："

#: src/monads/arithmetic.md:243
#, fuzzy
msgid "Constants \\\\( n \\\\) evaluate to singleton sets \\\\( {n} \\\\)."
msgstr "常量 \\\\( n \\\\) 求值为单元素集 \\\\( {n} \\\\)。"

#: src/monads/arithmetic.md:244
#, fuzzy
msgid ""
"Arithmetic operators other than division are called on each pair from the "
"Cartesian product of the operators, so \\\\( X + Y \\\\) evaluates to \\\\( "
"\\\\{ x + y \\\\mid x ∈ X, y ∈ Y \\\\} \\\\)."
msgstr ""
"除法以外的算术运算符对运算符笛卡尔积中的每一对进行调用，所以 \\\\( X + Y \\\\) 求值为 \\\\( \\\\{ x + y "
"\\\\mid x ∈ X, y ∈ Y \\\\} \\\\)。"

#: src/monads/arithmetic.md:245
#, fuzzy
msgid ""
"Division \\\\( X / Y \\\\) evaluates to \\\\( \\\\{ x / y \\\\mid x ∈ X, y ∈"
" Y, y ≠ 0\\\\} \\\\). In other words, all \\\\( 0 \\\\) values in \\\\( Y "
"\\\\)  are thrown out."
msgstr ""
"除法 \\\\( X / Y \\\\) 求值为 \\\\( \\\\{ x / y \\\\mid x ∈ X, y ∈ Y, y ≠ 0\\\\} "
"\\\\)。换句话说，\\\\( Y \\\\) 中的所有 \\\\( 0 \\\\) 值都被丢弃。"

#: src/monads/arithmetic.md:246
#, fuzzy
msgid "A choice \\\\( \\\\mathrm{choose}(x, y) \\\\) evaluates to \\\\( \\\\{ x, y \\\\} \\\\)."
msgstr "一个选择 \\\\( \\\\mathrm{choose}(x, y) \\\\) 求值为 \\\\( \\\\{ x, y \\\\} \\\\)。"

#: src/monads/arithmetic.md:248
#, fuzzy
msgid ""
"For example, \\\\( 1 + \\\\mathrm{choose}(2, 5) \\\\) evaluates to \\\\( "
"\\\\{ 3, 6 \\\\} \\\\), \\\\(1 + 2 / 0 \\\\) evaluates to \\\\( \\\\{\\\\} "
"\\\\), and \\\\( 90 / (\\\\mathrm{choose}(-5, 5) + 5) \\\\) evaluates to "
"\\\\( \\\\{ 9 \\\\} \\\\). Using multisets instead of true sets simplifies "
"the code by removing the need to check for uniqueness of elements."
msgstr ""
"例如，\\\\( 1 + \\\\mathrm{choose}(2, 5) \\\\) 求值为 \\\\( \\\\{ 3, 6 \\\\} "
"\\\\)，\\\\(1 + 2 / 0 \\\\) 求值为 \\\\( \\\\{\\\\} \\\\)，\\\\( 90 / "
"(\\\\mathrm{choose}(-5, 5) + 5) \\\\) 求值为 \\\\( \\\\{ 9 \\\\} "
"\\\\)。使用多重集代替真集简化了代码，无需再检查元素的唯一性。"

#: src/monads/arithmetic.md:251
#, fuzzy
msgid ""
"A monad that represents this non-deterministic effect must be able to "
"represent a situation in which there are no answers, and a situation in "
"which there is at least one answer together with any remaining answers:"
msgstr "表示这种非确定性效果的单子必须能够表示没有答案的情况，以及至少有一个答案和任何剩余答案的情况："

#: src/monads/arithmetic.md:257
#, fuzzy
msgid ""
"This datatype looks very much like `List`. The difference is that where "
"`cons` stores the rest of the list, `more` stores a function that should "
"compute the next value on demand. This means that a consumer of `Many` can "
"stop the search when some number of results have been found."
msgstr ""
"此数据类型看起来非常像 `List`。不同之处在于，`cons` 存储列表的其余部分，而 `more` 存储一个函数，该函数应按需计算下一个值。这意味着"
" `Many` 的使用者可以在找到一定数量的结果后停止搜索。"

#: src/monads/arithmetic.md:261
#, fuzzy
msgid ""
"A single result is represented by a `more` constructor that returns no "
"further results:"
msgstr "单个结果由 `more` 构造器表示，该构造器不返回任何进一步的结果："

#: src/monads/arithmetic.md:265
#, fuzzy
msgid ""
"The union of two multisets of results can be computed by checking whether "
"the first multiset is empty. If so, the second multiset is the union. If "
"not, the union consists of the first element of the first multiset followed "
"by the union of the rest of the first multiset with the second multiset:"
msgstr ""
"两个结果多重集的并集可以通过检查第一个多重集是否为空来计算。如果是，则第二个多重集是并集。如果不是，则并集由第一个多重集的第一个元素后跟第一个多重集的其余部分与第二个多重集的并集组成："

#: src/monads/arithmetic.md:274
#, fuzzy
msgid ""
"It can be convenient to start a search process with a list of values. "
"`Many.fromList` converts a list into a multiset of results:"
msgstr "从值列表开始搜索过程会很方便。`Many.fromList` 将列表转换为结果的多重集合："

#: src/monads/arithmetic.md:281
#, fuzzy
msgid ""
"Similarly, once a search has been specified, it can be convenient to extract"
" either a number of values, or all the values:"
msgstr "同样，一旦指定了搜索，就可以方便地提取多个值或所有值："

#: src/monads/arithmetic.md:293
#, fuzzy
msgid ""
"A `Monad Many` instance requires a `bind` operator. In a nondeterministic "
"search, sequencing two operations consists of taking all possibilities from "
"the first step and running the rest of the program on each of them, taking "
"the union of the results. In other words, if the first step returns three "
"possible answers, the second step needs to be tried for all three. Because "
"the second step can return any number of answers for each input, taking "
"their union represents the entire search space."
msgstr ""
"`Monad Many` 实例需要一个 `bind` "
"运算符。在非确定性搜索中，对两个操作进行排序包括从第一步中获取所有可能性，并在每个可能性上运行程序的其余部分，取结果的并集。换句话说，如果第一步返回三个可能的答案，则需要对所有三个答案尝试第二步。由于第二步可以为每个输入返回任意数量的答案，因此取它们的并集表示整个搜索空间。"

#: src/monads/arithmetic.md:305
#, fuzzy
msgid ""
"`Many.one` and `Many.bind` obey the monad contract. To check that `Many.bind"
" (Many.one v) f` is the same as `f v`, start by evaluating the expression as"
" far as possible:"
msgstr ""
"`Many.one` 和 `Many.bind` 遵循 monad 契约。要检查 `Many.bind (Many.one v) f` 是否与 `f "
"v` 相同，首先尽可能地计算表达式："

#: src/monads/arithmetic.md:316
#, fuzzy
msgid ""
"The empty multiset is a right identity of `union`, so the answer is "
"equivalent to `f v`. To check that `Many.bind v Many.one` is the same as "
"`v`, consider that `bind` takes the union of applying `Many.one` to each "
"element of `v`. In other words, if `v` has the form `{v1, v2, v3, ..., vn}`,"
" then `Many.bind v Many.one` is `{v1} ∪ {v2} ∪ {v3} ∪ ... ∪ {vn}`, which is "
"`{v1, v2, v3, ..., vn}`."
msgstr ""
"空多重集合是 `union` 的右单位，因此答案等同于 `f v`。要检查 `Many.bind v Many.one` 是否与 `v` 相同，请考虑 "
"`bind` 取 `Many.one` 应用于 `v` 的每个元素的并集。换句话说，如果 `v` 的形式为 `{v1, v2, v3, ..., "
"vn}`，则 `Many.bind v Many.one` 为 `{v1} ∪ {v2} ∪ {v3} ∪ ... ∪ {vn}`，即 `{v1, "
"v2, v3, ..., vn}`。"

#: src/monads/arithmetic.md:320
#, fuzzy
msgid ""
"Finally, to check that `Many.bind` is associative, check that `Many.bind "
"(Many.bind bind v f) g` is the same as `Many.bind v (fun x => Many.bind (f "
"x) g)`. If `v` has the form `{v1, v2, v3, ..., vn}`, then:"
msgstr ""
"最后，要检查 `Many.bind` 是否关联，请检查 `Many.bind (Many.bind bind v f) g` 是否与 "
"`Many.bind v (fun x => Many.bind (f x) g)` 相同。如果 `v` 的形式为 `{v1, v2, v3, ...,"
" vn}`，则："

#: src/monads/arithmetic.md:327
#, fuzzy
msgid "which means that"
msgstr "这意味着"

#: src/monads/arithmetic.md:337
#, fuzzy
msgid "Similarly,"
msgstr "同样地，"

#: src/monads/arithmetic.md:353
#, fuzzy
msgid "Thus, both sides are equal, so `Many.bind` is associative."
msgstr "因此，两边相等，所以 `Many.bind` 是结合的。"

#: src/monads/arithmetic.md:355
#, fuzzy
msgid "The resulting monad instance is:"
msgstr "由此产生的单子实例为："

#: src/monads/arithmetic.md:361
#, fuzzy
msgid ""
"An example search using this monad finds all the combinations of numbers in "
"a list that add to 15:"
msgstr "使用此单子的示例搜索可找到列表中所有加起来等于 15 的数字组合："

#: src/monads/arithmetic.md:377
#, fuzzy
msgid ""
"The search process is recursive over the list. The empty list is a "
"successful search when the goal is `0`; otherwise, it fails. When the list "
"is non-empty, there are two possibilities: either the head of the list is "
"greater than the goal, in which case it cannot participate in any successful"
" searches, or it is not, in which case it can. If the head of the list is "
"_not_ a candidate, then the search proceeds to the tail of the list. If the "
"head is a candidate, then there are two possibilities to be combined with "
"`Many.union`: either the solutions found contain the head, or they do not. "
"The solutions that do not contain the head are found with a recursive call "
"on the tail, while the solutions that do contain it result from subtracting "
"the head from the goal, and then attaching the head to the solutions that "
"result from the recursive call."
msgstr ""
"搜索过程对列表进行递归。当目标为 `0` "
"时，空列表是一个成功的搜索；否则，它将失败。当列表非空时，有两种可能性：列表的头部大于目标，在这种情况下，它不能参与任何成功的搜索，或者不是，在这种情况下，它可以。如果列表的头部"
" _不是_ 候选者，则搜索将继续进行到列表的尾部。如果头部是候选者，则有两个可能性与 `Many.union` "
"结合：找到的解包含头部，或者不包含。不包含头部的解通过对尾部进行递归调用找到，而包含头部的解则通过从目标中减去头部，然后将头部附加到递归调用产生的解中得到。"

#: src/monads/arithmetic.md:384
#, fuzzy
msgid ""
"Returning to the arithmetic evaluator that produces multisets of results, "
"the `both` and `neither` operators can be written as follows:"
msgstr "回到产生结果多重集的算术求值器，`both` 和 `neither` 运算符可以写成如下形式："

#: src/monads/arithmetic.md:398
#, fuzzy
msgid "Using these operators, the earlier examples can be evaluated:"
msgstr "使用这些运算符，可以对前面的示例进行求值："

#: src/monads/arithmetic.md:420
#, fuzzy
msgid "Custom Environments"
msgstr "自定义环境"

#: src/monads/arithmetic.md:422
#, fuzzy
msgid ""
"The evaluator can be made user-extensible by allowing strings to be used as "
"operators, and then providing a mapping from strings to a function that "
"implements them. For example, users could extend the evaluator with a "
"remainder operator or with one that returns the maximum of its two "
"arguments. The mapping from function names to function implementations is "
"called an _environment_."
msgstr ""
"可以通过允许将字符串用作运算符，然后提供从字符串到实现它们的函数的映射，使求值器可由用户扩展。例如，用户可以用余数运算符或返回其两个参数最大值的运算符来扩展求值器。从函数名称到函数实现的映射称为"
" _环境_。"

#: src/monads/arithmetic.md:426
#, fuzzy
msgid ""
"The environments needs to be passed in each recursive call. Initially, it "
"might seem that `evaluateM` needs an extra argument to hold the environment,"
" and that this argument should be passed to each recursive invocation. "
"However, passing an argument like this is another form of monad, so an "
"appropriate `Monad` instance allows the evaluator to be used unchanged."
msgstr ""
"环境需要在每次递归调用中传递。最初，`evaluateM` "
"似乎需要一个额外的参数来保存环境，并且该参数应该传递给每个递归调用。然而，像这样传递参数是单子的另一种形式，因此一个合适的 `Monad` "
"实例允许评估器保持不变。"

#: src/monads/arithmetic.md:430
#, fuzzy
msgid ""
"Using functions as a monad is typically called a _reader_ monad. When "
"evaluating expressions in the reader monad, the following rules are used:"
msgstr "将函数用作单子通常称为 _reader_ 单子。在 reader 单子中求值表达式时，使用以下规则："

#: src/monads/arithmetic.md:432
#, fuzzy
msgid "Constants \\\\( n \\\\) evaluate to constant functions \\\\( λ e . n \\\\),"
msgstr "常量 \\\\( n \\\\) 求值为常量函数 \\\\( λ e . n \\\\)；"

#: src/monads/arithmetic.md:433
#, fuzzy
msgid ""
"Arithmetic operators evaluate to functions that pass their arguments on, so "
"\\\\( f + g \\\\) evaluates to \\\\( λ e . f(e) + g(e) \\\\), and"
msgstr "算术运算符求值为将参数传递给它们的函数，因此 \\\\( f + g \\\\) 求值为 \\\\( λ e . f(e) + g(e) \\\\)；"

#: src/monads/arithmetic.md:434
#, fuzzy
msgid ""
"Custom operators evaluate to the result of applying the custom operator to "
"the arguments, so \\\\( f \\\\ \\\\mathrm{OP}\\\\ g \\\\) evaluates to "
"\\\\\\[ λ e . \\\\begin{cases} h(f(e), g(e)) & \\\\mathrm{if}\\\\ e\\\\ "
"\\\\mathrm{contains}\\\\ (\\\\mathrm{OP}, h) \\\\\\\\ 0 & "
"\\\\mathrm{otherwise} \\\\end{cases} \\\\\\] with \\\\( 0 \\\\) serving as a"
" fallback in case an unknown operator is applied."
msgstr ""
"自定义运算符求值为将自定义运算符应用于参数的结果，因此 \\\\( f \\\\ \\\\mathrm{OP}\\\\ g \\\\) 求值为 "
"\\\\\\[ λ e . \\\\begin{cases} h(f(e), g(e)) & \\\\mathrm{if}\\\\ e\\\\ "
"\\\\mathrm{contains}\\\\ (\\\\mathrm{OP}, h) \\\\\\\\ 0 & "
"\\\\mathrm{otherwise} \\\\end{cases} \\\\\\]，其中 \\\\( 0 \\\\) 在应用未知运算符时用作后备。"

#: src/monads/arithmetic.md:444
#, fuzzy
msgid ""
"To define the reader monad in Lean, the first step is to define the `Reader`"
" type and the effect that allows users to get ahold of the environment:"
msgstr "要在 Lean 中定义 reader 单子，第一步是定义 `Reader` 类型和允许用户获取环境的效果："

#: src/monads/arithmetic.md:450
#, fuzzy
msgid ""
"By convention, the Greek letter `ρ`, which is pronounced \"rho\", is used "
"for environments."
msgstr "按照惯例，希腊字母 `ρ`（发音为“rho”）用于表示环境。"

#: src/monads/arithmetic.md:452
#, fuzzy
msgid ""
"The fact that constants in arithmetic expressions evaluate to constant "
"functions suggests that the appropriate definition of `pure` for `Reader` is"
" a a constant function:"
msgstr "算术表达式中的常量求值为常量函数这一事实表明，`Reader` 的 `pure` 的适当定义是一个常量函数："

#: src/monads/arithmetic.md:457
#, fuzzy
msgid ""
"On the other hand, `bind` is a bit tricker. Its type is `Reader ρ α → (α → "
"Reader ρ β) → Reader ρ β`. This type can be easier to understand by "
"expanding the definitions of `Reader`, which yields `(ρ → α) → (α → ρ → β) →"
" ρ → β`. It should take an environment-accepting function as its first "
"argument, while the second argument should transform the result of the "
"environment-accepting function into yet another environment-accepting "
"function. The result of combining these is itself a function, waiting for an"
" environment."
msgstr ""
"另一方面，`bind` 有点棘手。它的类型是 `Reader ρ α → (α → Reader ρ β) → Reader ρ β`。通过展开 "
"`Reader` 的定义，可以更容易地理解此类型，从而产生 `(ρ → α) → (α → ρ → β) → ρ → "
"β`。它应该将接受环境的函数作为其第一个参数，而第二个参数应该将接受环境的函数的结果转换为另一个接受环境的函数。组合这些结果本身就是一个函数，等待一个环境。"

#: src/monads/arithmetic.md:463
#, fuzzy
msgid ""
"It's possible to use Lean interactively to get help writing this function. "
"The first step is to write down the arguments and return type, being very "
"explicit in order to get as much help as possible, with an underscore for "
"the definition's body:"
msgstr "交互式使用 Lean 可以获得编写此函数的帮助。第一步是写下参数和返回类型，为了获得尽可能多的帮助，需要非常明确，用下划线表示定义的主体："

#: src/monads/arithmetic.md:470
#, fuzzy
msgid ""
"Lean provides a message that describes which variables are available in "
"scope, and the type that's expected for the result. The `⊢` symbol, called a"
" _turnstile_ due to its resemblance to subway entrances, separates the local"
" variables from the desired type, which is `ρ → β` in this message:"
msgstr ""
"Lean 提供了一条消息，描述了哪些变量在范围内可用，以及结果的预期类型。`⊢` "
"符号，由于它类似于地铁入口而被称为“转门”，将局部变量与所需类型分开，在此消息中为 `ρ → β`："

#: src/monads/arithmetic.md:481
#, fuzzy
msgid ""
"Because the return type is a function, a good first step is to wrap a `fun` "
"around the underscore:"
msgstr "由于返回类型是一个函数，因此一个好的第一步是在下划线周围包装一个 `fun`："

#: src/monads/arithmetic.md:487
#, fuzzy
msgid ""
"The resulting message now shows the function's argument as a local variable:"
msgstr "现在，结果消息将函数的参数显示为局部变量："

#: src/monads/arithmetic.md:498
#, fuzzy
msgid ""
"The only thing in the context that can produce a `β` is `next`, and it will "
"require two arguments to do so. Each argument can itself be an underscore:"
msgstr "上下文中唯一可以生成 `β` 的是 `next`，它需要两个参数才能做到这一点。每个参数本身可以是一个下划线："

#: src/monads/arithmetic.md:505
#, fuzzy
msgid ""
"The two underscores have the following respective messages associated with "
"them:"
msgstr "两个下划线具有以下各自关联的消息："

#: src/monads/arithmetic.md:525
#, fuzzy
msgid ""
"Attacking the first underscore, only one thing in the context can produce an"
" `α`, namely `result`:"
msgstr "攻击第一个下划线，上下文中只有一件事可以生成 `α`，即 `result`："

#: src/monads/arithmetic.md:531
#, fuzzy
msgid "Now, both underscores have the same error:"
msgstr "现在，两个下划线都有相同的错误："

#: src/monads/arithmetic.md:541
#, fuzzy
msgid "Happily, both underscores can be replaced by `env`, yielding:"
msgstr "幸运的是，两个下划线都可以替换为 `env`，得到："

#: src/monads/arithmetic.md:548
#, fuzzy
msgid ""
"The final version can be obtained by undoing the expansion of `Reader` and "
"cleaning up the explicit details:"
msgstr "最终版本可以通过撤消 `Reader` 的展开并清理显式细节来获得："

#: src/monads/arithmetic.md:554
#, fuzzy
msgid ""
"It's not always possible to write correct functions by simply \"following "
"the types\", and it carries the risk of not understanding the resulting "
"program. However, it can also be easier to understand a program that has "
"been written than one that has not, and the process of filling in the "
"underscores can bring insights. In this case, `Reader.bind` works just like "
"`bind` for `Id`, except it accepts an additional argument that it then "
"passes down to its arguments, and this intuition can help in understanding "
"how it works."
msgstr ""
"仅仅“遵循类型”并不总是可以编写出正确的函数，并且有导致不理解结果程序的风险。然而，理解一个已经编写的程序也可能比理解一个没有编写的程序更容易，并且填写下划线的过程可以带来见解。在这种情况下，`Reader.bind`"
" 的工作方式与 `Id` 的 `bind` 完全相同，除了它接受一个额外的参数，然后将其传递给它的参数，并且这种直觉有助于理解它的工作原理。"

#: src/monads/arithmetic.md:558
#, fuzzy
msgid ""
"`Reader.pure`, which generates constant functions, and `Reader.bind` obey "
"the monad contract. To check that `Reader.bind (Reader.pure v) f` is the "
"same as `f v`, it's enough to replace definitions until the last step:"
msgstr ""
"`Reader.pure` 生成常量函数，`Reader.bind` 遵循单子契约。要检查 `Reader.bind (Reader.pure v) "
"f` 是否与 `f v` 相同，只需替换定义直到最后一步："

#: src/monads/arithmetic.md:571
#, fuzzy
msgid ""
"For every function `f`, `fun x => f x` is the same as `f`, so the first part"
" of the contract is satisfied. To check that `Reader.bind r Reader.pure` is "
"the same as `r`, a similar technique works:"
msgstr ""
"对于每个函数 `f`，`fun x => f x` 与 `f` 相同，因此契约的第一部分得到满足。要检查 `Reader.bind r "
"Reader.pure` 是否与 `r` 相同，可以使用类似的技术："

#: src/monads/arithmetic.md:582
#, fuzzy
msgid ""
"Because reader actions `r` are themselves functions, this is the same as "
"`r`. To check associativity, the same thing can be done for both "
"`Reader.bind (Reader.bind r f) g` and `Reader.bind r (fun x => Reader.bind "
"(f x) g)`:"
msgstr ""
"因为 reader 动作 `r` 本身是函数，所以这与 `r` 相同。要检查关联性，可以对 `Reader.bind (Reader.bind r f)"
" g` 和 `Reader.bind r (fun x => Reader.bind (f x) g)` 执行相同操作："

#: src/monads/arithmetic.md:606
#, fuzzy
msgid "Thus, a `Monad (Reader ρ)` instance is justified:"
msgstr "因此，`Monad (Reader ρ)` 实例是合理的："

#: src/monads/arithmetic.md:613
#, fuzzy
msgid ""
"The custom environments that will be passed to the expression evaluator can "
"be represented as lists of pairs:"
msgstr "将传递给表达式求值器的自定义环境可以表示为对列表："

#: src/monads/arithmetic.md:617
#, fuzzy
msgid "For instance, `exampleEnv` contains maximum and modulus functions:"
msgstr "例如，`exampleEnv` 包含最大值和模函数："

#: src/monads/arithmetic.md:618
#, fuzzy
msgid ""
"```lean\n"
"def exampleEnv : Env := [(\"max\", max), (\"mod\", (· % ·))]\n"
"```"
msgstr ""
"```lean\n"
"def exampleEnv : Env := [(\"max\", max), (\"mod\", (· % ·))]\n"
"```"

#: src/monads/arithmetic.md:622
#, fuzzy
msgid ""
"Lean already has a function `List.lookup` that finds the value associated "
"with a key in a list of pairs, so `applyPrimReader` needs only check whether"
" the custom function is present in the environment. It returns `0` if the "
"function is unknown:"
msgstr ""
"Lean 已经有一个函数 `List.lookup`，它在对列表中找到与键关联的值，因此 `applyPrimReader` "
"只需检查自定义函数是否存在于环境中。如果函数未知，它将返回 `0`："

#: src/monads/arithmetic.md:631
#, fuzzy
msgid ""
"Using `evaluateM` with `applyPrimReader` and an expression results in a "
"function that expects an environment. Luckily, `exampleEnv` is available:"
msgstr ""
"将 `evaluateM` 与 `applyPrimReader` 和表达式一起使用，将生成一个期望环境的函数。幸运的是，`exampleEnv` "
"可用："

#: src/monads/arithmetic.md:633
#, fuzzy
msgid ""
"```lean\n"
"open Expr Prim in\n"
"#eval evaluateM applyPrimReader (prim (other \"max\") (prim plus (const 5) (const 4)) (prim times (const 3) (const 2))) exampleEnv\n"
"```"
msgstr ""
"```lean\n"
"open Expr Prim in\n"
"#eval evaluateM applyPrimReader (prim (other \"max\") (prim plus (const 5) (const 4)) (prim times (const 3) (const 2))) exampleEnv\n"
"```"

#: src/monads/arithmetic.md:641
#, fuzzy
msgid ""
"Like `Many`, `Reader` is an example of an effect that is difficult to encode"
" in most languages, but type classes and monads make it just as convenient "
"as any other effect. The dynamic or special variables found in Common Lisp, "
"Clojure, and Emacs Lisp can be used like `Reader`. Similarly, Scheme and "
"Racket's parameter objects are an effect that exactly correspond to "
"`Reader`. The Kotlin idiom of context objects can solve a similar problem, "
"but they are fundamentally a means of passing function arguments "
"automatically, so this idiom is more like the encoding as a reader monad "
"than it is an effect in the language."
msgstr ""
"与 `Many` 一样，`Reader` 是一个难以在大多数语言中编码的效应示例，但类型类和单子使其与任何其他效应一样方便。Common "
"Lisp、Clojure 和 Emacs Lisp 中的动态或特殊变量可以用作 `Reader`。类似地，Scheme 和 Racket "
"的参数对象是一个与 `Reader` 完全对应的效应。Kotlin "
"的上下文对象惯用法可以解决类似的问题，但它们从根本上是一种自动传递函数参数的方法，因此这种惯用法更像是作为 reader "
"单子的编码，而不是语言中的效应。"

#: src/monads/arithmetic.md:648
#, fuzzy
msgid "Checking Contracts"
msgstr "检查合约"

#: src/monads/arithmetic.md:650
#, fuzzy
msgid "Check the monad contract for `State σ` and `Except ε`."
msgstr "检查 `State σ` 和 `Except ε` 的单子合约。"

#: src/monads/arithmetic.md:653
#, fuzzy
msgid "Readers with Failure"
msgstr "带有失败的 Reader"

#: src/monads/arithmetic.md:654
#, fuzzy
msgid ""
"Adapt the reader monad example so that it can also indicate failure when the"
" custom operator is not defined, rather than just returning zero. In other "
"words, given these definitions:"
msgstr "调整 Reader 单子示例，使其在自定义运算符未定义时也能指示失败，而不仅仅是返回零。换句话说，给定以下定义："

#: src/monads/arithmetic.md:661
#, fuzzy
msgid "do the following:"
msgstr "执行以下操作："

#: src/monads/arithmetic.md:662
#, fuzzy
msgid "Write suitable `pure` and `bind` functions"
msgstr "编写合适的 `pure` 和 `bind` 函数"

#: src/monads/arithmetic.md:663
#, fuzzy
msgid "Check that these functions satisfy the `Monad` contract"
msgstr "检查这些函数是否满足 `Monad` 合约"

#: src/monads/arithmetic.md:664
#, fuzzy
msgid "Write `Monad` instances for `ReaderOption` and `ReaderExcept`"
msgstr "为 `ReaderOption` 和 `ReaderExcept` 编写 `Monad` 实例"

#: src/monads/arithmetic.md:665
#, fuzzy
msgid ""
"Define suitable `applyPrim` operators and test them with `evaluateM` on some"
" example expressions"
msgstr "定义合适的 `applyPrim` 运算符，并使用 `evaluateM` 在一些示例表达式上对其进行测试"

#: src/monads/arithmetic.md:667
#, fuzzy
msgid "A Tracing Evaluator"
msgstr "一个跟踪求值器"

#: src/monads/arithmetic.md:669
#, fuzzy
msgid ""
"The `WithLog` type can be used with the evaluator to add optional tracing of"
" some operations. In particular, the type `ToTrace` can serve as a signal to"
" trace a given operator:"
msgstr "`WithLog` 类型可以与求值器一起使用，以添加对某些操作的可选跟踪。特别是，`ToTrace` 类型可以作为跟踪给定运算符的信号："

#: src/monads/arithmetic.md:675
#, fuzzy
msgid ""
"For the tracing evaluator, expressions should have type `Expr (Prim (ToTrace"
" (Prim Empty)))`. This says that the operators in the expression consist of "
"addition, subtraction, and multiplication, augmented with traced versions of"
" each. The innermost argument is `Empty` to signal that there are no further"
" special operators inside of `trace`, only the three basic ones."
msgstr ""
"对于跟踪求值器，表达式应具有类型 `Expr (Prim (ToTrace (Prim "
"Empty)))`。这意味着表达式中的运算符包括加法、减法和乘法，并带有每个运算符的跟踪版本。最内层的参数是 `Empty`，表示 `trace` "
"中没有其他特殊运算符，只有三个基本运算符。"

#: src/monads/arithmetic.md:678
#, fuzzy
msgid "Do the following:"
msgstr "执行以下操作："

#: src/monads/arithmetic.md:679
#, fuzzy
msgid "Implement a `Monad (WithLog logged)` instance"
msgstr "实现 `Monad (WithLog logged)` 实例"

#: src/monads/arithmetic.md:680
#, fuzzy
msgid ""
"Write an `applyTraced` function to apply traced operators to their "
"arguments, logging both the operator and the arguments, with type `ToTrace "
"(Prim Empty) → Int → Int → WithLog (Prim Empty × Int × Int) Int`"
msgstr ""
"编写 `applyTraced` 函数，将跟踪运算符应用于其参数，同时记录运算符和参数，类型为 `ToTrace (Prim Empty) → Int "
"→ Int → WithLog (Prim Empty × Int × Int) Int`"

#: src/monads/arithmetic.md:682
#, fuzzy
msgid "If the exercise has been completed correctly, then"
msgstr "如果练习已正确完成，那么"

#: src/monads/arithmetic.md:687
#, fuzzy
msgid "should result in"
msgstr "将导致"

#: src/monads/arithmetic.md:692
#, fuzzy
msgid ""
"Hint: values of type `Prim Empty` will appear in the resulting log. In order"
" to display them as a result of `#eval`, the following instances are "
"required:"
msgstr "提示：`Prim Empty` 类型的将在结果日志中出现。为了将它们显示为 `#eval` 的结果，需要以下实例："
