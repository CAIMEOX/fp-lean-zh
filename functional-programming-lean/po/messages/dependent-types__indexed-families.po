#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/dependent-types/indexed-families.md:3
#, fuzzy
msgid ""
"Polymorphic inductive types take type arguments. For instance, `List` takes "
"an argument that determines the type of the entries in the list, and "
"`Except` takes arguments that determine the types of the exceptions or "
"values. These type arguments, which are the same in every constructor of the"
" datatype, are referred to as _parameters_."
msgstr ""
"多态归纳类型接受类型参数。例如，`List` 接受一个参数来确定列表中条目的类型，而 `Except` "
"接受一个参数来确定异常或值的类型。这些类型参数在数据类型的每个构造函数中都是相同的，称为“参数”。"

#: src/dependent-types/indexed-families.md:7
#, fuzzy
msgid ""
"Arguments to inductive types need not be the same in every constructor, "
"however. Inductive types in which the arguments to the type vary based on "
"the choice of constructor are called _indexed families_, and the arguments "
"that vary are referred to as _indices_. The \"hello world\" of indexed "
"families is a type of lists that contains the length of the list in addition"
" to the type of entries, conventionally referred to as \"vectors\":"
msgstr ""
"然而，归纳类型的参数不必在每个构造函数中都相同。参数根据构造函数的选择而变化的归纳类型称为“索引族”，而变化的参数称为“索引”。索引族的“hello "
"world”是一种列表类型，除了条目类型之外，还包含列表的长度，通常称为“向量”："

#: src/dependent-types/indexed-families.md:16
#, fuzzy
msgid ""
"Function declarations may take some arguments before the colon, indicating "
"that they are available in the entire definition, and some arguments after, "
"indicating a desire to pattern-match on them and define the function case by"
" case. Inductive datatypes have a similar principle: the argument `α` is "
"named at the top of the datatype declaration, prior to the colon, which "
"indicates that it is a parameter that must be provided as the first argument"
" in all occurrences of `Vect` in the definition, while the `Nat` argument "
"occurs after the colon, indicating that it is an index that may vary. "
"Indeed, the three occurrences of `Vect` in the `nil` and `cons` constructor "
"declarations consistently provide `α` as the first argument, while the "
"second argument is different in each case."
msgstr ""
"函数声明可以在冒号之前接受一些参数，表示它们在整个定义中可用，并在冒号之后接受一些参数，表示希望对它们进行模式匹配并逐个定义函数。归纳数据类型有一个类似的原则：参数"
" `α` 在数据类型声明的顶部，在冒号之前命名，这表示它是一个必须在定义中所有 `Vect` 的第一个参数中提供的参数，而 `Nat` "
"参数出现在冒号之后，表示它是一个可能变化的索引。事实上，`nil` 和 `cons` 构造函数声明中 `Vect` 的三个出现始终将 `α` "
"提供为第一个参数，而第二个参数在每种情况下都不同。"

#: src/dependent-types/indexed-families.md:20
#, fuzzy
msgid ""
"The declaration of `nil` states that it is a constructor of type `Vect α 0`."
" This means that using `Vect.nil` in a context expecting a `Vect String 3` "
"is a type error, just as `[1, 2, 3]` is a type error in a context that "
"expects a `List String`:"
msgstr ""
"`nil` 的声明表明它是一个类型 `Vect α 0` 的构造器。这意味着在期望 `Vect String 3` 的上下文中使用 `Vect.nil`"
" 是一个类型错误，就像 `[1, 2, 3]` 在期望 `List String` 的上下文中是一个类型错误一样："

#: src/dependent-types/indexed-families.md:33
#, fuzzy
msgid ""
"The mismatch between `0` and `3` in this example plays exactly the same role"
" as any other type mismatch, even though `0` and `3` are not themselves "
"types."
msgstr "此示例中 `0` 和 `3` 之间的错配与任何其他类型错配的作用完全相同，即使 `0` 和 `3` 本身不是类型。"

#: src/dependent-types/indexed-families.md:35
#, fuzzy
msgid ""
"Indexed families are called _families_ of types because different index "
"values can make different constructors available for use. In some sense, an "
"indexed family is not a type; rather, it is a collection of related types, "
"and the choice of index values also chooses a type from the collection. "
"Choosing the index `5` for `Vect` means that only the constructor `cons` is "
"available, and choosing the index `0` means that only `nil` is available."
msgstr ""
"索引族被称为类型的“族”，因为不同的索引值可以使不同的构造器可供使用。从某种意义上说，索引族不是类型；相反，它是一组相关类型的集合，并且索引值的选取也从集合中选取了一个类型。为"
" `Vect` 选择索引 `5` 意味着只有构造器 `cons` 可用，而选择索引 `0` 意味着只有 `nil` 可用。"

#: src/dependent-types/indexed-families.md:39
#, fuzzy
msgid ""
"If the index is not yet known (e.g. because it is a variable), then no "
"constructor can be used until it becomes known. Using `n` for the length "
"allows neither `Vect.nil` nor `Vect.cons`, because there's no way to know "
"whether the variable `n` should stand for a `Nat` that matches `0` or `n + "
"1`:"
msgstr ""
"如果索引尚未知道（例如，因为它是一个变量），那么在它变得已知之前，不能使用任何构造器。对长度使用 `n` 既不允许 `Vect.nil` 也不允许 "
"`Vect.cons`，因为无法知道变量 `n` 是否应该代表与 `0` 或 `n + 1` 匹配的 `Nat`："

#: src/dependent-types/indexed-families.md:52
msgid ""
"```lean\n"
"example : Vect String n := Vect.cons \"Hello\" (Vect.cons \"world\" Vect.nil)\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:55
msgid ""
"```output error\n"
"type mismatch\n"
"  Vect.cons \"Hello\" (Vect.cons \"world\" Vect.nil)\n"
"has type\n"
"  Vect String (0 + 1 + 1) : Type\n"
"but is expected to have type\n"
"  Vect String n : Type\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:64
#, fuzzy
msgid ""
"Having the length of the list as part of its type means that the type "
"becomes more informative. For example, `Vect.replicate` is a function that "
"creates a `Vect` with a number of copies of a given value. The type that "
"says this precisely is:"
msgstr ""
"将列表的长度作为其类型的一部分意味着类型变得更有信息性。例如，`Vect.replicate` 是一个创建具有给定值副本的 `Vect` "
"的函数。确切地说出这一点的类型是："

#: src/dependent-types/indexed-families.md:70
#, fuzzy
msgid ""
"The argument `n` appears as the length of the result. The message associated"
" with the underscore placeholder describes the task at hand:"
msgstr "参数 `n` 显示为结果的长度。与下划线占位符关联的消息描述了手头的任务："

#: src/dependent-types/indexed-families.md:81
#, fuzzy
msgid ""
"When working with indexed families, constructors can only be applied when "
"Lean can see that the constructor's index matches the index in the expected "
"type. However, neither constructor has an index that matches `n`—`nil` "
"matches `Nat.zero`, and `cons` matches `Nat.succ`. Just as in the example "
"type errors, the variable `n` could stand for either, depending on which "
"`Nat` is provided to the function as an argument. The solution is to use "
"pattern matching to consider both of the possible cases:"
msgstr ""
"在处理索引族时，只有当 Lean 可以看到构造器的索引与预期类型中的索引匹配时，才能应用构造器。然而，这两个构造器都没有与 `n` "
"匹配的索引——`nil` 匹配 `Nat.zero`，而 `cons` 匹配 `Nat.succ`。就像在示例类型错误中一样，变量 `n` "
"可以代表这两个中的任何一个，具体取决于作为参数提供给函数的 `Nat`。解决方案是使用模式匹配来考虑这两种可能的情况："

#: src/dependent-types/indexed-families.md:91
#, fuzzy
msgid ""
"Because `n` occurs in the expected type, pattern matching on `n` _refines_ "
"the expected type in the two cases of the match. In the first underscore, "
"the expected type has become `Vect α 0`:"
msgstr ""
"由于 `n` 出现在预期类型中，因此对 `n` 进行模式匹配会根据匹配的两种情况来细化预期类型。在第一个下划线中，预期类型变为 `Vect α 0`："

#: src/dependent-types/indexed-families.md:101
#, fuzzy
msgid "In the second underscore, it has become `Vect α (k + 1)`:"
msgstr "在第二个下划线中，它变为 `Vect α (k + 1)`："

#: src/dependent-types/indexed-families.md:111
#, fuzzy
msgid ""
"When pattern matching refines the type of a program in addition to "
"discovering the structure of a value, it is called _dependent pattern "
"matching_."
msgstr "当模式匹配除了发现值结构之外还细化程序的类型时，它被称为 _依赖模式匹配_。"

#: src/dependent-types/indexed-families.md:113
#, fuzzy
msgid ""
"The refined type makes it possible to apply the constructors. The first "
"underscore matches `Vect.nil`, and the second matches `Vect.cons`: "
msgstr "细化的类型使得可以应用构造器。第一个下划线匹配 `Vect.nil`，第二个匹配 `Vect.cons`："

#: src/dependent-types/indexed-families.md:121
#, fuzzy
msgid ""
"The first underscore under the `.cons` should have type `α`. There is an `α`"
" available, namely `x`:"
msgstr "`.cons` 下面的第一个下划线应为类型 `α`。有一个可用的 `α`，即 `x`："

#: src/dependent-types/indexed-families.md:132
#, fuzzy
msgid ""
"The second underscore should be a `Vect α k`, which can be produced by a "
"recursive call to `replicate`:"
msgstr "第二个下划线应为 `Vect α k`，可以通过对 `replicate` 的递归调用来生成："

#: src/dependent-types/indexed-families.md:142
#, fuzzy
msgid "Here is the final definition of `replicate`:"
msgstr "以下是 `replicate` 的最终定义："

#: src/dependent-types/indexed-families.md:150
#, fuzzy
msgid ""
"In addition to providing assistance while writing the function, the "
"informative type of `Vect.replicate` also allows client code to rule out a "
"number of unexpected functions without having to read the source code. A "
"version of `replicate` for lists could produce a list of the wrong length:"
msgstr ""
"除了在编写函数时提供帮助之外，`Vect.replicate` 的信息类型还允许客户端代码排除许多意外函数，而无需阅读源代码。列表版本的 "
"`replicate` 可能会生成长度错误的列表："

#: src/dependent-types/indexed-families.md:158
#, fuzzy
msgid "However, making this mistake with `Vect.replicate` is a type error:"
msgstr "然而，对 `Vect.replicate` 进行此操作会产生类型错误："

#: src/dependent-types/indexed-families.md:177
#, fuzzy
msgid ""
"The function `List.zip` combines two lists by pairing the first entry in the"
" first list with the first entry in the second list, the second entry in the"
" first list with the second entry in the second list, and so forth. "
"`List.zip` can be used to pair the three highest peaks in the US state of "
"Oregon with the three highest peaks in Denmark:"
msgstr ""
"函数 `List.zip` "
"通过将第一个列表中的第一个条目与第二个列表中的第一个条目配对，将第一个列表中的第二个条目与第二个列表中的第二个条目配对，依此类推，来组合两个列表。`List.zip`"
" 可用于将美国俄勒冈州的三个最高峰与丹麦的三个最高峰配对："

#: src/dependent-types/indexed-families.md:179
msgid ""
"```lean\n"
"[\"Mount Hood\",\n"
" \"Mount Jefferson\",\n"
" \"South Sister\"].zip [\"Møllehøj\", \"Yding Skovhøj\", \"Ejer Bavnehøj\"]\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:184
#, fuzzy
msgid "The result is a list of three pairs:"
msgstr "结果是一个包含三个对的列表："

#: src/dependent-types/indexed-families.md:185
msgid ""
"```lean\n"
"[(\"Mount Hood\", \"Møllehøj\"),\n"
" (\"Mount Jefferson\", \"Yding Skovhøj\"),\n"
" (\"South Sister\", \"Ejer Bavnehøj\")]\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:190
#, fuzzy
msgid ""
"It's somewhat unclear what should happen when the lists have different "
"lengths. Like many languages, Lean chooses to ignore the extra entries in "
"one of the lists. For instance, combining the heights of the five highest "
"peaks in Oregon with those of the three highest peaks in Denmark yields "
"three pairs. In particular,"
msgstr ""
"当列表具有不同长度时，应该发生什么情况有点不明确。与许多语言一样，Lean "
"选择忽略其中一个列表中的额外条目。例如，将俄勒冈州五个最高峰的高度与丹麦三个最高峰的高度相结合，会产生三个对。特别是，"

#: src/dependent-types/indexed-families.md:202
#, fuzzy
msgid ""
"While this approach is convenient because it always returns an answer, it "
"runs the risk of throwing away data when the lists unintentionally have "
"different lengths. F# takes a different approach: its version of `List.zip` "
"throws an exception when the lengths don't match, as can be seen in this "
"`fsi` session:"
msgstr ""
"虽然这种方法很方便，因为它总是返回一个答案，但当列表意外具有不同长度时，它有丢弃数据风险。F# 采取了不同的方法：当长度不匹配时，其版本的 "
"`List.zip` 会引发异常，如在以下 `fsi` 会话中所示："

#: src/dependent-types/indexed-families.md:217
#, fuzzy
msgid ""
"This avoids accidentally discarding information, but crashing a program "
"comes with its own difficulties. The Lean equivalent, which would use the "
"`Option` or `Except` monads, would introduce a burden that may not be worth "
"the safety."
msgstr ""
"这避免了意外丢弃信息，但程序崩溃也带来了自己的困难。Lean 等价项（将使用 `Option` 或 `Except` "
"单子）会引入一种负担，这种负担可能不值得安全。"

#: src/dependent-types/indexed-families.md:220
#, fuzzy
msgid ""
"Using `Vect`, however, it is possible to write a version of `zip` with a "
"type that requires that both arguments have the same length:"
msgstr "但是，使用 `Vect`，可以编写一个 `zip` 版本，其类型要求两个参数具有相同的长度："

#: src/dependent-types/indexed-families.md:226
#, fuzzy
msgid ""
"This definition only has patterns for the cases where either both arguments "
"are `Vect.nil` or both arguments are `Vect.cons`, and Lean accepts the "
"definition without a \"missing cases\" error like the one that results from "
"a similar definition for `List`:"
msgstr ""
"此定义仅对两种情况具有模式：两种参数均为 `Vect.nil` 或两种参数均为 `Vect.cons`，并且 Lean 接受此定义，而不会出现类似于 "
"`List` 的类似定义产生的“缺少情况”错误："

#: src/dependent-types/indexed-families.md:237
#, fuzzy
msgid ""
"This is because the constructor used in the first pattern, `nil` or `cons`, "
"_refines_ the type checker's knowledge about the length `n`. When the first "
"pattern is `nil`, the type checker can additionally determine that the "
"length was `0`, so the only possible choice for the second pattern is `nil`."
" Similarly, when the first pattern is `cons`, the type checker can determine"
" that the length was `k+1` for some `Nat` `k`, so the only possible choice "
"for the second pattern is `cons`. Indeed, adding a case that uses `nil` and "
"`cons` together is a type error, because the lengths don't match:"
msgstr ""
"因为第一个模式中使用的构造器 `nil` 或 `cons` 会细化类型检查器对长度 `n` 的了解。当第一个模式为 `nil` "
"时，类型检查器还可以确定长度为 `0`，因此第二个模式的唯一可能选择是 `nil`。类似地，当第一个模式为 `cons` "
"时，类型检查器可以确定长度为某个 `Nat` `k` 的 `k+1`，因此第二个模式的唯一可能选择是 `cons`。实际上，添加同时使用 `nil` 和"
" `cons` 的情况是一个类型错误，因为长度不匹配："

#: src/dependent-types/indexed-families.md:255
#, fuzzy
msgid ""
"The refinement of the length can be observed by making `n` into an explicit "
"argument:"
msgstr "可以通过将 `n` 变成显式参数来观察长度的细化："

#: src/dependent-types/indexed-families.md:264
#, fuzzy
msgid ""
"Getting a feel for programming with dependent types requires experience, and"
" the exercises in this section are very important. For each exercise, try to"
" see which mistakes the type checker can catch, and which ones it can't, by "
"experimenting with the code as you go. This is also a good way to develop a "
"feel for the error messages."
msgstr ""
"获得使用依赖类型编程的感觉需要经验，本节中的练习非常重要。对于每个练习，尝试通过在进行过程中试验代码来查看类型检查器可以捕获哪些错误，哪些错误无法捕获。这也是培养对错误消息的感觉的好方法。"

#: src/dependent-types/indexed-families.md:268
#, fuzzy
msgid ""
"Double-check that `Vect.zip` gives the right answer when combining the three"
" highest peaks in Oregon with the three highest peaks in Denmark. Because "
"`Vect` doesn't have the syntactic sugar that `List` has, it can be helpful "
"to begin by defining `oregonianPeaks : Vect String 3` and `danishPeaks : "
"Vect String 3`."
msgstr ""
"仔细检查 `Vect.zip` 在将俄勒冈州的三个最高峰与丹麦的三个最高峰结合时是否给出了正确的答案。由于 `Vect` 没有 `List` "
"拥有的语法糖，因此首先定义 `oregonianPeaks : Vect String 3` 和 `danishPeaks : Vect String "
"3` 会很有帮助。"

#: src/dependent-types/indexed-families.md:271
#, fuzzy
msgid ""
"Define a function `Vect.map` with type `(α → β) → Vect α n → Vect β n`."
msgstr "定义一个类型为 `(α → β) → Vect α n → Vect β n` 的函数 `Vect.map`。"

#: src/dependent-types/indexed-families.md:273
#, fuzzy
msgid ""
"Define a function `Vect.zipWith` that combines the entries in a `Vect` one "
"at a time with a function. It should have the type `(α → β → γ) → Vect α n →"
" Vect β n → Vect γ n`."
msgstr ""
"定义一个函数 `Vect.zipWith`，它一次将 `Vect` 中的条目与一个函数结合起来。它的类型应该是 `(α → β → γ) → Vect "
"α n → Vect β n → Vect γ n`。"

#: src/dependent-types/indexed-families.md:276
#, fuzzy
msgid ""
"Define a function `Vect.unzip` that splits a `Vect` of pairs into a pair of "
"`Vect`s. It should have the type `Vect (α × β) n → Vect α n × Vect β n`."
msgstr ""
"定义一个函数 `Vect.unzip`，它将一个 `Vect` 对拆分为一对 `Vect`。它的类型应该是 `Vect (α × β) n → Vect"
" α n × Vect β n`。"

#: src/dependent-types/indexed-families.md:278
#, fuzzy
msgid ""
"Define a function `Vect.snoc` that adds an entry to the _end_ of a `Vect`. "
"Its type should be `Vect α n → α → Vect α (n + 1)` and `#eval Vect.snoc "
"(.cons \"snowy\" .nil) \"peaks\"` should yield `Vect.cons \"snowy\" "
"(Vect.cons \"peaks\" (Vect.nil))`. The name `snoc` is a traditional "
"functional programming pun: it is `cons` backwards."
msgstr ""
"定义一个函数 `Vect.snoc`，它在 `Vect` 的末尾添加一个条目。它的类型应该是 `Vect α n → α → Vect α (n + "
"1)`，并且 `#eval Vect.snoc (.cons \"snowy\" .nil) \"peaks\"` 应该生成 `Vect.cons "
"\"snowy\" (Vect.cons \"peaks\" (Vect.nil))`。`snoc` 这个名字是一个传统的函数式编程双关语：它是 "
"`cons` 的反向拼写。"

#: src/dependent-types/indexed-families.md:280
#, fuzzy
msgid "Define a function `Vect.reverse` that reverses the order of a `Vect`."
msgstr "定义一个函数 `Vect.reverse`，它反转 `Vect` 的顺序。"

#: src/dependent-types/indexed-families.md:282
#, fuzzy
msgid ""
"Define a function `Vect.drop` with the following type: `(n : Nat) → Vect α "
"(k + n) → Vect α k`. Verify that it works by checking that `#eval "
"danishPeaks.drop 2` yields `Vect.cons \"Ejer Bavnehøj\" (Vect.nil)`."
msgstr ""
"定义一个函数 `Vect.drop`，类型如下：`(n : Nat) → Vect α (k + n) → Vect α k`。通过检查 `#eval "
"danishPeaks.drop 2` 生成 `Vect.cons \"Ejer Bavnehøj\" (Vect.nil)` 来验证它是否有效。"

#: src/dependent-types/indexed-families.md:285
#, fuzzy
msgid ""
"Define a function `Vect.take` with type `(n : Nat) → Vect α (k + n) → Vect α"
" n` that returns the first `n` entries in the `Vect`. Check that it works on"
" an example."
msgstr ""
"定义一个类型为 `(n : Nat) → Vect α (k + n) → Vect α n` 的函数 `Vect.take`，它返回 `Vect` "
"中的前 `n` 个条目。通过一个示例检查它是否有效。"
