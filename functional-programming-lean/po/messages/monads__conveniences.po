#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/monads/conveniences.md:3
#, fuzzy
msgid "Shared Argument Types"
msgstr "共享参数类型"

#: src/monads/conveniences.md:5
#, fuzzy
msgid ""
"When defining a function that takes multiple arguments that have the same "
"type, both can be written before the same colon. For example,"
msgstr "在定义一个接受多个具有相同类型参数的函数时，可以在同一个冒号前编写这两个参数。例如，"

#: src/monads/conveniences.md:14
#, fuzzy
msgid "can be written"
msgstr "可以写成"

#: src/monads/conveniences.md:22
#, fuzzy
msgid "This is especially useful when the type signature is large."
msgstr "当类型签名较大时，这尤其有用。"

#: src/monads/conveniences.md:24
#, fuzzy
msgid "Leading Dot Notation"
msgstr "前导点表示法"

#: src/monads/conveniences.md:26
#, fuzzy
msgid ""
"The constructors of an inductive type are in a namespace. This allows "
"multiple related inductive types to use the same constructor names, but it "
"can lead to programs becoming verbose. In contexts where the inductive type "
"in question is known, the namespace can be omitted by preceding the "
"constructor's name with a dot, and Lean uses the expected type to resolve "
"the constructor names. For example, a function that mirrors a binary tree "
"can be written:"
msgstr ""
"归纳类型的构造函数位于一个命名空间中。这允许多个相关的归纳类型使用相同的构造函数名称，但可能导致程序变得冗长。在已知归纳类型的情况下，可以通过在构造函数名称前加上一个点来省略命名空间，并且"
" Lean 使用预期的类型来解析构造函数名称。例如，可以编写一个镜像二叉树的函数："

#: src/monads/conveniences.md:35
#, fuzzy
msgid ""
"Omitting the namespaces makes it significantly shorter, at the cost of "
"making the program harder to read in contexts like code review tools that "
"don't include the Lean compiler:"
msgstr "省略命名空间可以显著缩短代码，但代价是使程序在不包含 Lean 编译器的代码审查工具等上下文中更难阅读："

#: src/monads/conveniences.md:42
#, fuzzy
msgid ""
"Using the expected type of an expression to disambiguate a namespace is also"
" applicable to names other than constructors. If `BinTree.empty` is defined "
"as an alternative way of creating `BinTree`s, then it can also be used with "
"dot notation:"
msgstr ""
"使用表达式的预期类型来消除命名空间歧义也适用于除构造函数之外的其他名称。如果将 `BinTree.empty` 定义为创建 `BinTree` "
"的另一种方式，那么它也可以与点表示法一起使用："

#: src/monads/conveniences.md:53
#, fuzzy
msgid "Or-Patterns"
msgstr "或模式"

#: src/monads/conveniences.md:55
#, fuzzy
msgid ""
"In contexts that allow multiple patterns, such as `match`\\-expressions, "
"multiple patterns may share their result expressions. The datatype `Weekday`"
" that represents days of the week:"
msgstr "在允许多个模式的上下文中，例如 `match` 表达式，多个模式可以共享其结果表达式。表示一周中几天的数据类型 `Weekday`："

#: src/monads/conveniences.md:69
#, fuzzy
msgid "Pattern matching can be used to check whether a day is a weekend:"
msgstr "模式匹配可用于检查某天是否为周末："

#: src/monads/conveniences.md:77
#, fuzzy
msgid "This can already be simplified by using constructor dot notation:"
msgstr "使用构造器点表示法可以简化此操作："

#: src/monads/conveniences.md:85
#, fuzzy
msgid ""
"Because both weekend patterns have the same result expression (`true`), they"
" can be condensed into one:"
msgstr "由于两个周末模式具有相同的结果表达式（“true”），因此可以将它们合并为一个："

#: src/monads/conveniences.md:92
#, fuzzy
msgid ""
"This can be further simplified into a version in which the argument is not "
"named:"
msgstr "可以进一步简化为不命名参数的版本："

#: src/monads/conveniences.md:99
#, fuzzy
msgid ""
"Behind the scenes, the result expression is simply duplicated across each "
"pattern. This means that patterns can bind variables, as in this example "
"that removes the `inl` and `inr` constructors from a sum type in which both "
"contain the same type of value:"
msgstr ""
"在幕后，结果表达式只是在每个模式中重复。这意味着模式可以绑定变量，如本例中从和类型中删除 `inl` 和 `inr` "
"构造器，其中两者都包含相同类型的值："

#: src/monads/conveniences.md:105
#, fuzzy
msgid ""
"Because the result expression is duplicated, the variables bound by the "
"patterns are not required to have the same types. Overloaded functions that "
"work for multiple types may be used to write a single result expression that"
" works for patterns that bind variables of different types:"
msgstr ""
"由于结果表达式是重复的，因此模式绑定的变量不必具有相同的类型。适用于多种类型的高级函数可用于编写一个结果表达式，该表达式适用于绑定不同类型变量的模式："

#: src/monads/conveniences.md:107
msgid ""
"```lean\n"
"def stringy : Nat ⊕ Weekday → String\n"
"  | .inl x | .inr x => s!\"It is {repr x}\"\n"
"```"
msgstr ""

#: src/monads/conveniences.md:111
#, fuzzy
msgid ""
"In practice, only variables shared in all patterns can be referred to in the"
" result expression, because the result must make sense for each pattern. In "
"`getTheNat`, only `n` can be accessed, and attempts to use either `x` or `y`"
" lead to errors."
msgstr ""
"实际上，只有在所有模式中共享的变量才能在结果表达式中引用，因为结果必须对每个模式都有意义。在 `getTheNat` 中，只能访问 `n`，而尝试使用 "
"`x` 或 `y` 会导致错误。"

#: src/monads/conveniences.md:117
#, fuzzy
msgid ""
"Attempting to access `x` in a similar definition causes an error because "
"there is no `x` available in the second pattern:"
msgstr "尝试在类似定义中访问 `x` 会导致错误，因为第二个模式中没有 `x` 可用："

#: src/monads/conveniences.md:126
#, fuzzy
msgid ""
"The fact that the result expression is essentially copy-pasted to each "
"branch of the pattern match can lead to some surprising behavior. For "
"example, the following definitions are acceptable because the `inr` version "
"of the result expression refers to the global definition of `str`:"
msgstr ""
"结果表达式本质上是复制粘贴到模式匹配的每个分支，这可能会导致一些令人惊讶的行为。例如，以下定义是可以接受的，因为 `inr` 版本的结果表达式引用了 "
"`str` 的全局定义："

#: src/monads/conveniences.md:128
msgid ""
"```lean\n"
"def str := \"Some string\"\n"
"\n"
"def getTheString : (Nat × String) ⊕ (Nat × β) → String\n"
"  | .inl (n, str) | .inr (n, y) => str\n"
"```"
msgstr ""

#: src/monads/conveniences.md:134
#, fuzzy
msgid ""
"Calling this function on both constructors reveals the confusing behavior. "
"In the first case, a type annotation is needed to tell Lean which type `β` "
"should be:"
msgstr "对两个构造器调用此函数会显示令人困惑的行为。在第一种情况下，需要类型注释来告诉 Lean `β` 应该是什么类型："

#: src/monads/conveniences.md:136
msgid ""
"```lean\n"
"#eval getTheString (.inl (20, \"twenty\") : (Nat × String) ⊕ (Nat × String))\n"
"```"
msgstr ""

#: src/monads/conveniences.md:139
msgid ""
"```output info\n"
"\"twenty\"\n"
"```"
msgstr ""

#: src/monads/conveniences.md:142
#, fuzzy
msgid "In the second case, the global definition is used:"
msgstr "在第二种情况下，使用了全局定义："

#: src/monads/conveniences.md:143
msgid ""
"```lean\n"
"#eval getTheString (.inr (20, \"twenty\"))\n"
"```"
msgstr ""

#: src/monads/conveniences.md:146
msgid ""
"```output info\n"
"\"Some string\"\n"
"```"
msgstr ""

#: src/monads/conveniences.md:150
#, fuzzy
msgid ""
"Using or-patterns can vastly simplify some definitions and increase their "
"clarity, as in `Weekday.isWeekend`. Because there is a potential for "
"confusing behavior, it's a good idea to be careful when using them, "
"especially when variables of multiple types or disjoint sets of variables "
"are involved."
msgstr ""
"使用或模式可以极大地简化一些定义并提高其清晰度，如 "
"`Weekday.isWeekend`。由于存在混淆行为的可能性，因此在使用它们时最好小心，尤其是在涉及多种类型或不相交变量集的变量时。"
