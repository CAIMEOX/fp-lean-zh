#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/monad-transformers/summary.md:3
#, fuzzy
msgid "Combining Monads"
msgstr "组合单子"

#: src/monad-transformers/summary.md:5
#, fuzzy
msgid ""
"When writing a monad from scratch, there are design patterns that tend to "
"describe the ways that each effect is added to the monad. Reader effects are"
" added by having the monad's type be a function from the reader's "
"environment, state effects are added by including a function from the "
"initial state to the value paired with the final state, failure or "
"exceptions are added by including a sum type in the return type, and logging"
" or other output is added by including a product type in the return type. "
"Existing monads can be made part of the return type as well, allowing their "
"effects to be included in the new monad."
msgstr ""
"在从头开始编写单子时，有一些设计模式倾向于描述将每种效果添加到单子的方式。通过将单子的类型设为从读取器环境读取的函数来添加读取器效果，通过包含从初始状态到与最终状态配对的值的函数来添加状态效果，通过在返回类型中包含和类型来添加失败或异常，通过在返回类型中包含乘积类型来添加日志记录或其他输出。现有的单子也可以作为返回类型的一部分，从而允许将它们的效果包含在新单子中。"

#: src/monad-transformers/summary.md:9
#, fuzzy
msgid ""
"These design patterns are made into a library of reusable software "
"components by defining _monad transformers_, which add an effect to some "
"base monad. Monad transformers take the simpler monad types as arguments, "
"returning the enhanced monad types. At a minimum, a monad transformer should"
" provide the following instances:"
msgstr ""
"通过定义添加效果到某个基本单子的 "
"_单子转换器_，将这些设计模式制成可重用软件组件库。单子转换器将更简单的单子类型作为参数，返回增强的单子类型。最起码，单子转换器应提供以下实例："

#: src/monad-transformers/summary.md:13
#, fuzzy
msgid ""
"A `MonadLift` instance to translate an action from the inner monad to the "
"transformed monad"
msgstr "`MonadLift` 实例用于将操作从内部单子提升到转换后的单子"

#: src/monad-transformers/summary.md:15
#, fuzzy
msgid ""
"Monad transformers may be implemented as polymorphic structures or inductive"
" datatypes, but they are most often implemented as functions from the "
"underlying monad type to the enhanced monad type."
msgstr "单子转换器可以实现为多态结构或归纳数据类型，但最常实现为从底层单子类型到增强单子类型的函数。"

#: src/monad-transformers/summary.md:17
#, fuzzy
msgid "Type Classes for Effects"
msgstr "用于效果的类型类"

#: src/monad-transformers/summary.md:19
#, fuzzy
msgid ""
"A common design pattern is to implement a particular effect by defining a "
"monad that has the effect, a monad transformer that adds it to another "
"monad, and a type class that provides a generic interface to the effect. "
"This allows programs to be written that merely specify which effects they "
"need, so the caller can provide any monad that has the right effects."
msgstr ""
"一种常见的模式是通过定义具有效果的单子、添加该效果的单子转换器以及提供对该效果的通用接口的类型类来实现特定效果。这允许编写仅指定所需效果的程序，以便调用者可以提供具有正确效果的任何单子。"

#: src/monad-transformers/summary.md:22
#, fuzzy
msgid ""
"Sometimes, auxiliary type information (e.g. the state's type in a monad that"
" provides state, or the exception's type in a monad that provides "
"exceptions) is an output parameter, and sometimes it is not. The output "
"parameter is most useful for simple programs that use each kind of effect "
"only once, but it risks having the type checker commit to a the wrong type "
"too early when multiple instances of the same effect are used in a given "
"program. Thus, both versions are typically provided, with the ordinary-"
"parameter version of the type class having a name that ends in `-Of`."
msgstr ""
"有时，辅助类型信息（例如，提供状态的单子中的状态类型或提供异常的单子中的异常类型）是输出参数，有时则不是。输出参数最适用于仅使用每种效果一次的简单程序，但当给定程序中使用同一效果的多个实例时，它有风险让类型检查器过早地提交错误的类型。因此，通常提供两个版本，具有普通参数的类型类版本具有以"
" `-Of` 结尾的名称。"

#: src/monad-transformers/summary.md:26
#, fuzzy
msgid "Monad Transformers Don't Commute"
msgstr "单子转换器不可交换"

#: src/monad-transformers/summary.md:28
#, fuzzy
msgid ""
"It is important to note that changing the order of transformers in a monad "
"can change the meaning of programs that use the monad. For instance, re-"
"ordering `StateT` and `ExceptT` can result either in programs that lose "
"state modifications when exceptions are thrown or programs that keep "
"changes. While most imperative languages provide only the latter, the "
"increased flexibility provided by monad transformers demands thought and "
"attention to choose the correct variety for the task at hand."
msgstr ""
"需要注意的是，更改单子中转换器的顺序可能会改变使用该单子的程序的含义。例如，重新排序 `StateT` 和 `ExceptT` "
"可能会导致在抛出异常时丢失状态修改的程序或保留更改的程序。虽然大多数命令式语言仅提供后者，但单子转换器提供的灵活性要求对选择适合手头任务的正确类型进行思考和注意。"

#: src/monad-transformers/summary.md:32
#, fuzzy
msgid "`do`\\-Notation for Monad Transformers"
msgstr "**do** 符号用于单子变换器"

#: src/monad-transformers/summary.md:34
#, fuzzy
msgid ""
"Lean's `do`\\-blocks support early return, in which the block is terminated "
"with some value, locally mutable variables, `for`\\-loops with `break` and "
"`continue`, and single-branched `if`\\-statements. While this may seem to be"
" introducing imperative features that would get in the way of using Lean to "
"write proofs, it is in fact nothing more than a more convenient syntax for "
"certain common uses of monad transformers. Behind the scenes, whatever monad"
" the `do`\\-block is written in is transformed by appropriate uses of "
"`ExceptT` and `StateT` to support these additional effects."
msgstr ""
"Lean 的 **do** 块支持提前返回，其中块以某个值终止，局部可变变量，带有 **break** 和 **continue** 的 **for**"
" 循环，以及单分支 **if** 语句。虽然这似乎引入了命令式特性，会妨碍使用 Lean "
"编写证明，但实际上它只不过是对单子变换器某些常见用法的一种更方便的语法。在幕后，**do** 块所写的任何单子都会通过适当使用 **ExceptT** "
"和 **StateT** 来转换，以支持这些附加效果。"
