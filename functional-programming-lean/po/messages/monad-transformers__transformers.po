#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/monad-transformers/transformers.md:3
#, fuzzy
msgid ""
"`ReaderT` is far from the only useful monad transformer. This section "
"describes a number of additional transformers. Each monad transformer "
"consists of the following:"
msgstr "`ReaderT` 远非唯一有用的单子变换器。本节介绍了许多其他变换器。每个单子变换器包含以下内容："

#: src/monad-transformers/transformers.md:6
#, fuzzy
msgid ""
"A definition or datatype `T` that takes a monad as an argument. It should "
"have a type like `(Type u → Type v) → Type u → Type v`, though it may accept"
" additional arguments prior to the monad."
msgstr ""
"一个定义或数据类型 `T`，它将单子作为参数。它的类型应类似于 `(Type u → Type v) → Type u → Type "
"v`，尽管它可以在单子之前接受其他参数。"

#: src/monad-transformers/transformers.md:8
#, fuzzy
msgid ""
"A `Monad` instance for `T m` that relies on an instance of `Monad m`. This "
"enables the transformed monad to be used as a monad."
msgstr "一个 `Monad` 实例，用于 `T m`，它依赖于 `Monad m` 的实例。这使得变换后的单子可以用作单子。"

#: src/monad-transformers/transformers.md:9
#, fuzzy
msgid ""
"A `MonadLift` instance that translates actions of type `m α` into actions of"
" type `T m α`, for arbitrary monads `m`. This enables actions from the "
"underlying monad to be used in the transformed monad."
msgstr ""
"一个 `MonadLift` 实例，它将类型为 `m α` 的动作转换为类型为 `T m α` 的动作，适用于任意单子 "
"`m`。这使得可以将来自底层单子的动作用于变换后的单子。"

#: src/monad-transformers/transformers.md:11
#, fuzzy
msgid ""
"Furthermore, the `Monad` instance for the transformer should obey the "
"contract for `Monad`, at least if the underlying `Monad` instance does. In "
"addition, `monadLift (pure x)` should be equivalent to `pure x` in the "
"transformed monad, and `monadLift` should distribute over `bind` so that "
"`monadLift (x >>= f)` is the same as `monadLift x >>= fun y => monadLift (f "
"y)`."
msgstr ""
"此外，变换器的 `Monad` 实例应遵守 `Monad` 的契约，至少在底层 `Monad` 实例这样做时。此外，`monadLift (pure "
"x)` 在变换后的单子中应等同于 `pure x`，并且 `monadLift` 应分布在 `bind` 上，以便 `monadLift (x >>= "
"f)` 与 `monadLift x >>= fun y => monadLift (f y)` 相同。"

#: src/monad-transformers/transformers.md:14
#, fuzzy
msgid ""
"Many monad transformers additionally define type classes in the style of "
"`MonadReader` that describe the actual effects available in the monad. This "
"can provide more flexibility: it allows programs to be written that rely "
"only on an interface, and don't constrain the underlying monad to be "
"implemented by a given transformer. The type classes are a way for programs "
"to express their requirements, and monad transformers are a convenient way "
"to meet these requirements."
msgstr ""
"许多单子变换器还定义了类似于 `MonadReader` "
"的类型类，用于描述单子中可用的实际效果。这可以提供更大的灵活性：它允许编写仅依赖于接口的程序，并且不会限制底层单子由给定的变换器实现。类型类是程序表达其需求的一种方式，而单子变换器是满足这些需求的便捷方式。"

#: src/monad-transformers/transformers.md:19
#, fuzzy
msgid "Failure with `OptionT`"
msgstr "`OptionT` 的失败"

#: src/monad-transformers/transformers.md:21
#, fuzzy
msgid ""
"Failure, represented by the `Option` monad, and exceptions, represented by "
"the `Except` monad, both have corresponding transformers. In the case of "
"`Option`, failure can be added to a monad by having it contain values of "
"type `Option α` where it would otherwise contain values of type `α`. For "
"example, `IO (Option α)` represents `IO` actions that don't always return a "
"value of type `α`. This suggests the definition of the monad transformer "
"`OptionT`:"
msgstr ""
"由 `Option` 单子表示的失败和由 `Except` 单子表示的异常都有相应的变换器。对于 `Option`，可以通过让它包含类型为 "
"`Option α` 的值（在其他情况下它将包含类型为 `α` 的值）来将失败添加到单子中。例如，`IO (Option α)` 表示不总是返回类型为 "
"`α` 的值的 `IO` 操作。这表明了单子变换器 `OptionT` 的定义："

#: src/monad-transformers/transformers.md:30
#, fuzzy
msgid ""
"As an example of `OptionT` in action, consider a program that asks the user "
"questions. The function `getSomeInput` asks for a line of input and removes "
"whitespace from both ends. If the resulting trimmed input is non-empty, then"
" it is returned, but the function fails if there are no non-whitespace "
"characters:"
msgstr ""
"作为 `OptionT` 实际应用的示例，考虑一个向用户提问的程序。函数 `getSomeInput` "
"要求输入一行内容，并从两端删除空格。如果修剪后的输入非空，则返回它，但如果没有非空格字符，则函数失败："

#: src/monad-transformers/transformers.md:33
msgid ""
"```lean\n"
"def getSomeInput : OptionT IO String := do\n"
"  let input ← (← IO.getStdin).getLine\n"
"  let trimmed := input.trim\n"
"  if trimmed == \"\" then\n"
"    failure\n"
"  else pure trimmed\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:41
#, fuzzy
msgid ""
"This particular application tracks users with their name and their favorite "
"species of beetle:"
msgstr "此特定应用程序使用其姓名和最喜欢的甲虫种类跟踪用户："

#: src/monad-transformers/transformers.md:47
#, fuzzy
msgid ""
"Asking the user for input is no more verbose than a function that uses only "
"`IO` would be:"
msgstr "向用户询问输入的内容并不比仅使用 `IO` 的函数更冗长："

#: src/monad-transformers/transformers.md:48
msgid ""
"```lean\n"
"def getUserInfo : OptionT IO UserInfo := do\n"
"  IO.println \"What is your name?\"\n"
"  let name ← getSomeInput\n"
"  IO.println \"What is your favorite species of beetle?\"\n"
"  let beetle ← getSomeInput\n"
"  pure ⟨name, beetle⟩\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:56
#, fuzzy
msgid ""
"However, because the function runs in an `OptionT IO` context rather than "
"just in `IO`, failure in the first call to `getSomeInput` causes the whole "
"`getUserInfo` to fail, with control never reaching the question about "
"beetles. The main function, `interact`, invokes `getUserInfo` in a purely "
"`IO` context, which allows it to check whether the call succeeded or failed "
"by matching on the inner `Option`:"
msgstr ""
"但是，由于函数在 `OptionT IO` 上下文中而不是仅在 `IO` 中运行，因此在第一次调用 `getSomeInput` 时失败会导致整个 "
"`getUserInfo` 失败，并且控制权永远不会到达有关甲虫的问题。主函数 `interact` 在纯 `IO` 上下文中调用 "
"`getUserInfo`，这允许它通过匹配内部 `Option` 来检查调用是否成功或失败："

#: src/monad-transformers/transformers.md:58
msgid ""
"```lean\n"
"def interact : IO Unit := do\n"
"  match ← getUserInfo with\n"
"  | none => IO.eprintln \"Missing info\"\n"
"  | some ⟨name, beetle⟩ => IO.println s!\"Hello {name}, whose favorite beetle is {beetle}.\"\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:65
#, fuzzy
msgid "The Monad Instance"
msgstr "单子实例"

#: src/monad-transformers/transformers.md:67
#, fuzzy
msgid ""
"Writing the monad instance reveals a difficulty. Based on the types, `pure` "
"should use `pure` from the underlying monad `m` together with `some`. Just "
"as `bind` for `Option` branches on the first argument, propagating `none`, "
"`bind` for `OptionT` should run the monadic action that makes up the first "
"argument, branch on the result, and then propagate `none`. Following this "
"sketch yields the following definition, which Lean does not accept:"
msgstr ""
"编写单子实例时会遇到一个困难。根据类型，`pure` 应将基础单子 `m` 中的 `pure` 与 `some` 一起使用。正如 `Option` 的 "
"`bind` 分支在第一个参数上，传播 `none`，`OptionT` 的 `bind` 应运行构成第一个参数的单子操作，在结果上分支，然后传播 "
"`none`。按照此草图，会得到以下定义，而 Lean 无法接受："

#: src/monad-transformers/transformers.md:79
#, fuzzy
msgid "The error message shows a cryptic type mismatch:"
msgstr "错误消息显示了一个难以理解的类型不匹配："

#: src/monad-transformers/transformers.md:90
#, fuzzy
msgid ""
"The problem here is that Lean is selecting the wrong `Monad` instance for "
"the surrounding use of `pure`. Similar errors occur for the definition of "
"`bind`. One solution is to use type annotations to guide Lean to the correct"
" `Monad` instance:"
msgstr ""
"这里的问题是 Lean 为周围的 `pure` 用法选择了错误的 `Monad` 实例。`bind` "
"定义也会出现类似的错误。一种解决方案是使用类型注释来指导 Lean 使用正确的 `Monad` 实例："

#: src/monad-transformers/transformers.md:101
#, fuzzy
msgid ""
"While this solution works, it is inelegant and the code becomes a bit noisy."
msgstr "虽然此解决方案可行，但它不够优雅，并且代码会变得有点嘈杂。"

#: src/monad-transformers/transformers.md:103
#, fuzzy
msgid ""
"An alternative solution is to define functions whose type signatures guide "
"Lean to the correct instances. In fact, `OptionT` could have been defined as"
" a structure:"
msgstr "另一种解决方案是定义其类型签名指导 Lean 使用正确实例的函数。事实上，`OptionT` 可以定义为一个结构："

#: src/monad-transformers/transformers.md:109
#, fuzzy
msgid ""
"This would solve the problem, because the constructor `OptionT.mk` and the "
"field accessor `OptionT.run` would guide type class inference to the correct"
" instances. The downside to doing this is that structure values would need "
"to be allocated and deallocated repeatedly when running code that uses it, "
"while the direct definition is a compile-time-only feature. The best of both"
" worlds can be achieved by defining functions that serve the same role as "
"`OptionT.mk` and `OptionT.run`, but that work with the direct definition:"
msgstr ""
"这将解决问题，因为构造函数 `OptionT.mk` 和字段访问器 `OptionT.run` "
"将指导类型类推断到正确的实例。这样做的缺点是，在运行使用它的代码时，需要反复分配和释放结构值，而直接定义只是一个编译时特性。可以通过定义与 "
"`OptionT.mk` 和 `OptionT.run` 具有相同作用但适用于直接定义的函数来实现两全其美："

#: src/monad-transformers/transformers.md:117
#, fuzzy
msgid ""
"Both functions return their inputs unchanged, but they indicate the boundary"
" between code that is intended to present the interface of `OptionT` and "
"code that is intended to present the interface of the underlying monad `m`. "
"Using these helpers, the `Monad` instance becomes more readable:"
msgstr ""
"这两个函数都返回它们未更改的输入，但它们指示了打算呈现 `OptionT` 接口的代码与打算呈现底层单子 `m` "
"接口的代码之间的界限。使用这些帮助器，`Monad` 实例变得更具可读性："

#: src/monad-transformers/transformers.md:127
#, fuzzy
msgid ""
"Here, the use of `OptionT.mk` indicates that its arguments should be "
"considered as code that uses the interface of `m`, which allows Lean to "
"select the correct `Monad` instances."
msgstr "此处，使用 `OptionT.mk` 表示其参数应被视为使用 `m` 接口的代码，这允许 Lean 选择正确的 `Monad` 实例。"

#: src/monad-transformers/transformers.md:129
#, fuzzy
msgid ""
"After defining the monad instance, it's a good idea to check that the monad "
"contract is satisfied. The first step is to show that `bind (pure v) f` is "
"the same as `f v`. Here's the steps:"
msgstr "在定义单子实例后，最好检查单子契约是否得到满足。第一步是证明 `bind (pure v) f` 与 `f v` 相同。以下是步骤："

#: src/monad-transformers/transformers.md:189
#, fuzzy
msgid ""
"The second rule states that `bind w pure` is the same as `w`. To demonstrate"
" this, unfold the definitions of `bind` and `pure`, yielding:"
msgstr "第二条规则指出 `bind w pure` 与 `w` 相同。为了证明这一点，展开 `bind` 和 `pure` 的定义，得到："

#: src/monad-transformers/transformers.md:197
#, fuzzy
msgid ""
"In this pattern match, the result of both cases is the same as the pattern "
"being matched, just with `pure` around it. In other words, it is equivalent "
"to `w >>= fun y => pure y`, which is an instance of `m`'s second monad rule."
msgstr ""
"在此模式匹配中，两种情况的结果都与正在匹配的模式相同，只是周围有 `pure`。换句话说，它等效于 `w >>= fun y => pure y`，这是"
" `m` 的第二个单子规则的一个实例。"

#: src/monad-transformers/transformers.md:200
#, fuzzy
msgid ""
"The final rule states that `bind (bind v f) g`  is the same as `bind v (fun "
"x => bind (f x) g)`. It can be checked in the same way, by expanding the "
"definitions of `bind` and `pure` and then delegating to the underlying monad"
" `m`."
msgstr ""
"最后一条规则指出 `bind (bind v f) g` 与 `bind v (fun x => bind (f x) g)` 相同。可以通过展开 "
"`bind` 和 `pure` 的定义，然后委托给底层单子 `m` 来以相同的方式进行检查。"

#: src/monad-transformers/transformers.md:203
#, fuzzy
msgid "An `Alternative` Instance"
msgstr "`Alternative` 实例"

#: src/monad-transformers/transformers.md:205
#, fuzzy
msgid ""
"One convenient way to use `OptionT` is through the `Alternative` type class."
" Successful return is already indicated by `pure`, and the `failure` and "
"`orElse` methods of `Alternative` provide a way to write a program that "
"returns the first successful result from a number of subprograms:"
msgstr ""
"使用 `OptionT` 的一种便捷方法是通过 `Alternative` 类型类。`pure` 已经指示了成功的返回，而 `Alternative` "
"的 `failure` 和 `orElse` 方法提供了一种编写程序的方法，该程序从多个子程序中返回第一个成功的结果："

#: src/monad-transformers/transformers.md:217
#, fuzzy
msgid "Lifting"
msgstr "提升"

#: src/monad-transformers/transformers.md:219
#, fuzzy
msgid ""
"Lifting an action from `m` to `OptionT m` only requires wrapping `some` "
"around the result of the computation:"
msgstr "将一个动作从 `m` 提升到 `OptionT m` 只需要将计算结果用 `some` 包裹起来："

#: src/monad-transformers/transformers.md:227
#, fuzzy
msgid "Exceptions"
msgstr "异常"

#: src/monad-transformers/transformers.md:229
#, fuzzy
msgid ""
"The monad transformer version of `Except` is very similar to the monad "
"transformer version of `Option`. Adding exceptions of type `ε` to some "
"monadic action of type `m α` can be accomplished by adding exceptions to "
"`α`, yielding type `m (Except ε α)`:"
msgstr ""
"`Except` 的单子变换器版本与 `Option` 的单子变换器版本非常相似。向类型为 `m α` 的某个单子动作添加类型为 `ε` "
"的异常可以通过向 `α` 添加异常来完成，得到类型 `m (Except ε α)`："

#: src/monad-transformers/transformers.md:235
#, fuzzy
msgid ""
"`OptionT` provides `mk` and `run` functions to guide the type checker "
"towards the correct `Monad` instances. This trick is also useful for "
"`ExceptT`:"
msgstr ""
"`OptionT` 提供了 `mk` 和 `run` 函数来指导类型检查器指向正确的 `Monad` 实例。此技巧对 `ExceptT` 也有用："

#: src/monad-transformers/transformers.md:242
#, fuzzy
msgid ""
"The `Monad` instance for `ExceptT` is also very similar to the instance for "
"`OptionT`. The only difference is that it propagates a specific error value,"
" rather than `none`:"
msgstr ""
"`ExceptT` 的 `Monad` 实例也与 `OptionT` 的实例非常相似。唯一的区别是它传播一个特定的错误值，而不是 `none`："

#: src/monad-transformers/transformers.md:253
#, fuzzy
msgid ""
"The type signatures of `ExceptT.mk` and `ExceptT.run` contain a subtle "
"detail: they annotate the universe levels of `α` and `ε` explicitly. If they"
" are not explicitly annotated, then Lean generates a more general type "
"signature in which they have distinct polymorphic universe variables. "
"However, the definition of `ExceptT` expects them to be in the same "
"universe, because they can both be provided as arguments to `m`. This can "
"lead to a problem in the `Monad` instance where the universe level solver "
"fails to find a working solution:"
msgstr ""
"`ExceptT.mk` 和 `ExceptT.run` 的类型签名包含一个微妙的细节：它们明确地标注了 `α` 和 `ε` "
"的宇宙级别。如果它们没有被明确标注，那么 Lean 会生成一个更通用的类型签名，其中它们具有不同的多态宇宙变量。然而，`ExceptT` "
"的定义期望它们在同一个宇宙中，因为它们都可以作为 `m` 的参数提供。这可能会导致 `Monad` "
"实例出现问题，其中宇宙级别求解器无法找到一个可行的解决方案："

#: src/monad-transformers/transformers.md:275
#, fuzzy
msgid ""
"This kind of error message is typically caused by underconstrained universe "
"variables. Diagnosing it can be tricky, but a good first step is to look for"
" reused universe variables in some definitions that are not reused in "
"others."
msgstr ""
"这种类型的错误消息通常是由约束不足的宇宙变量引起的。诊断它可能很棘手，但一个好的第一步是查找某些定义中重复使用的宇宙变量，而其他定义中没有重复使用。"

#: src/monad-transformers/transformers.md:278
#, fuzzy
msgid ""
"Unlike `Option`, the `Except` datatype is typically not used as a data "
"structure. It is always used as a control structure with its `Monad` "
"instance. This means that it is reasonable to lift `Except ε` actions into "
"`ExceptT ε m`, as well as actions from the underlying monad `m`. Lifting "
"`Except` actions into `ExceptT` actions is done by wrapping them in `m`'s "
"`pure`, because an action that only has exception effects cannot have any "
"effects from the monad `m`:"
msgstr ""
"与 `Option` 不同，`Except` 数据类型通常不用作数据结构。它总是与它的 `Monad` 实例一起用作控制结构。这意味着将 `Except"
" ε` 动作提升到 `ExceptT ε m` 是合理的，以及从底层单子 `m` 中提升动作。将 `Except` 动作提升到 `ExceptT` "
"动作是通过将它们包装在 `m` 的 `pure` 中完成的，因为一个只有异常效果的动作不能有任何来自单子 `m` 的效果："

#: src/monad-transformers/transformers.md:286
#, fuzzy
msgid ""
"Because actions from `m` do not have any exceptions in them, their value "
"should be wrapped in `Except.ok`. This can be accomplished using the fact "
"that `Functor` is a superclass of `Monad`, so applying a function to the "
"result of any monadic computation can be accomplished using `Functor.map`:"
msgstr ""
"由于 `m` 中的动作不会引发任何异常，因此其值应包装在 `Except.ok` 中。这可以通过利用 `Functor` 是 `Monad` "
"的超类这一事实来实现，因此可以使用 `Functor.map` 将函数应用于任何单子计算的结果："

#: src/monad-transformers/transformers.md:293
#, fuzzy
msgid "Type Classes for Exceptions"
msgstr "异常类型类"

#: src/monad-transformers/transformers.md:295
#, fuzzy
msgid ""
"Exception handling fundamentally consists of two operations: the ability to "
"throw exceptions, and the ability to recover from them. Thus far, this has "
"been accomplished using the constructors of `Except` and pattern matching, "
"respectively. However, this ties a program that uses exceptions to one "
"specific encoding of the exception handling effect. Using a type class to "
"capture these operations allows a program that uses exceptions to be used in"
" _any_ monad that supports throwing and catching."
msgstr ""
"异常处理基本上包含两个操作：引发异常的能力和从异常中恢复的能力。到目前为止，这已分别使用 `Except` "
"的构造函数和模式匹配来完成。但是，这将使用异常的程序绑定到异常处理效果的一个特定编码。使用类型类来捕获这些操作允许使用异常的程序在支持引发和捕获的 "
"_任何_ 单子中使用。"

#: src/monad-transformers/transformers.md:300
#, fuzzy
msgid ""
"Throwing an exception should take an exception as an argument, and it should"
" be allowed in any context where a monadic action is requested. The \"any "
"context\" part of the specification can be written as a type by writing `m "
"α`—because there's no way to produce a value of any arbitrary type, the "
"`throw` operation must be doing something that causes control to leave that "
"part of the program. Catching an exception should accept any monadic action "
"together with a handler, and the handler should explain how to get back to "
"the action's type from an exception:"
msgstr ""
"引发异常应将异常作为参数，并且应允许在任何需要单子操作的上下文中使用它。规范的“任何上下文”部分可以通过编写 `m α` "
"作为类型来编写——因为无法生成任何任意类型的值，所以 `throw` "
"操作必须执行某些操作导致控制离开程序的该部分。捕获异常应接受任何单子操作和处理程序，并且处理程序应解释如何从异常返回到操作的类型："

#: src/monad-transformers/transformers.md:309
#, fuzzy
msgid ""
"The universe levels on `MonadExcept` differ from those of `ExceptT`. In "
"`ExceptT`, both `ε` and `α` have the same level, while `MonadExcept` imposes"
" no such limitation. This is because `MonadExcept` never places an exception"
" value inside of `m`. The most general universe signature recognizes the "
"fact that `ε` and `α` are completely independent in this definition. Being "
"more general means that the type class can be instantiated for a wider "
"variety of types."
msgstr ""
"`MonadExcept` 上的宇宙级别与 `ExceptT` 的宇宙级别不同。在 `ExceptT` 中，`ε` 和 `α` 都具有相同的级别，而 "
"`MonadExcept` 则没有这样的限制。这是因为 `MonadExcept` 永远不会将异常值放在 `m` 中。最通用的宇宙签名认识到 `ε` 和"
" `α` 在此定义中是完全独立的。更通用意味着类型类可以实例化更多种类的类型。"

#: src/monad-transformers/transformers.md:315
#, fuzzy
msgid ""
"An example program that uses `MonadExcept` is a simple division service. The"
" program is divided into two parts: a frontend that supplies a user "
"interface based on strings that handles errors, and a backend that actually "
"does the division. Both the frontend and the backend can throw exceptions, "
"the former for ill-formed input and the latter for division by zero errors. "
"The exceptions are an inductive type:"
msgstr ""
"一个使用 `MonadExcept` "
"的示例程序是一个简单的除法服务。该程序分为两部分：一个基于处理错误的字符串提供用户界面的前端，以及一个实际执行除法的后端。前端和后端都可能抛出异常，前者针对格式错误的输入，后者针对除以零的错误。异常是一种归纳类型："

#: src/monad-transformers/transformers.md:324
#, fuzzy
msgid "The backend checks for zero, and divides if it can:"
msgstr "后端检查零，如果可以，则进行除法："

#: src/monad-transformers/transformers.md:331
#, fuzzy
msgid ""
"The frontend's helper `asNumber` throws an exception if the string it is "
"passed is not a number. The overall frontend converts its inputs to `Int`s "
"and calls the backend, handling exceptions by returning a friendly string "
"error:"
msgstr ""
"前端的助手 `asNumber` 在传递给它的字符串不是数字时抛出异常。整个前端将其输入转换为 `Int` "
"并调用后端，通过返回友好的字符串错误来处理异常："

#: src/monad-transformers/transformers.md:333
msgid ""
"```lean\n"
"def asNumber [Monad m] [MonadExcept Err m] (s : String) : m Int :=\n"
"  match s.toInt? with\n"
"  | none => throw (.notANumber s)\n"
"  | some i => pure i\n"
"\n"
"def divFrontend [Monad m] [MonadExcept Err m] (n k : String) : m String :=\n"
"  tryCatch (do pure (toString (← divBackend (← asNumber n) (← asNumber k))))\n"
"    fun\n"
"      | .divByZero => pure \"Division by zero!\"\n"
"      | .notANumber s => pure s!\"Not a number: \\\"{s}\\\"\"\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:345
#, fuzzy
msgid ""
"Throwing and catching exceptions is common enough that Lean provides a "
"special syntax for using `MonadExcept`. Just as `+` is short for "
"`HAdd.hAdd`, `try` and `catch` can be used as shorthand for the `tryCatch` "
"method:"
msgstr ""
"抛出和捕获异常很常见，以至于 Lean 提供了一种特殊的语法来使用 `MonadExcept`。就像 `+` 是 `HAdd.hAdd` "
"的缩写一样，`try` 和 `catch` 可以用作 `tryCatch` 方法的缩写："

#: src/monad-transformers/transformers.md:347
msgid ""
"```lean\n"
"def divFrontend [Monad m] [MonadExcept Err m] (n k : String) : m String :=\n"
"  try\n"
"    pure (toString (← divBackend (← asNumber n) (← asNumber k)))\n"
"  catch\n"
"    | .divByZero => pure \"Division by zero!\"\n"
"    | .notANumber s => pure s!\"Not a number: \\\"{s}\\\"\"\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:356
#, fuzzy
msgid ""
"In addition to `Except` and `ExceptT`, there are useful `MonadExcept` "
"instances for other types that may not seem like exceptions at first glance."
" For example, failure due to `Option` can be seen as throwing an exception "
"that contains no data whatsoever, so there is an instance of `MonadExcept "
"Unit Option` that allows `try ... catch ...` syntax to be used with "
"`Option`."
msgstr ""
"除了 `Except` 和 `ExceptT` 之外，还有其他类型的有用的 `MonadExcept` 实例，乍一看可能不像异常。例如，由于 "
"`Option` 导致的失败可以看作抛出一个不包含任何数据的异常，因此有一个 `MonadExcept Unit Option` 实例，允许将 `try"
" ... catch ...` 语法与 `Option` 一起使用。"

#: src/monad-transformers/transformers.md:359
#, fuzzy
msgid "State"
msgstr "状态"

#: src/monad-transformers/transformers.md:361
#, fuzzy
msgid ""
"A simulation of mutable state is added to a monad by having monadic actions "
"accept a starting state as an argument and return a final state together "
"with their result. The bind operator for a state monad provides the final "
"state of one action as an argument to the next action, threading the state "
"through the program. This pattern can also be expressed as a monad "
"transformer:"
msgstr ""
"通过让单子操作接受一个起始状态作为参数并返回一个最终状态及其结果，将可变状态的模拟添加到单子中。状态单子的绑定运算符将一个操作的最终状态作为参数提供给下一个操作，从而将状态贯穿整个程序。此模式也可以表示为单子转换器："

#: src/monad-transformers/transformers.md:370
#, fuzzy
msgid ""
"Once again, the monad instance is very similar to that for `State`. The only"
" difference is that the input and output states are passed around and "
"returned in the underlying monad, rather than with pure code:"
msgstr "再次，单子实例与 `State` 非常相似。唯一的区别是输入和输出状态在底层单子中传递和返回，而不是使用纯代码："

#: src/monad-transformers/transformers.md:380
#, fuzzy
msgid ""
"The corresponding type class has `get` and `set` methods. One downside of "
"`get` and `set` is that it becomes too easy to `set` the wrong state when "
"updating it. This is because retrieving the state, updating it, and saving "
"the updated state is a natural way to write some programs. For example, the "
"following program counts the number of diacritic-free English vowels and "
"consonants in a string of letters:"
msgstr ""
"对应的类型类具有 `get` 和 `set` 方法。`get` 和 `set` 的一个缺点是更新状态时很容易 `set` "
"错误的状态。这是因为检索状态、更新状态和保存更新后的状态是编写某些程序的自然方式。例如，以下程序计算一串字母中不带变音符号的英语元音和辅音的数量："

#: src/monad-transformers/transformers.md:384
msgid ""
"```lean\n"
"structure LetterCounts where\n"
"  vowels : Nat\n"
"  consonants : Nat\n"
"deriving Repr\n"
"\n"
"inductive Err where\n"
"  | notALetter : Char → Err\n"
"deriving Repr\n"
"\n"
"def vowels :=\n"
"  let lowerVowels := \"aeiuoy\"\n"
"  lowerVowels ++ lowerVowels.map (·.toUpper)\n"
"\n"
"def consonants :=\n"
"  let lowerConsonants := \"bcdfghjklmnpqrstvwxz\"\n"
"  lowerConsonants ++ lowerConsonants.map (·.toUpper )\n"
"\n"
"def countLetters (str : String) : StateT LetterCounts (Except Err) Unit :=\n"
"  let rec loop (chars : List Char) := do\n"
"    match chars with\n"
"    | [] => pure ()\n"
"    | c :: cs =>\n"
"      let st ← get\n"
"      let st' ←\n"
"        if c.isAlpha then\n"
"          if vowels.contains c then\n"
"            pure {st with vowels := st.vowels + 1}\n"
"          else if consonants.contains c then\n"
"            pure {st with consonants := st.consonants + 1}\n"
"          else -- modified or non-English letter\n"
"            pure st\n"
"        else throw (.notALetter c)\n"
"      set st'\n"
"      loop cs\n"
"  loop str.toList\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:421
#, fuzzy
msgid ""
"It would be very easy to write `set st` instead of `set st'`. In a large "
"program, this kind of mistake can lead to difficult-to-diagnose bugs."
msgstr "很容易写成 `set st` 而不是 `set st'`。在一个大型程序中，这种类型的错误可能导致难以诊断的错误。"

#: src/monad-transformers/transformers.md:424
#, fuzzy
msgid ""
"While using a nested action for the call to `get` would solve this problem, "
"it can't solve all such problems. For example, a function might update a "
"field on a structure based on the values of two other fields. This would "
"require two separate nested-action calls to `get`. Because the Lean compiler"
" contains optimizations that are only effective when there is a single "
"reference to a value, duplicating the references to the state might lead to "
"code that is significantly slower. Both the potential performance problem "
"and the potential bug can be worked around by using `modify`, which "
"transforms the state using a function:"
msgstr ""
"虽然对 `get` 调用使用嵌套动作可以解决这个问题，但它不能解决所有此类问题。例如，一个函数可能会根据其他两个字段的值更新结构上的字段。这将需要对 "
"`get` 进行两个单独的嵌套动作调用。由于 Lean "
"编译器包含仅在对值有单个引用时才有效的优化，因此复制对状态的引用可能会导致代码速度显着降低。潜在的性能问题和潜在的错误都可以通过使用 `modify` "
"来解决，它使用函数转换状态："

#: src/monad-transformers/transformers.md:446
#, fuzzy
msgid ""
"The type class contains a function akin to `modify` called `modifyGet`, "
"which allows the function to both compute a return value and transform an "
"old state in a single step. The function returns a pair in which the first "
"element is the return value, and the second element is the new state; "
"`modify` just adds the constructor of `Unit` to the pair used in "
"`modifyGet`:"
msgstr ""
"类型类包含一个类似于 `modify` 的函数，称为 "
"`modifyGet`，它允许函数在一步中计算返回值和转换旧状态。该函数返回一个对，其中第一个元素是返回值，第二个元素是新状态；`modify` 只是将"
" `Unit` 的构造函数添加到 `modifyGet` 中使用的对中："

#: src/monad-transformers/transformers.md:453
#, fuzzy
msgid "The definition of `MonadState` is as follows:"
msgstr "`MonadState` 的定义如下："

#: src/monad-transformers/transformers.md:460
#, fuzzy
msgid ""
"`PUnit` is a version of the `Unit` type that is universe-polymorphic to "
"allow it to be in `Type u` instead of `Type`. While it would be possible to "
"provide a default implementation of `modifyGet` in terms of `get` and `set`,"
" it would not admit the optimizations that make `modifyGet` useful in the "
"first place, rendering the method useless."
msgstr ""
"`PUnit` 是 `Unit` 类型的版本，它是 universe-polymorphic，允许它在 `Type u` 中而不是 `Type` "
"中。虽然可以根据 `get` 和 `set` 提供 `modifyGet` 的默认实现，但它不会承认使 `modifyGet` "
"有用的优化，从而使该方法毫无用处。"

#: src/monad-transformers/transformers.md:463
#, fuzzy
msgid "`Of` Classes and `The` Functions"
msgstr "`Of` 类和 `The` 函数"

#: src/monad-transformers/transformers.md:465
#, fuzzy
msgid ""
"Thus far, each monad type class that takes extra information, like the type "
"of exceptions for `MonadExcept` or the type of the state for `MonadState`, "
"has this type of extra information as an output parameter. For simple "
"programs, this is generally convenient, because a monad that combines one "
"use each of `StateT`, `ReaderT`, and `ExceptT` has only a single state type,"
" environment type, and exception type. As monads grow in complexity, "
"however, they may involve multiple states or errors types. In this case, the"
" use of an output parameter makes it impossible to target both states in the"
" same `do`\\-block."
msgstr ""
"到目前为止，每个获取额外信息的 monad 类型类（例如 `MonadExcept` 的异常类型或 `MonadState` "
"的状态类型）都将此类额外信息作为输出参数。对于简单的程序，这通常很方便，因为结合了 `StateT`、`ReaderT` 和 `ExceptT` 的 "
"monad 只有一个状态类型、环境类型和异常类型。然而，随着 monad "
"的复杂性增加，它们可能涉及多个状态或错误类型。在这种情况下，使用输出参数使得无法在同一个 `do` 块中针对这两个状态。"

#: src/monad-transformers/transformers.md:470
#, fuzzy
msgid ""
"For these cases, there are additional type classes in which the extra "
"information is not an output parameter. These versions of the type classes "
"use the word `Of` in the name. For example, `MonadStateOf` is like "
"`MonadState`, but without an `outParam` modifier."
msgstr ""
"对于这些情况，还有其他类型类，其中额外信息不是输出参数。这些版本的类型类在名称中使用单词 `Of`。例如，`MonadStateOf` 类似于 "
"`MonadState`，但没有 `outParam` 修饰符。"

#: src/monad-transformers/transformers.md:474
#, fuzzy
msgid ""
"Similarly, there are versions of the type class methods that accept the type"
" of the extra information as an _explicit_, rather than implicit, argument. "
"For `MonadStateOf`, there are `getThe` with type"
msgstr "类似地，有类型类方法的版本，它们接受额外信息的类型作为显式（而不是隐式）参数。对于 `MonadStateOf`，有类型为"

#: src/monad-transformers/transformers.md:479
#, fuzzy
msgid "and `modifyThe` with type"
msgstr "的 `getThe` 和类型为"

#: src/monad-transformers/transformers.md:483
#, fuzzy
msgid ""
"There is no `setThe` because the type of the new state is enough to decide "
"which surrounding state monad transformer to use."
msgstr "由于新状态的类型足以决定使用哪个周围状态单子变换器，因此没有 `setThe`。"

#: src/monad-transformers/transformers.md:485
#, fuzzy
msgid ""
"In the Lean standard library, there are instances of the non-`Of` versions "
"of the classes defined in terms of the instances of the versions with `Of`. "
"In other words, implementing the `Of` version yields implementations of "
"both. It's generally a good idea to implement the `Of` version, and then "
"start writing programs using the non-`Of` versions of the class, "
"transitioning to the `Of` version if the output parameter becomes "
"inconvenient."
msgstr ""
"在 Lean 标准库中，有非 `Of` 版本的类实例，这些类实例是根据带有 `Of` 的版本实例定义的。换句话说，实现 `Of` "
"版本会产生两个版本。通常情况下，最好实现 `Of` 版本，然后开始使用非 `Of` 版本的类编写程序，如果输出参数变得不方便，则过渡到 `Of` 版本。"

#: src/monad-transformers/transformers.md:489
#, fuzzy
msgid "Transformers and `Id`"
msgstr "变换器和 `Id`"

#: src/monad-transformers/transformers.md:491
#, fuzzy
msgid ""
"The identity monad `Id` is the monad that has no effects whatsoever, to be "
"used in contexts that expect a monad for some reason but where none is "
"actually necessary. Another use of `Id` is to serve as the bottom of a stack"
" of monad transformers. For instance, `StateT σ Id` works just like `State "
"σ`."
msgstr ""
"恒等单子 `Id` 是没有任何效果的单子，用于在某些原因需要单子但实际上不需要单子的上下文中。`Id` "
"的另一个用途是作为单子变换器堆栈的底部。例如，`StateT σ Id` 的工作方式与 `State σ` 相同。"

#: src/monad-transformers/transformers.md:498
#, fuzzy
msgid "Monad Contract"
msgstr "单子契约"

#: src/monad-transformers/transformers.md:500
#, fuzzy
msgid ""
"Using pencil and paper, check that the rules of the monad transformer "
"contract are satisfied for each monad transformer in this section."
msgstr "使用纸笔，检查本节中每个单子变换器是否满足单子变换器契约的规则。"

#: src/monad-transformers/transformers.md:502
#, fuzzy
msgid "Logging Transformer"
msgstr "日志记录变换器"

#: src/monad-transformers/transformers.md:504
#, fuzzy
msgid ""
"Define a monad transformer version of `WithLog`. Also define the "
"corresponding type class `MonadWithLog`, and write a program that combines "
"logging and exceptions."
msgstr "定义 `WithLog` 的单子变换器版本。还要定义相应的类型类 `MonadWithLog`，并编写一个结合日志记录和异常的程序。"

#: src/monad-transformers/transformers.md:507
#, fuzzy
msgid "Counting Files"
msgstr "计数文件"

#: src/monad-transformers/transformers.md:509
#, fuzzy
msgid ""
"Modify `doug`'s monad with `StateT` such that it counts the number of "
"directories and files seen. At the end of execution, it should display a "
"report like:"
msgstr "使用 `StateT` 修改 `doug` 的单子，以便计算看到的目录和文件数。在执行结束时，它应显示类似以下的报告："
